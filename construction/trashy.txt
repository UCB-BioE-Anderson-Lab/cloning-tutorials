# If needed in Colab, first run:
# !pip -q install rdkit-pypi git+https://github.com/connorcoley/rdchiral.git

from rdkit import Chem
from rdkit.Chem import rdChemReactions as Reactions, Draw
from IPython.display import display, Markdown

import importlib, io, sys, contextlib

# --- special-groups customization & reporting ---
def _describe_special_group_rules():
    from IPython.display import Markdown, display
    description = (
        "Using **custom special-group rules**:\n"
        "- Only consider atoms within **topological distance ≤ 2** of:\n"
        "  - **C=C**, **C=N**, **C=O**, **C=S** double bonds\n"
        "  - **aromatic atoms** (any aromatic ring)\n"
        "- All other rdchiral special groups are ignored."
    )
    display(Markdown(description))


def custom_special_groups(mol, base_fn):
    """
    Restrict special groups to atoms within 2 bonds of:
    - C=C, C=N, C=O, C=S double bonds
    - aromatic atoms

    Returns a filtered structure matching the type/shape of base_fn(mol).
    """
    from rdkit import Chem
    from rdkit.Chem import rdmolops

    # Collect seeds: atoms that lie on specified unsaturations or are aromatic
    allowed_atoms = set()

    # 1) unsaturations: C= [C,N,O,S]
    valid_symbols = {"C", "N", "O", "S"}
    for bond in mol.GetBonds():
        if bond.GetBondType() != Chem.BondType.DOUBLE:
            continue
        a1, a2 = bond.GetBeginAtom(), bond.GetEndAtom()
        s1, s2 = a1.GetSymbol(), a2.GetSymbol()
        if s1 == "C" and s2 in valid_symbols:
            allowed_atoms.add(a1.GetIdx()); allowed_atoms.add(a2.GetIdx())
        elif s2 == "C" and s1 in valid_symbols:
            allowed_atoms.add(a1.GetIdx()); allowed_atoms.add(a2.GetIdx())

    # 2) aromatics
    for atom in mol.GetAtoms():
        if atom.GetIsAromatic():
            allowed_atoms.add(atom.GetIdx())

    # Expand to radius 2 (topological distance)
    if allowed_atoms:
        dmat = rdmolops.GetDistanceMatrix(mol)
        n = mol.GetNumAtoms()
        expanded = set()
        for i in range(n):
            for j in allowed_atoms:
                # dmat is float but contains topological distances
                if dmat[i, j] <= 2.0:
                    expanded.add(i)
        allowed_atoms = expanded

    # Obtain base structure to understand type/shape
    base = base_fn(mol)

    # Helper to extract any atom indices from a group entry
    def _extract_indices(entry):
        # Try dict-like
        if hasattr(entry, 'get'):
            for key in ("atoms", "aids", "atom_ids", "indices", "idxs", "atomIndices"):
                val = entry.get(key)
                if isinstance(val, (list, tuple)) and val and all(isinstance(x, int) for x in val):
                    return set(val)
                if isinstance(val, int):
                    return {val}
        # Try attribute-like
        for key in ("atoms", "aids", "atom_ids", "indices", "idxs", "atomIndices"):
            if hasattr(entry, key):
                val = getattr(entry, key)
                if isinstance(val, (list, tuple)) and val and all(isinstance(x, int) for x in val):
                    return set(val)
                if isinstance(val, int):
                    return {val}
        # Try tuple/list positional ints
        if isinstance(entry, (tuple, list)):
            s = {x for x in entry if isinstance(x, int)}
            if s:
                return s
        return None

    # Now filter `base` to only include entries that touch allowed atoms.
    # Handle common container types conservatively.
    if isinstance(base, dict):
        # Assume mapping from atom-index key or group-id to payload possibly holding indices
        filtered = {}
        for k, v in base.items():
            indices = _extract_indices(v)
            if indices is None and isinstance(k, int):
                indices = {k}
            if not allowed_atoms or (indices and indices & allowed_atoms):
                filtered[k] = v
        return filtered

    if isinstance(base, (list, tuple)):
        kept = []
        for entry in base:
            indices = _extract_indices(entry)
            if not allowed_atoms or (indices and indices & allowed_atoms):
                kept.append(entry)
        return kept

    # Fallback: if unknown type, return base unchanged rather than breaking extraction
    return base

# --- silence rdchiral chatter ---
@contextlib.contextmanager
def _silence():
    _o, _e = sys.stdout, sys.stderr
    try:
        sys.stdout = io.StringIO(); sys.stderr = io.StringIO()
        yield
    finally:
        sys.stdout, sys.stderr = _o, _e

def rdchiral_extract_operator(mapped_rxn: str,
                              *,
                              use_stereo=True,
                              include_all_unmapped_reactant_atoms=False,
                              max_unmapped_product_atoms=5,
                              reactant_radius=1,
                              product_radius=0,
                              enable_special_groups=True,
                              verbose=False,
                              special_groups_fn=None):
    """
    Extract a rdchiral operator from a mapped reaction SMIRKS/SMILES string "left >> right".
    Returns the rdchiral template dict or None on failure.
    """
    te = importlib.import_module("rdchiral.template_extractor")

    # snapshot original globals touched by rdchiral
    _orig = dict(
        VERBOSE=getattr(te, "VERBOSE", False),
        USE_STEREOCHEMISTRY=getattr(te, "USE_STEREOCHEMISTRY", True),
        MAXIMUM_NUMBER_UNMAPPED_PRODUCT_ATOMS=getattr(te, "MAXIMUM_NUMBER_UNMAPPED_PRODUCT_ATOMS", 5),
        INCLUDE_ALL_UNMAPPED_REACTANT_ATOMS=getattr(te, "INCLUDE_ALL_UNMAPPED_REACTANT_ATOMS", True),
        get_fragments_for_changed_atoms=te.get_fragments_for_changed_atoms,
        get_special_groups=te.get_special_groups,
    )

    # apply local settings
    te.VERBOSE = bool(verbose)
    te.USE_STEREOCHEMISTRY = bool(use_stereo)
    te.MAXIMUM_NUMBER_UNMAPPED_PRODUCT_ATOMS = int(max_unmapped_product_atoms)
    te.INCLUDE_ALL_UNMAPPED_REACTANT_ATOMS = bool(include_all_unmapped_reactant_atoms)

    # optionally disable or customize special groups
    if not enable_special_groups:
        te.get_special_groups = lambda mol: []
    elif special_groups_fn is not None:
        # Allow caller to supply a custom function. It should accept (mol, base_fn)
        # and return the same type as rdchiral.template_extractor.get_special_groups.
        base_fn = _orig["get_special_groups"]
        def _custom_get_special_groups(mol):
            return special_groups_fn(mol, base_fn)
        te.get_special_groups = _custom_get_special_groups

    # force radii by wrapping get_fragments_for_changed_atoms
    _gffca_orig = _orig["get_fragments_for_changed_atoms"]
    def _gffca_forced(mols, changed_atom_tags, radius=0, category='reactants', expansion=[]):
        forced = reactant_radius if category == 'reactants' else product_radius
        return _gffca_orig(mols, changed_atom_tags, radius=forced, category=category, expansion=expansion)
    te.get_fragments_for_changed_atoms = _gffca_forced

    # run extraction
    try:
        with _silence():
            tpl = te.extract_from_reaction({"_id": "demo", "reactants": mapped_rxn.split(">>")[0],
                                            "products": mapped_rxn.split(">>")[1]})
    finally:
        # restore globals
        te.VERBOSE = _orig["VERBOSE"]
        te.USE_STEREOCHEMISTRY = _orig["USE_STEREOCHEMISTRY"]
        te.MAXIMUM_NUMBER_UNMAPPED_PRODUCT_ATOMS = _orig["MAXIMUM_NUMBER_UNMAPPED_PRODUCT_ATOMS"]
        te.INCLUDE_ALL_UNMAPPED_REACTANT_ATOMS = _orig["INCLUDE_ALL_UNMAPPED_REACTANT_ATOMS"]
        te.get_fragments_for_changed_atoms = _orig["get_fragments_for_changed_atoms"]
        te.get_special_groups = _orig["get_special_groups"]

    return tpl if isinstance(tpl, dict) and "reaction_smarts" in tpl else None


def summarize_operator(smirks: str):
    rxn = Reactions.ReactionFromSmarts(smirks)
    reactant_smarts = [Chem.MolToSmarts(m) for m in rxn.GetReactants()]
    has_dbond = any("=" in s for s in reactant_smarts if s)
    return {
        "smirks": smirks,
        "reactant_templates": reactant_smarts,
        "has_pi_in_reactant_templates": has_dbond,
    }

# Print the active special-group rules once
_describe_special_group_rules()

def run(label: str, mapped_smirks: str):
    display(Markdown(f"### {label}"))
    settings_line = "SG=custom(C=C/C=N/C=O/C=S + aromatic, d≤2), r=1, p=0, incl_all_unmapped=False, stereo=True"
    tpl = rdchiral_extract_operator(
        mapped_smirks,
        use_stereo=True,
        include_all_unmapped_reactant_atoms=True,
        reactant_radius=1,
        product_radius=0,
        enable_special_groups=True,
        verbose=False,
        special_groups_fn=custom_special_groups,
    )
    display(Markdown(f"- **Settings:** {settings_line}"))
    if not tpl:
        display(Markdown("- **Result:** extraction failed"))
        return
    info = summarize_operator(tpl["reaction_smarts"])
    short = info["smirks"] if len(info["smirks"]) < 180 else info["smirks"][:180] + "…"
    display(Markdown(f"- **π in reactant template:** {'✅' if info['has_pi_in_reactant_templates'] else '—'}"))
    display(Markdown(f"- **Operator (SMIRKS):**\n\n```\n{short}\n```"))
    try:
        img = Draw.ReactionToImage(Reactions.ReactionFromSmarts(info["smirks"]), subImgSize=(360, 240))
        display(img)
    except Exception:
        pass

# --- Your seven examples ---
examples = [
    ("ethanol",
     "[C:4][C:1][O:20]>>[C:4][C:1][O:20][C]"),
    ("vinyl alcohol",
     "[C:4]=[C:1][O:20]>>[C:4]=[C:1][O:20][C]"),
    ("allyl alcohol",
     "[C:4]=[C:5][C:1][O:20]>>[C:4]=[C:5][C:1][O:20][C]"),
    ("dibutenyl alcohol",
     "[C:6]=[C:5][C:4]=[C:1][O:20]>>[C:6]=[C:5][C:4]=[C:1][O:20][C]"),
    ("phenol",
     "[c:7]1[c:6][c:5][c:4][c:3][c:1]1[O:20]>>[c:7]1[c:6][c:5][c:4][c:3][c:2]1[O:20][C]"),
    ("benzyl alcohol",
     "[c:7]1[c:6][c:5][c:4][c:3][c:2]1[C:8][O:20]>>[c:7]1[c:6][c:5][c:4][c:3][c:2]1[C:8][O:20][C]"),
    ("phenethyl alcohol",
     "[c:7]1[c:6][c:5][c:4][c:3][c:2]1[C:8][C:9][O:20]>>[c:7]1[c:6][c:5][c:4][c:3][c:2]1[C:8][C:9][O:20][C]"),
    



    ("ethyl chloride",
     "[C:4][C:1][Cl]>>[C:4][C:1][O][C]"),
    ("vinyl chloride",
     "[C:4]=[C:1][Cl]>>[C:4]=[C:1][O][C]"),
    ("allyl chloride",
     "[C:4]=[C:5][C:1][Cl]>>[C:4]=[C:5][C:1][O][C]"),
    ("dibutenyl chloride",
     "[C:6]=[C:5][C:4]=[C:1][Cl]>>[C:6]=[C:5][C:4]=[C:1][O][C]"),
    ("polyene chloride",
     "[C:10]=[C:9][C:8]=[C:7][C:6]=[C:5][C:4]=[C:1][Cl]>>[C:10]=[C:9][C:8]=[C:7][C:6]=[C:5][C:4]=[C:1][O][C]"),
    ("chlorobenzene",
     "[c:7]1[c:6][c:5][c:4][c:3][c:2]1[Cl]>>[c:7]1[c:6][c:5][c:4][c:3][c:2]1[O][C]"),
    ("benzyl chloride",
     "[c:7]1[c:6][c:5][c:4][c:3][c:2]1[C:8][Cl]>>[c:7]1[c:6][c:5][c:4][c:3][c:2]1[C:8][O][C]"),
    ("phenethyl chloride",
     "[c:7]1[c:6][c:5][c:4][c:3][c:2]1[C:8][C:9][Cl]>>[c:7]1[c:6][c:5][c:4][c:3][c:2]1[C:8][C:9][O][C]"),
    
    ("Long-Range Michael Addition",
     "[C:1]=[C:2][C:3]=[C:4][C:5]=[C:6][C:7]=[C:8][C:9]=[C:10][C:11]=[C:12][C:13]=[O]>>[C][S][C:1][C:2][C:3]=[C:4][C:5]=[C:6][C:7]=[C:8][C:9]=[C:10][C:11]=[C:12][C:13]=[O]"),
]


display(Markdown("## RDChiral extraction for the seven mapped tests"))
for label, smirks in examples:
    run(label, smirks)