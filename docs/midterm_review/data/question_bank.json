{
  "core_types_and_containers": [
    {
      "slug": "name-binding-shared-list",
      "difficulty": "medium",
      "topic": "Understanding that variable assignment creates shared references, not independent copies",
      "question": "A construct's sequence is stored in a list of parts. A colleague saves\na reference to work with it:\n\n<python>\nparts = ['J23119', 'B0034', 'amilGFP']\nmy_copy = parts\nmy_copy.append('B0015')\n</python>\n\nHow many elements does parts contain?\n",
      "choices": {
        "A": "3 — my_copy is a separate list",
        "B": "4 — both names refer to the same list",
        "C": "4 — append always modifies all lists in the program",
        "D": "TypeError — you cannot append to a referenced list"
      },
      "answer": "B",
      "explanation": "Assignment (my_copy = parts) binds a second name to the same list object.\nIt does not create a copy. Appending through my_copy mutates the shared\nlist, so parts also has 4 elements. This matters in genetic design code\nwhere a construct's parts list may be passed to multiple functions — any\nmutation through one reference is visible to all others.\n"
    },
    {
      "slug": "string-substring-search",
      "difficulty": "medium",
      "topic": "Using string operations to answer questions about sequence content",
      "question": "A codon optimization function must verify that a designed CDS does not\ncontain the BsaI recognition site <pre>GGTCTC</pre>. Given:\n\n<python>\ncds = 'ATGAACGGTCTCAAATAA'\n</python>\n\nWhich of the following correctly detects the forbidden site?\n",
      "choices": {
        "A": "'GGTCTC' in cds",
        "B": "cds['GGTCTC']",
        "C": "cds.count('GGTCTC') > 1",
        "D": "cds == 'GGTCTC'"
      },
      "answer": "A",
      "explanation": "The 'in' operator checks whether the left string appears as a contiguous\nsubstring anywhere in the right string. Here <pre>GGTCTC</pre> is embedded starting\nat index 8, so the expression returns True. Option B treats a string as a\ndict (TypeError). Option C only flags the site if it appears more than\nonce, missing the single occurrence. Option D checks whether the entire CDS\nequals the site. The biological point: a single occurrence of a forbidden\nrestriction site is enough to disrupt a fabrication plan.\n"
    },
    {
      "slug": "dict-as-lookup-table",
      "difficulty": "medium",
      "topic": "Forward vs. reverse lookup in a dict and what the key-value direction implies",
      "question": "The genetic code is stored as a dict mapping codons to amino acids:\n\n<python>\ngenetic_code = {'ATG': 'M', 'TTT': 'F', 'TTC': 'F', 'TAA': '*', ...}\n</python>\n\nA student wants to reverse-translate a protein — given an amino acid,\nfind all codons that encode it. They write:\n\n<python>\ngenetic_code['F']\n</python>\n\nWhat happens?\n",
      "choices": {
        "A": "Returns ['TTT', 'TTC']",
        "B": "Returns 'TTT'",
        "C": "KeyError — 'F' is a value in this dict, not a key",
        "D": "Returns 'F'"
      },
      "answer": "C",
      "explanation": "Dict lookup is by key. The keys are codons ('ATG', 'TTT', etc.), not amino\nacids. 'F' is not a key, so a KeyError is raised. To find codons for an\namino acid, you must iterate over items and filter by value. This reflects\na fundamental design choice: the genetic code dict is structured for\ntranslation (codon → amino acid), and reverse translation requires a\ndifferent access pattern.\n"
    },
    {
      "slug": "none-guarding-operations",
      "difficulty": "medium",
      "topic": "Handling absent or optional data and ensuring operations are valid before applying them",
      "question": "An RBSChooser function returns an RBSOption object when it finds a\nsuitable ribosome binding site, or None when no candidate passes the\nfilters. A caller writes:\n\n<python>\nresult = rbs_chooser.run(cds)\nutr = result.utr\n</python>\n\nIf the chooser found no valid RBS for this CDS, what happens?\n",
      "choices": {
        "A": "utr is set to None",
        "B": "utr is set to an empty string",
        "C": "AttributeError — None has no attribute 'utr'",
        "D": "The function silently returns a default RBS"
      },
      "answer": "C",
      "explanation": "When the chooser returns None, accessing .utr on None raises an\nAttributeError. None is not an object with fields — it represents the\nabsence of a result. The caller must check whether result is None before\naccessing its attributes. This is a general pattern: any function that can\nfail to produce a result may return None, and callers must handle that case\nbefore proceeding.\n"
    },
    {
      "slug": "modeling-for-domain-inference",
      "difficulty": "medium",
      "topic": "Modeling a biological object as a data structure and making domain inferences from it",
      "question": "A strain and a plasmid are modeled as:\n\n<python>\nstrain = {'name': 'Mach1', 'resistances': {'AmpR', 'KanR'}}\nplasmid = {'name': 'pUC19', 'marker': 'AmpR'}\n</python>\n\nYou want to check whether the strain already carries the plasmid's\nresistance marker (which would make antibiotic selection unreliable).\nWhich expression performs this check?\n",
      "choices": {
        "A": "plasmid['marker'] in strain['resistances']",
        "B": "strain['resistances'] == plasmid['marker']",
        "C": "plasmid['marker'] in strain['name']",
        "D": "strain['resistances'].append(plasmid['marker'])"
      },
      "answer": "A",
      "explanation": "strain['resistances'] is a set, and 'in' checks membership. Here 'AmpR'\nis in the set, meaning the strain is already resistant and plating on\nampicillin would not distinguish transformants from background. Option B\ncompares a set to a string (always False). Option C checks if 'AmpR' is a\nsubstring of 'Mach1' (nonsensical). Option D calls .append() on a set,\nwhich raises AttributeError — sets use .add(). Answering correctly\nrequires understanding both the Python types and why pre-existing\nresistance defeats selection.\n"
    },
    {
      "slug": "boolean-validation-logic",
      "difficulty": "medium",
      "topic": "Using boolean expressions to enforce domain constraints on computed values",
      "question": "An oligo design function checks whether the Tm and length of a primer\nare within acceptable bounds:\n\n<python>\ntm = 58.5\nlength = 22\nok = tm >= 55 and tm <= 65 and length >= 18 and length <= 30\n</python>\n\nA second primer has tm = 72.0 and length = 40. What is the value of\nok for each?\n",
      "choices": {
        "A": "True for the first, True for the second",
        "B": "True for the first, False for the second",
        "C": "False for both — all four conditions must use 'or'",
        "D": "True for both — 'and' only requires one condition to be True"
      },
      "answer": "B",
      "explanation": "For the first primer, all four conditions hold, so ok is True. For the\nsecond, tm > 65 and length > 30, so two conditions fail and 'and' returns\nFalse. The 'and' operator requires every condition to be True. This pattern\nencodes the biological reality that a primer must satisfy multiple\nsimultaneous constraints to function — too hot a Tm or too long an oligo\nwill cause problems even if the other values look fine.\n"
    },
    {
      "slug": "container-choice-for-data",
      "difficulty": "medium",
      "topic": "Selecting a container type based on the properties of the data it must hold",
      "question": "You are designing a data structure to represent a genetic construct.\nIt has an ordered series of CDS names that may repeat (e.g. two copies\nof the same gene in an operon), and a collection of restriction enzyme\nsites that must be absent from the final sequence (no duplicates matter,\norder is irrelevant).\n\nWhich pair of container types best fits these two needs?\n",
      "choices": {
        "A": "list for the CDS names, set for the forbidden sites",
        "B": "set for the CDS names, list for the forbidden sites",
        "C": "dict for the CDS names, set for the forbidden sites",
        "D": "list for both"
      },
      "answer": "A",
      "explanation": "The CDS names are ordered and may contain duplicates, so a list is the\nright fit. The forbidden sites are an unordered collection where only\nmembership matters, so a set is natural — it enforces uniqueness and\nmakes 'in' checks efficient. Option B would lose gene order and\nduplicates, which changes the operon structure. Option C has no natural\nkey to use. Option D works mechanically but forces you to manually\nprevent duplicates in the forbidden sites.\n"
    },
    {
      "slug": "tuple-immutability-consequence",
      "difficulty": "medium",
      "topic": "Immutable containers as fixed records and the consequences of immutability",
      "question": "Proteomics data is loaded as a list of tuples, which are immutable:\n\n<python>\ndata = [('b0002', 498), ('b0003', 181), ('b0004', 889)]\n</python>\n\nYou want to correct an error in the abundance of b0003. You write:\n\n<python>\ndata[1][1] = 200\n</python>\n\nWhat happens?\n",
      "choices": {
        "A": "The abundance of b0003 is updated to 200",
        "B": "TypeError — tuples do not support item assignment",
        "C": "IndexError — tuples can only be accessed at index 0",
        "D": "The entire tuple is replaced with 200"
      },
      "answer": "B",
      "explanation": "data[1] retrieves the tuple ('b0003', 181), but tuples are immutable — you\ncannot change their elements in place. To correct the value, you would need\nto replace the entire tuple: data[1] = ('b0003', 200). This immutability\nis a feature when loading experimental data: it prevents accidental\nmodification of the original measurements, forcing you to be explicit about\nany changes.\n"
    },
    {
      "slug": "restructuring-for-access-pattern",
      "difficulty": "medium",
      "topic": "Choosing how to organize data into containers based on what questions you need to answer",
      "question": "You have a list of (gene_id, abundance) tuples from a proteomics\nexperiment:\n\n<python>\ndata = [('b0002', 498), ('b0003', 181), ('b0004', 889), ...]\n</python>\n\nYou need to repeatedly look up abundances by gene ID. You convert to:\n\n<python>\nby_gene = {gid: ab for gid, ab in data}\n</python>\n\nA colleague instead keeps the original list and uses:\n\n<python>\n[ab for gid, ab in data if gid == 'b0004'][0]\n</python>\n\nBoth return 889 for 'b0004'. Why is the dict preferable?\n",
      "choices": {
        "A": "The dict finds the value directly by key; the list must scan every entry",
        "B": "The dict uses less memory because it discards the gene IDs",
        "C": "The list version returns a different data type",
        "D": "There is no meaningful difference — both are equivalent"
      },
      "answer": "A",
      "explanation": "Dict lookup by key is a direct operation. The list comprehension must\niterate through every tuple and compare gene IDs until it finds a match.\nWhen you need repeated random access by an identifier — as when multiple\ndesign functions each need to check different genes' expression levels —\nrestructuring from a list of records to a dict keyed by identifier is the\nstandard move. The choice of container should match the dominant access\npattern.\n"
    },
    {
      "slug": "filtering-structured-records",
      "difficulty": "medium",
      "topic": "Filtering and projecting fields from a collection of structured records",
      "question": "RBS candidates are stored as a list of dicts:\n\n<python>\noptions = [\n    {'source': 'rpsA', 'utr': 'AAAGAGG...', 'hairpins': 0},\n    {'source': 'cspA', 'utr': 'AAGAAGG...', 'hairpins': 3},\n    {'source': 'ompA', 'utr': 'AAGGAG...', 'hairpins': 1},\n]\n</python>\n\nYou want the source gene names of candidates with no predicted\nhairpins. Which expression produces them?\n",
      "choices": {
        "A": "[opt['source'] for opt in options if opt['hairpins'] == 0]",
        "B": "options['hairpins' == 0]",
        "C": "[opt for opt in options if opt['hairpins'] == 0]",
        "D": "options.filter('hairpins', 0)"
      },
      "answer": "A",
      "explanation": "The list comprehension iterates over options, keeps entries where hairpins\nis 0, and extracts the 'source' field, yielding ['rpsA']. Option B tries\nto index a list with a boolean expression (TypeError). Option C returns\nthe full dicts, not just the gene names. Option D invents a .filter()\nmethod that lists do not have. The pattern of filtering records by a\ncriterion and projecting a specific field is used throughout the course —\nfor selecting RBS candidates, filtering proteomics hits, or querying\na parts registry."
    }
  ],
  "control_flow_and_iteration": [
    {
      "slug": "tracing-a-loop-over-sequence",
      "difficulty": "medium",
      "topic": "Tracing a for loop step-by-step to predict what it builds from sequential data",
      "question": "A function translates a DNA coding sequence one codon at a time:\n\n<python>\ngenetic_code = {'ATG': 'M', 'AAA': 'K', 'GGT': 'G', 'TAA': '*'}\ncds = 'ATGAAAGGT'\nprotein = ''\nfor i in range(0, len(cds), 3):\n    codon = cds[i:i+3]\n    protein += genetic_code[codon]\n</python>\n\nWhat is the value of protein after the loop finishes?\n",
      "choices": {
        "A": "MKG",
        "B": "ATGAAAGGT",
        "C": "M",
        "D": "KeyError is raised"
      },
      "answer": "A",
      "explanation": "The loop steps through the string in increments of 3. On the first\niteration i=0 gives codon 'ATG' → 'M'. Then i=3 gives 'AAA' → 'K'.\nThen i=6 gives 'GGT' → 'G'. The concatenation builds 'MKG'. Option B\nconfuses the DNA with the protein. Option C would result if the loop\nonly ran once. Option D would occur if a codon were not in the table,\nbut all three are present.\n"
    },
    {
      "slug": "if-elif-else-classification",
      "difficulty": "medium",
      "topic": "Using branching logic to classify items into categories based on multiple criteria",
      "question": "A function classifies genes by their proteomics abundance:\n\n<python>\ndef classify(abundance):\n    if abundance > 1000:\n        return 'high'\n    elif abundance > 100:\n        return 'medium'\n    elif abundance > 0:\n        return 'low'\n    else:\n        return 'not detected'\n</python>\n\nWhat does classify(100) return?\n",
      "choices": {
        "A": "high",
        "B": "medium",
        "C": "low",
        "D": "not detected"
      },
      "answer": "C",
      "explanation": "The conditions are tested in order. 100 > 1000 is False. 100 > 100 is\nalso False (not strictly greater). 100 > 0 is True, so 'low' is returned.\nA common mistake is reading > as >=. The elif chain ensures exactly one\nbranch executes, and the order of the conditions determines the boundary\nbehavior — a student must trace through each condition to find which one\nfires first.\n"
    },
    {
      "slug": "early-exit-with-break",
      "difficulty": "medium",
      "topic": "Using break to stop iteration once a condition is met, and understanding what value is retained",
      "question": "A function finds the position of the first <pre>GG</pre> dinucleotide in a\nsequence, which could indicate a PAM site:\n\n<python>\nseq = 'ATCAGATGGCCA'\nposition = -1\nfor i in range(len(seq) - 1):\n    if seq[i:i+2] == 'GG':\n        position = i\n        break\n</python>\n\nWhat is the value of position?\n",
      "choices": {
        "A": 7,
        "B": 8,
        "C": -1,
        "D": 3
      },
      "answer": "A",
      "explanation": "The loop scans left to right. At i=7, seq[7:9] is 'GG' (the G's in\n<pre>ATCAGATGGCCA</pre>). The position is set to 7 and break exits the loop\nimmediately. Without break, the loop would continue and could overwrite\nposition if another 'GG' existed later. The -1 sentinel remains only if\nno 'GG' is found at all. This pattern — scanning for the first occurrence\nof a motif and stopping — is used in CRISPR target finding and restriction\nsite scanning.\n"
    },
    {
      "slug": "continue-to-skip-invalid",
      "difficulty": "medium",
      "topic": "Using continue to skip entries that fail a validity check while processing the rest",
      "question": "A function collects abundances for genes that have proteomics data,\nskipping entries marked as missing:\n\n<python>\ndata = [('b0002', 498), ('b0003', None), ('b0004', 889), ('b0005', None)]\nvalid = []\nfor gene_id, abundance in data:\n    if abundance is None:\n        continue\n    valid.append(abundance)\n</python>\n\nWhat is the value of valid?\n",
      "choices": {
        "A": "[498, 889]",
        "B": "[498, None, 889, None]",
        "C": "[('b0002', 498), ('b0004', 889)]",
        "D": "[] — continue skips all remaining iterations"
      },
      "answer": "A",
      "explanation": "When abundance is None, continue skips the rest of the loop body and\nmoves to the next tuple. It does not skip all remaining iterations —\nonly the current one. For the two non-None entries, abundance is appended\nto valid. Option B would result if there were no skip logic. Option C\nwould result if the entire tuple were appended. Option D reflects a\ncommon misconception that continue exits the loop entirely (that's break).\n"
    },
    {
      "slug": "iterating-over-dict-items",
      "difficulty": "medium",
      "topic": "Iterating over key-value pairs in a dict to accumulate or transform structured data",
      "question": "A codon frequency table stores how often each codon appears in\nhighly-expressed E. coli genes. You want to find the most frequent\ncodon for proline:\n\n<python>\npro_codons = {'CCT': 27340, 'CCC': 19666, 'CCA': 31534, 'CCG': 76644}\nbest_codon = None\nbest_count = 0\nfor codon, count in pro_codons.items():\n    if count > best_count:\n        best_codon = codon\n        best_count = count\n</python>\n\nWhat is the value of best_codon?\n",
      "choices": {
        "A": "CCG",
        "B": "CCT",
        "C": "CCA",
        "D": "None — the loop never updates best_codon"
      },
      "answer": "A",
      "explanation": "The loop examines each codon-count pair. CCT (27340) beats the initial 0,\nthen CCC (19666) does not beat 27340, CCA (31534) beats 27340, and finally\nCCG (76644) beats 31534. The last update wins, leaving best_codon as 'CCG'.\nThis is a standard argmax pattern over dict items — the same logic applies\nto finding the best RBS candidate, the highest-abundance gene, or the most\ncommon codon context pair.\n"
    },
    {
      "slug": "nested-loop-combinatorics",
      "difficulty": "medium",
      "topic": "Using nested loops to enumerate combinations and understanding how iteration count scales",
      "question": "A reverse translation function enumerates all possible two-codon\nsequences for the dipeptide Met-Lys:\n\n<python>\nmet_codons = ['ATG']\nlys_codons = ['AAA', 'AAG']\ncombos = []\nfor m in met_codons:\n    for k in lys_codons:\n        combos.append(m + k)\n</python>\n\nHow many elements are in combos, and what would happen if Lys had 6\nsynonymous codons instead of 2?\n",
      "choices": {
        "A": "2 elements now; 6 if Lys had 6 codons",
        "B": "2 elements now; 12 if Lys had 6 codons",
        "C": "3 elements now; 7 if Lys had 6 codons",
        "D": "2 elements now; 6^2 = 36 if Lys had 6 codons"
      },
      "answer": "A",
      "explanation": "Nested loops produce the product of the iteration counts: 1 × 2 = 2. With\n6 Lys codons it would be 1 × 6 = 6. Option B incorrectly doubles again.\nOption C adds instead of multiplies. Option D squares the Lys count. This\ncombinatorial explosion is why enumerating all possible codon sequences for\na full protein is infeasible — each additional amino acid multiplies the\ncount by its number of synonymous codons.\n"
    },
    {
      "slug": "while-loop-convergence",
      "difficulty": "medium",
      "topic": "Using a while loop that repeats until a condition is satisfied, and reasoning about termination",
      "question": "A guided-random codon optimizer generates candidate CDS sequences\nuntil one passes a forbidden-sequence check:\n\n<python>\nimport random\nrandom.seed(42)\nattempts = 0\npassed = False\nwhile not passed:\n    candidate = generate_random_cds(protein)\n    passed = not has_forbidden_sites(candidate)\n    attempts += 1\n</python>\n\nWhich of the following is true about this loop?\n",
      "choices": {
        "A": "It could run forever if no valid CDS exists for this protein",
        "B": "It always terminates after exactly one iteration",
        "C": "It terminates after a fixed number of iterations regardless of input",
        "D": "Setting the seed guarantees it runs exactly once"
      },
      "answer": "A",
      "explanation": "The while loop repeats as long as passed is False. If every possible CDS\nfor this protein contains a forbidden site, the loop never terminates. The\nseed makes the random sequence reproducible but does not guarantee that the\nfirst (or any) candidate will pass. In practice, a well-designed version\nwould include a maximum iteration count to avoid infinite loops. This is a\nreal concern in codon optimization — the guided random method must handle\nthe possibility that constraints are unsatisfiable.\n"
    },
    {
      "slug": "loop-accumulator-pattern",
      "difficulty": "medium",
      "topic": "Building up a result incrementally inside a loop and understanding the final accumulated value",
      "question": "A function builds the reverse complement of a DNA sequence:\n\n<python>\ncomplement = {'A': 'T', 'T': 'A', 'C': 'G', 'G': 'C'}\ndna = 'ATCG'\nresult = ''\nfor base in dna:\n    result = complement[base] + result\n</python>\n\nWhat is the value of result?\n",
      "choices": {
        "A": "CGAT",
        "B": "TAGC",
        "C": "GCTA",
        "D": "ATCG"
      },
      "answer": "A",
      "explanation": "Each complemented base is prepended to result (added to the left). Step by\nstep: '' → 'T' → 'AT' → 'GAT' → 'CGAT'. Prepending reverses the order\nwhile the complement dict handles the base pairing. Option B would be the\nresult of complementing without reversing. Option C would result from\nreversing without complementing. Option D is the original sequence. Getting\nthis right requires tracing both the complement lookup and the prepend\naccumulation through each iteration.\n"
    },
    {
      "slug": "conditional-guard-before-operation",
      "difficulty": "medium",
      "topic": "Using an if-check inside a loop to guard against invalid operations on certain elements",
      "question": "A function processes a mixed-case DNA sequence, skipping any character\nthat is not a valid base:\n\n<python>\nseq = 'ATCnGNtt'\ncleaned = ''\nfor ch in seq.upper():\n    if ch in 'ATCG':\n        cleaned += ch\n</python>\n\nWhat is the value of cleaned?\n",
      "choices": {
        "A": "ATCGTT",
        "B": "ATCnGNtt",
        "C": "ATCG",
        "D": "ValueError is raised on 'n'"
      },
      "answer": "A",
      "explanation": "seq.upper() converts to 'ATCNGTT'. The loop checks each character against\n'ATCG'. 'A', 'T', 'C' pass. 'N' fails the check and is skipped. 'G', 'T',\n'T' pass. The result is 'ATCGTT'. This is the pattern from lecture where\nreverse_complement silently skipped invalid bases — except here the intent\nis explicit filtering rather than a silent bug. The guard ensures only\nvalid bases are processed without raising an error.\n"
    },
    {
      "slug": "iteration-order-matters",
      "difficulty": "medium",
      "topic": "Understanding that the order of iteration affects the result when operations are position-dependent",
      "question": "Two functions both scan a sequence for all <pre>GG</pre> dinucleotides, but\none scans left-to-right and the other right-to-left:\n\n<python>\nseq = 'GGGAT'\n\n# Left to right\nhits_lr = []\nfor i in range(len(seq) - 1):\n    if seq[i:i+2] == 'GG':\n        hits_lr.append(i)\n\n# Right to left\nhits_rl = []\nfor i in range(len(seq) - 2, -1, -1):\n    if seq[i:i+2] == 'GG':\n        hits_rl.append(i)\n</python>\n\nWhat are hits_lr and hits_rl?\n",
      "choices": {
        "A": "[0, 1] and [1, 0] — same positions, different order",
        "B": "Both are [0, 1] — iteration order does not affect which positions match",
        "C": "hits_lr is [0] and hits_rl is [1] — each finds only one",
        "D": "hits_lr is [0, 1] and hits_rl is [0, 1] — same list"
      },
      "answer": "A",
      "explanation": "<pre>GGGAT</pre> has 'GG' at positions 0 and 1 (overlapping). Both loops find both\npositions because the match condition is the same regardless of scan\ndirection. But hits_lr appends them as [0, 1] while hits_rl appends them\nas [1, 0]. The positions found are identical; the order in the output list\ndiffers. This matters when you want the *first* or *last* occurrence — for\nexample, finding the PAM-proximal vs. PAM-distal target site in a CRISPR\ndesign depends on which direction you scan."
    }
  ],
  "functions_parameters_and_scope": [
    {
      "slug": "return-vs-print-in-design",
      "difficulty": "medium",
      "topic": "Understanding that functions communicate results through return values, not side effects",
      "question": "A student writes a function to translate a CDS into a protein:\n\n<python>\ndef translate(cds, genetic_code):\n    protein = ''\n    for i in range(0, len(cds), 3):\n        codon = cds[i:i+3]\n        protein += genetic_code[codon]\n    print(protein)\n\nresult = translate('ATGAAATAA', genetic_code)\n</python>\n\nThey then try to check if the protein starts with methionine:\n\n<python>\nresult.startswith('M')\n</python>\n\nWhat happens?\n",
      "choices": {
        "A": "Returns True — the protein starts with 'M'",
        "B": "AttributeError — result is None because the function prints but does not return",
        "C": "Returns False — print converts the protein to a different format",
        "D": "NameError — protein is not accessible outside the function"
      },
      "answer": "B",
      "explanation": "The function uses print() instead of return, so it displays the protein\nto the console but returns None by default. Calling .startswith() on None\nraises an AttributeError. Option A would be correct if the function used\nreturn instead of print. Option C invents a conversion that print does not\nperform. Option D describes a real scoping fact — protein is local — but\nthe immediate error is the None return, not a NameError.\n"
    },
    {
      "slug": "local-scope-isolation",
      "difficulty": "medium",
      "topic": "Recognizing that local variables inside a function are invisible to the caller",
      "question": "A function computes the GC content of a DNA sequence:\n\n<python>\ndef gc_content(seq):\n    gc_count = 0\n    for base in seq:\n        if base in 'GC':\n            gc_count += 1\n    fraction = gc_count / len(seq)\n    return fraction\n\nresult = gc_content('ATGCGC')\nprint(gc_count)\n</python>\n\nWhat happens when print(gc_count) executes?\n",
      "choices": {
        "A": "Prints 4 — gc_count was computed inside the function",
        "B": "Prints 0 — gc_count is reset after the function returns",
        "C": "NameError — gc_count is local to gc_content and does not exist in the caller's scope",
        "D": "Prints 0.667 — gc_count holds the fraction, not the count"
      },
      "answer": "C",
      "explanation": "Variables created inside a function are local to that function. They exist\nonly while the function is executing and are not visible to the caller.\nThe function correctly computes gc_count = 4 and returns 0.667, but\ngc_count itself is not accessible outside. Option A assumes local variables\nleak into the caller's namespace. Option B invents a reset mechanism.\nOption D confuses gc_count with fraction. The caller must use the returned\nvalue (result) to access the computation's output.\n"
    },
    {
      "slug": "default-argument-override",
      "difficulty": "medium",
      "topic": "Using default arguments to provide sensible fallbacks that callers can override",
      "question": "A CRISPR guide RNA design function has a default PAM:\n\n<python>\ndef find_targets(seq, pam='NGG'):\n    targets = []\n    for i in range(len(seq) - len(pam)):\n        if matches_pam(seq[i:i+len(pam)], pam):\n            targets.append(i)\n    return targets\n\na = find_targets(genome_seq)\nb = find_targets(genome_seq, 'NGG')\nc = find_targets(genome_seq, 'NNGRRT')\n</python>\n\nWhich calls use the Cas9 PAM <pre>NGG</pre> and which use <pre>NNGRRT</pre>?\n",
      "choices": {
        "A": "a and b use 'NGG'; c uses 'NNGRRT'",
        "B": "Only b uses 'NGG'; a uses None because no argument was provided",
        "C": "All three use 'NGG' — the default cannot be overridden",
        "D": "a uses 'NGG'; b and c both raise errors for passing a second argument"
      },
      "answer": "A",
      "explanation": "When no argument is provided for pam, the default 'NGG' is used (call a).\nPassing 'NGG' explicitly (call b) has the same effect. Passing 'NNGRRT'\n(call c) overrides the default with the Cas12a/SaCas9 PAM. Option B\nconfuses default values with None — the default is 'NGG', not the absence\nof a value. Option C claims defaults are locked. Option D invents a\nrestriction on passing optional arguments. Default arguments let a function\nserve the common case (Cas9) while remaining flexible for alternatives.\n"
    },
    {
      "slug": "pure-function-no-side-effects",
      "difficulty": "medium",
      "topic": "Distinguishing pure functions from those with side effects and understanding why purity aids testing",
      "question": "Two implementations of reverse_complement are proposed:\n\n<python>\n# Version A\ncomplement_table = {}\ndef reverse_complement_a(seq):\n    complement_table['last_input'] = seq\n    comp = seq.translate(str.maketrans('ATCG', 'TAGC'))\n    return comp[::-1]\n\n# Version B\ndef reverse_complement_b(seq):\n    comp = seq.translate(str.maketrans('ATCG', 'TAGC'))\n    return comp[::-1]\n</python>\n\nBoth return the correct reverse complement. Why is Version B preferred\nfor use in a design pipeline?\n",
      "choices": {
        "A": "Version B is a pure function — same input always gives the same output with no side effects",
        "B": "Version A is slower because dicts are slow",
        "C": "Version B handles lowercase input and Version A does not",
        "D": "Version A returns a different result each time it is called"
      },
      "answer": "A",
      "explanation": "Version A modifies the global complement_table every time it is called,\nwhich is a side effect. Pure functions like Version B depend only on their\ninputs and produce only their return value. This makes Version B easier\nto test, compose, and parallelize — you never need to worry about hidden\nstate changes. Option B invents a performance issue. Option C is wrong\nbecause neither handles lowercase. Option D is wrong because A returns the\nsame result — it just also mutates external state, which is the problem.\n"
    },
    {
      "slug": "function-as-reusable-unit",
      "difficulty": "medium",
      "topic": "Recognizing when repeated logic should be extracted into a function and how arguments generalize it",
      "question": "A student writes code to check for forbidden restriction sites in a\ndesigned gene:\n\n<python>\nhas_ecori = 'GAATTC' in cds\nhas_bsai = 'GGTCTC' in cds\nhas_bsai_rc = 'GAGACC' in cds\nhas_ecori_rc = 'GAATTC' in cds\n</python>\n\nThey realize the pattern repeats. Which refactoring best captures\nthe shared logic?\n",
      "choices": {
        "A": "<python>\ndef has_site(seq, site):\n    rc = reverse_complement(site)\n    return site in seq or rc in seq\n</python>\n",
        "B": "<python>\ndef has_site(seq):\n    return 'GAATTC' in seq or 'GGTCTC' in seq\n</python>\n",
        "C": "<python>\ndef has_site(site):\n    return site in cds\n</python>\n",
        "D": "<python>\ndef has_site():\n    return True\n</python>\n"
      },
      "answer": "A",
      "explanation": "Option A takes both the sequence and the site as parameters, checks the\nsite and its reverse complement, and returns a boolean. This works for any\nrestriction site on any sequence. Option B hardcodes specific sites, so it\nis not reusable for other enzymes. Option C captures the site parameter\nbut relies on cds from the outer scope — it is not self-contained and\nbreaks if called from a different context. Option D is trivially useless.\nThe key insight is that a well-designed function parameterizes everything\nthat varies across use cases.\n"
    },
    {
      "slug": "initiate-run-lifecycle",
      "difficulty": "medium",
      "topic": "Understanding the two-phase pattern of configuring an algorithm object then executing it",
      "question": "The RBSChooser class uses an initiate/run pattern:\n\n<python>\nchooser = RBSChooser()\nchooser.initiate()       # loads proteomics data and builds lookup tables\nresult = chooser.run(cds)  # designs an RBS for the given CDS\n</python>\n\nA student tries to skip initiation:\n\n<python>\nchooser2 = RBSChooser()\nresult2 = chooser2.run(cds)\n</python>\n\nWhat is the most likely outcome?\n",
      "choices": {
        "A": "It works — initiate is optional and run loads data on demand",
        "B": "AttributeError or KeyError — run depends on data structures that initiate creates",
        "C": "result2 is None — run detects missing initialization and returns nothing",
        "D": "TypeError — run cannot be called on an uninitialized object"
      },
      "answer": "B",
      "explanation": "The initiate method loads proteomics data, parses TSV files, and builds\ninternal lookup tables. The run method assumes those data structures exist\nand accesses them directly. Skipping initiate means those attributes were\nnever created, so run crashes when it tries to use them. Option A invents\nlazy loading that was not implemented. Option C assumes graceful handling.\nOption D invents a type-level restriction. The two-phase pattern separates\nexpensive one-time setup from repeated per-query execution — but the caller\nmust honor the contract by calling initiate before run.\n"
    },
    {
      "slug": "mutable-default-argument-trap",
      "difficulty": "medium",
      "topic": "Understanding why mutable default arguments can cause unexpected state sharing between calls",
      "question": "A function collects restriction sites to avoid during gene design:\n\n<python>\ndef add_forbidden_site(site, sites=[]):\n    sites.append(site)\n    return sites\n\nresult1 = add_forbidden_site('GAATTC')\nresult2 = add_forbidden_site('GGTCTC')\n</python>\n\nWhat is the value of result2?\n",
      "choices": {
        "A": "['GGTCTC'] — each call starts with a fresh empty list",
        "B": "['GAATTC', 'GGTCTC'] — the default list is shared across calls",
        "C": "TypeError — you cannot use a list as a default argument",
        "D": "['GGTCTC', 'GAATTC'] — the list prepends new entries"
      },
      "answer": "B",
      "explanation": "In Python, default mutable arguments are created once when the function is\ndefined, not on each call. Both calls share the same list object, so the\nfirst call adds 'GAATTC' and the second adds 'GGTCTC' to that same list.\nThis is a well-known Python pitfall. Option A describes the expected\nbehavior if a new list were created each call — the fix is to use\nsites=None and create the list inside the function body. Option C is wrong\nbecause lists are valid defaults (just dangerous). Option D invents\nprepend behavior. In design code, this bug would cause forbidden sites\nfrom one gene design to silently carry over to the next.\n"
    },
    {
      "slug": "class-attribute-vs-instance-attribute",
      "difficulty": "medium",
      "topic": "Distinguishing data shared across all instances from data specific to one instance",
      "question": "A TranscriptDesigner class stores both shared configuration and\nper-design results:\n\n<python>\nclass TranscriptDesigner:\n    checkers = [ForbiddenSequenceChecker, HairpinChecker]  # class attribute\n\n    def __init__(self, protein_seq):\n        self.protein_seq = protein_seq   # instance attribute\n        self.cds = None                  # instance attribute\n\ndesigner_a = TranscriptDesigner('MKALIV')\ndesigner_b = TranscriptDesigner('MPQRST')\n</python>\n\nWhich statement is true?\n",
      "choices": {
        "A": "designer_a.checkers and designer_b.checkers refer to the same list; their protein_seq values differ",
        "B": "Each designer has its own independent copy of checkers and protein_seq",
        "C": "checkers is only accessible via the class, not through instances",
        "D": "designer_a.protein_seq and designer_b.protein_seq refer to the same string"
      },
      "answer": "A",
      "explanation": "Class attributes are shared across all instances — designer_a.checkers and\ndesigner_b.checkers refer to the same list. Instance attributes assigned\nin __init__ are unique to each object, so the protein sequences differ.\nOption B is wrong because class attributes are shared, not copied.\nOption C is wrong because instances can access class attributes through\nnormal dot notation. Option D is wrong because protein_seq is assigned\nper-instance. The checkers are shared because all designers use the same\nvalidation pipeline, while each design works on a different protein.\n"
    },
    {
      "slug": "argument-order-and-keyword-args",
      "difficulty": "medium",
      "topic": "Using positional and keyword arguments to make function calls readable and correct",
      "question": "A PCR primer design function has this signature:\n\n<python>\ndef design_primers(template, target_tm=60.0, min_length=18, max_length=30):\n    ...\n</python>\n\nA student calls it four ways:\n\n<python>\na = design_primers('ATGCCC...', 55.0, 20, 25)\nb = design_primers('ATGCCC...', max_length=25, target_tm=55.0)\nc = design_primers('ATGCCC...', min_length=20, 55.0)\nd = design_primers(target_tm=55.0, template='ATGCCC...')\n</python>\n\nWhich calls raise a SyntaxError?\n",
      "choices": {
        "A": "Only c — positional arguments cannot follow keyword arguments",
        "B": "c and d — keyword arguments must match the exact order",
        "C": "Only d — template must be passed positionally",
        "D": "None — Python accepts arguments in any order"
      },
      "answer": "A",
      "explanation": "Python requires all positional arguments to come before keyword arguments\nin a function call. Call c passes min_length=20 as a keyword then 55.0 as\na positional argument, which violates this rule and raises SyntaxError.\nCall a uses all positional arguments in order — valid. Call b mixes\npositional and keyword but keywords come last — valid. Call d uses all\nkeyword arguments, which can appear in any order — valid. This matters\nin design code where functions have many parameters: keyword arguments\nmake calls self-documenting and order-independent.\n"
    },
    {
      "slug": "function-composition-pipeline",
      "difficulty": "medium",
      "topic": "Composing functions so the output of one becomes the input of the next in a processing pipeline",
      "question": "A gene design pipeline composes three functions:\n\n<python>\ndef reverse_translate(protein, codon_table):\n    '''Returns a DNA CDS encoding the protein.'''\n    ...\n\ndef optimize_codons(cds, organism):\n    '''Returns an optimized version of the CDS.'''\n    ...\n\ndef remove_forbidden_sites(cds, forbidden):\n    '''Returns a CDS with forbidden sites silently eliminated.'''\n    ...\n</python>\n\nA student writes:\n\n<python>\ncds = reverse_translate('MKALI', codon_table)\noptimized = optimize_codons(cds, 'ecoli')\nfinal = remove_forbidden_sites(optimized, ['GAATTC', 'GGTCTC'])\n</python>\n\nAnother student writes:\n\n<python>\nfinal = remove_forbidden_sites(\n    optimize_codons(\n        reverse_translate('MKALI', codon_table),\n        'ecoli'),\n    ['GAATTC', 'GGTCTC'])\n</python>\n\nWhat is the relationship between these two approaches?\n",
      "choices": {
        "A": "They produce the same result — the second nests the calls but the execution order and data flow are identical",
        "B": "The nested version runs faster because it avoids creating intermediate variables",
        "C": "The nested version skips the optimize_codons step",
        "D": "They produce different results because nested calls change the evaluation order"
      },
      "answer": "A",
      "explanation": "Both approaches call the same three functions in the same order with the\nsame arguments. The first stores intermediate results in named variables;\nthe second nests the calls so each return value is passed directly as an\nargument to the next outer function. Python evaluates innermost calls\nfirst, so reverse_translate runs first, then optimize_codons, then\nremove_forbidden_sites — the identical pipeline. Option B invents a\nperformance difference. Option C misreads the nesting. Option D\nmisunderstands evaluation order. Named intermediates are often clearer\nfor debugging, but the result is the same."
    }
  ],
  "indexing_slicing_and_string_processing": [
    {
      "slug": "zero-based-index-extraction",
      "difficulty": "medium",
      "topic": "Applying zero-based indexing to extract a specific element from sequential data",
      "question": "A promoter sequence is stored as a string. A student wants to check\nthe base at the transcription start site, which is the 5th nucleotide\nin the stored sequence:\n\n<pre>promoter = 'TTGACATATAAT'</pre>\n\nThe student writes:\n\n<python>\ntss = promoter[5]\n</python>\n\nWhat value does tss hold, and did the student get what they wanted?\n",
      "choices": {
        "A": "'A' — this is the 6th nucleotide, not the 5th; the student has an off-by-one error",
        "B": "'C' — this is the 5th nucleotide, exactly what the student wanted",
        "C": "'T' — index 5 wraps around to the beginning of the string",
        "D": "IndexError — index 5 is out of range for this string"
      },
      "answer": "A",
      "explanation": "In Python, indexing is zero-based: promoter[0]='T', [1]='T', [2]='G',\n[3]='A', [4]='C', [5]='A'. So promoter[5] returns 'A', which is\nthe 6th nucleotide in the sequence. The student wanted the 5th\nnucleotide (1-based position 5), which is promoter[4] = 'C'. The\nstudent's off-by-one error comes from forgetting that Python counts\nfrom 0. In biological databases, sequences are 1-indexed, but Python\nstrings are 0-indexed — this mismatch is a persistent source of bugs.\nOption B has the wrong value — 'C' is at index 4, not 5. Option C\nis wrong — Python does not wrap indices around. Option D is wrong\nbecause the string has 12 characters, so index 5 is valid.\n"
    },
    {
      "slug": "slice-endpoint-exclusion",
      "difficulty": "medium",
      "topic": "Understanding that slice endpoints are exclusive and reasoning about boundary positions",
      "question": "A gene annotation says the start codon begins at position 10 (0-based)\nin a genomic sequence. You want to extract the 3-nucleotide start codon:\n\n<pre>genome = 'CCCGTTAAACATGAAAGGGCCC'</pre>\n\nWhich slice correctly extracts <pre>ATG</pre> starting at index 10?\n",
      "choices": {
        "A": "genome[10:13]",
        "B": "genome[10:12]",
        "C": "genome[11:14]",
        "D": "genome[10:10+2]"
      },
      "answer": "A",
      "explanation": "Python slicing uses a half-open interval: seq[start:end] includes index\nstart up to but not including index end. To get 3 characters starting at\nindex 10, you need genome[10:13] — indices 10, 11, 12. Option B gives\ngenome[10:12] which is only 2 characters ('AT'). Option C starts at 11\ninstead of 10, grabbing 'TGA' — a frameshift. Option D computes\ngenome[10:12], the same 2-character error as B. The formula for\nextracting n characters starting at position i is always seq[i:i+n].\nThe half-open convention avoids fencepost errors once internalized: the\nlength of a slice equals end minus start.\n"
    },
    {
      "slug": "negative-index-from-end",
      "difficulty": "medium",
      "topic": "Using negative indices to access elements relative to the end of a sequence",
      "question": "A CDS must end with a stop codon. To extract the last three\nnucleotides for verification:\n\n<pre>cds = 'ATGAAAGGTCTCTAA'</pre>\n\nA student writes:\n\n<python>\nlast_codon = cds[-3:]\n</python>\n\nWhat is the value of last_codon?\n",
      "choices": {
        "A": "TAA",
        "B": "ATG",
        "C": "CTT",
        "D": "IndexError — negative indices are not allowed on strings"
      },
      "answer": "A",
      "explanation": "Negative indices count from the end: cds[-1] is the last character 'A',\ncds[-2] is 'A', cds[-3] is 'T'. The slice cds[-3:] means \"from the\nthird-to-last character to the end,\" yielding 'TAA'. This is the\nstandard idiom for checking the terminal codon of a CDS without needing\nto know the sequence length. Option B would require cds[:3] (the first\nthree). Option C is not a substring of this sequence. Option D is wrong\nbecause Python fully supports negative indexing on strings, lists, and\ntuples. Negative indexing is equivalent to cds[len(cds)-3:], but more\nconcise and less error-prone.\n"
    },
    {
      "slug": "off-by-one-protospacer-extraction",
      "difficulty": "medium",
      "topic": "Getting boundary arithmetic right when extracting a region defined relative to a landmark position",
      "question": "A CRISPR guide design function locates a PAM site (<pre>NGG</pre>) and must\nextract the 20-nt protospacer immediately upstream. The PAM starts at\nindex 25 in the target sequence:\n\n<python>\ntarget = '...' # a long genomic string\npam_index = 25\n</python>\n\nWhich slice correctly extracts the 20-nt protospacer?\n",
      "choices": {
        "A": "target[pam_index-20:pam_index]",
        "B": "target[pam_index-21:pam_index-1]",
        "C": "target[pam_index-20:pam_index-1]",
        "D": "target[pam_index-19:pam_index]"
      },
      "answer": "A",
      "explanation": "The protospacer is the 20 nucleotides immediately before the PAM. If the\nPAM starts at index 25, the protospacer occupies indices 5 through 24\ninclusive. Using the half-open interval: target[25-20:25] = target[5:25],\nwhich captures exactly 20 characters (indices 5..24). Option B gives\ntarget[4:24], which starts one position too early and ends one too early.\nOption C gives target[5:24], which is only 19 characters — the classic\noff-by-one error of subtracting 1 from the end when the endpoint is\nalready exclusive. Option D gives target[6:25], only 19 characters\nstarting one position too late. The key insight: because slicing already\nexcludes the endpoint, using the PAM index directly as the end requires\nno adjustment.\n"
    },
    {
      "slug": "slice-with-step-reverse",
      "difficulty": "medium",
      "topic": "Using a step argument in slicing to reverse or subsample sequential data",
      "question": "A function needs to reverse a DNA sequence as part of computing the\nreverse complement. Given:\n\n<pre>seq = 'AACGTCG'</pre>\n\nWhat is the value of seq[::-1]?\n",
      "choices": {
        "A": "GCTGCAA",
        "B": "AACGTCG",
        "C": "GCAACGT",
        "D": "TypeError — strings do not support step slicing"
      },
      "answer": "A",
      "explanation": "The slice [::-1] means start from the end, go to the beginning, stepping\nby -1 — it reverses the string. <pre>AACGTCG</pre> reversed is <pre>GCTGCAA</pre>. This\nis the standard Python idiom for string reversal and is used in the\nreverse complement operation: first complement each base, then reverse\n(or vice versa). Option B is the original unreversed sequence. Option C\nis an incorrect reversal. Option D is wrong because all Python sequences\nsupport the step parameter in slices. Note that [::-1] creates a new\nstring — it does not modify seq in place, because strings are immutable.\n"
    },
    {
      "slug": "find-returns-negative-one",
      "difficulty": "medium",
      "topic": "Distinguishing methods that return sentinel values from those that raise exceptions on failure",
      "question": "A restriction site scanner needs to locate <pre>GAATTC</pre> (EcoRI) in a\ndesigned gene. Two approaches:\n\n<python>\ncds = 'ATGAAACCCGGGTAA'\n\npos_a = cds.find('GAATTC')\npos_b = cds.index('GAATTC')\n</python>\n\nThe site is not present in this CDS. What happens?\n",
      "choices": {
        "A": "Both return -1",
        "B": "find returns -1; index raises ValueError",
        "C": "find returns None; index returns -1",
        "D": "Both raise ValueError"
      },
      "answer": "B",
      "explanation": "When the substring is not found, str.find() returns -1 as a sentinel\nvalue, while str.index() raises a ValueError. This is a critical\ndistinction in sequence scanning code: if you use find() and forget\nto check for -1, subsequent slicing with a negative index will silently\nextract the wrong region. For example, cds[pos_a:pos_a+6] when pos_a\nis -1 gives cds[-1:5], which is an empty string — a silent bug. The\nindex() method forces you to handle the missing-site case explicitly\nvia a try/except. Option A is wrong because index does not return -1.\nOption C is wrong because find returns -1, not None. Option D is wrong\nbecause find never raises an exception for missing substrings.\n"
    },
    {
      "slug": "string-immutability-mutation",
      "difficulty": "medium",
      "topic": "Recognizing that immutable sequences cannot be modified in place and must be rebuilt",
      "question": "A codon optimization function wants to replace the codon at positions\n6-8 in a CDS with a synonymous alternative:\n\n<python>\ncds = 'ATGAAACCCGGGTAA'\ncds[6:9] = 'CCT'\n</python>\n\nWhat happens?\n",
      "choices": {
        "A": "The CDS is updated to 'ATGAAACCTGGGTAA'",
        "B": "TypeError — strings do not support item assignment",
        "C": "The slice is replaced and the string shrinks if the new codon is shorter",
        "D": "A new string is returned but cds is unchanged"
      },
      "answer": "B",
      "explanation": "Strings in Python are immutable — you cannot assign to a slice or an\nindex. The attempt raises TypeError: 'str' object does not support item\nassignment. To perform the replacement, you must build a new string:\ncds = cds[:6] + 'CCT' + cds[9:]. Option A describes what would happen\nif strings were mutable. Option C describes list-like behavior that\nstrings do not have. Option D confuses the situation with methods like\n.replace() that return new strings, but slice assignment is simply not\nallowed. In genetic design code, this means every sequence modification\ncreates a new string object.\n"
    },
    {
      "slug": "codon-boundary-alignment",
      "difficulty": "medium",
      "topic": "Ensuring that positional arithmetic respects the internal structure of sequential data",
      "question": "A function extracts the codon that contains a specific nucleotide\nposition in a CDS. The CDS is in frame (starts with ATG at index 0).\nGiven nucleotide position 7:\n\n<pre>cds = 'ATGAAACCCTAA'</pre>\n\nWhat is the codon containing position 7 and what are its boundaries?\n",
      "choices": {
        "A": "'CCC' at indices 6:9 — position 7 falls in the third codon (i=6)",
        "B": "'AAC' at indices 3:6 — position 7 is in the second codon",
        "C": "'ACC' at indices 7:10 — start the codon at the given position",
        "D": "'CCC' at indices 7:9 — extract from position 7 to end of codon"
      },
      "answer": "A",
      "explanation": "Codons in a CDS starting at index 0 begin at indices 0, 3, 6, 9, ...\nTo find which codon contains position p, compute the codon start as\n(p // 3) * 3. For p=7: (7 // 3) * 3 = 2 * 3 = 6. The codon spans\ncds[6:9] = 'CCC'. Option B uses the wrong codon boundary (the second\ncodon is cds[3:6] = 'AAA', which does not contain position 7). Option C\nstarts a 3-nt window at the arbitrary nucleotide position, ignoring\nreading frame alignment. Option D extracts only a partial codon. The\ngeneral formula (p // 3) * 3 snaps any position down to its codon\nboundary — a pattern used when making synonymous substitutions that\nmust preserve the reading frame.\n"
    },
    {
      "slug": "overlapping-substring-count",
      "difficulty": "medium",
      "topic": "Understanding how built-in search methods handle overlapping matches in sequential data",
      "question": "A function checks how many times the dinucleotide <pre>AA</pre> appears in a\npoly-A tract:\n\n<python>\nseq = 'AAAAAC'\ncount_a = seq.count('AA')\n</python>\n\nWhat is the value of count_a?\n",
      "choices": {
        "A": "4 — every overlapping occurrence is counted",
        "B": "2 — count returns non-overlapping matches from left to right",
        "C": "3 — count slides a window one base at a time",
        "D": "5 — every position where 'A' appears is counted"
      },
      "answer": "B",
      "explanation": "The str.count() method finds non-overlapping occurrences, scanning left\nto right. In <pre>AAAAAC</pre>, the first 'AA' matches at index 0, consuming\nindices 0-1. The next match starts at index 2, consuming 2-3. Index 4\nis 'A' followed by 'C', which is not 'AA'. So count returns 2. If you\nneed overlapping matches (indices 0, 1, 2, 3), you must write an\nexplicit loop or use a regex with lookahead. Option A would be the\noverlapping count. Option C gives 3, which is neither the overlapping\nnor the non-overlapping count. Option D confuses counting a single\ncharacter with counting a dinucleotide. This distinction matters when\nscanning for repeated motifs in promoters or ribosome binding sites.\n"
    },
    {
      "slug": "case-normalization-before-search",
      "difficulty": "medium",
      "topic": "Ensuring consistent data representation before performing comparisons or lookups",
      "question": "GenBank files sometimes represent features in lowercase to indicate\nthey were computationally predicted. A function must check whether a\nsequence contains a BamHI site (<pre>GGATCC</pre>), regardless of case:\n\n<pre>seq = 'atgGGATCCaaa'</pre>\n\nA student writes three attempts:\n\n<python>\nattempt1 = 'GGATCC' in seq\nattempt2 = 'GGATCC' in seq.upper()\nattempt3 = 'ggatcc' in seq\n</python>\n\nWhich attempt correctly detects the site regardless of input casing?\n",
      "choices": {
        "A": "Only attempt2",
        "B": "attempt1 and attempt2",
        "C": "attempt2 and attempt3",
        "D": "All three"
      },
      "answer": "A",
      "explanation": "String comparison in Python is case-sensitive. In this particular input,\nattempt1 happens to work because <pre>GGATCC</pre> appears literally in uppercase.\nBut if the input were <pre>atgggatccaaa</pre> (all lowercase), attempt1 would\nfail. Only attempt2 normalizes case before searching, making it robust to\nany combination. attempt3 searches for lowercase 'ggatcc' which fails if\nthe site is uppercase. The biological lesson: always normalize case before\nsearching sequences from external sources where capitalization conventions\nvary."
    }
  ],
  "tracebacks_and_exceptions": [
    {
      "slug": "reading-traceback-to-find-failing-line",
      "difficulty": "medium",
      "topic": "Reading a stack trace to identify which line caused an error and what triggered it",
      "question": "A student runs a gene design pipeline and gets this traceback:\n\n<pre>\nTraceback (most recent call last):\n  File \"pipeline.py\", line 12, in <module>\n    result = design_rbs(cds, proteomics)\n  File \"rbs.py\", line 45, in design_rbs\n    abundance = proteomics[gene_id]\nKeyError: 'b0025'\n</pre>\n\nWhich line actually raised the error, and what caused it?\n",
      "choices": {
        "A": "Line 12 of pipeline.py — the function design_rbs does not exist",
        "B": "Line 45 of rbs.py — the key 'b0025' was not found in the proteomics dict",
        "C": "Line 12 of pipeline.py — cds is None",
        "D": "Line 45 of rbs.py — gene_id is an integer but should be a string"
      },
      "answer": "B",
      "explanation": "A traceback reads bottom-up: the last entry is the line that raised the\nexception. Line 45 of rbs.py attempted proteomics[gene_id] where gene_id\nwas 'b0025', but that key does not exist in the dict. Line 12 is the\ncaller — it shows how execution reached the failing function but is not\nwhere the error occurred. Option A misreads the traceback as a missing\nfunction. Option C invents a None issue not indicated by the error type.\nOption D invents a type mismatch — KeyError means the key is absent, not\nthe wrong type.\n"
    },
    {
      "slug": "exception-type-from-none-attribute-access",
      "difficulty": "medium",
      "topic": "Predicting the exception type when an operation is applied to the wrong kind of value",
      "question": "A CRISPR target finder returns None when no valid guide is found:\n\n<python>\ndef find_best_guide(seq, pam='NGG'):\n    candidates = find_all_targets(seq, pam)\n    if len(candidates) == 0:\n        return None\n    return select_best(candidates)\n</python>\n\nA caller writes:\n\n<python>\nguide = find_best_guide(short_seq)\nprint(guide.spacer)\n</python>\n\nIf no guide was found, what exception is raised on the second line?\n",
      "choices": {
        "A": "ValueError — the spacer is invalid",
        "B": "NameError — guide was never defined",
        "C": "AttributeError — None has no attribute 'spacer'",
        "D": "TypeError — print cannot accept None"
      },
      "answer": "C",
      "explanation": "When find_best_guide returns None, guide is bound to None. Accessing\n.spacer on None raises AttributeError because None has no attributes.\nThis is one of the most common errors in pipelines that return None for\n\"not found\" — the caller must check before accessing fields. Option A\nis wrong because no ValueError is involved. Option B is wrong because\nguide is defined — it just holds None. Option D is wrong because the\nerror occurs at guide.spacer, before print ever receives its argument.\n"
    },
    {
      "slug": "guard-clause-vs-silent-failure",
      "difficulty": "medium",
      "topic": "Recognizing why validating inputs early with guard clauses prevents harder-to-diagnose errors later",
      "question": "Two versions of reverse_complement handle non-ATCG characters differently:\n\n<python>\n# Version A: silently skips invalid bases\ndef reverse_complement_a(seq):\n    comp = {'A': 'T', 'T': 'A', 'C': 'G', 'G': 'C'}\n    result = ''\n    for base in seq:\n        if base in comp:\n            result = comp[base] + result\n    return result\n\n# Version B: guard clause that rejects invalid input\ndef reverse_complement_b(seq):\n    if not all(b in 'ATCG' for b in seq):\n        raise ValueError(f'Invalid base in sequence: {seq}')\n    comp = {'A': 'T', 'T': 'A', 'C': 'G', 'G': 'C'}\n    result = ''\n    for base in seq:\n        result = comp[base] + result\n    return result\n</python>\n\nA researcher accidentally passes <pre>ATGNCC</pre> (with an ambiguous N).\nWhat happens with each version?\n",
      "choices": {
        "A": "Both raise ValueError — any non-ATCG character triggers an error",
        "B": "A returns 'GGNAT' (skipping N); B raises ValueError explaining the problem",
        "C": "A returns 'GGNCAT'; B returns 'GGNCAT' — both handle N the same way",
        "D": "A returns 'GGCAT' (silently dropping N); B raises ValueError explaining the problem"
      },
      "answer": "D",
      "explanation": "Version A skips any base not in the complement dict. 'N' is not a key,\nso it is silently dropped, producing the reverse complement of 'ATGCC'\nwhich is 'GGCAT'. The result is the wrong length and missing a position\n— a silent data corruption. Version B checks all bases up front and\nraises ValueError with a message identifying the bad input. This is the\nguard clause pattern from lecture: fail fast with a clear message rather\nthan silently producing wrong results. Option B incorrectly includes N\nin Version A's output. Option C invents complement behavior for N.\n"
    },
    {
      "slug": "raise-vs-return-none-for-invalid-input",
      "difficulty": "medium",
      "topic": "Choosing between raising an exception and returning None when a function receives illegal input",
      "question": "A function computes the molecular weight of a DNA sequence. A student\nconsiders two designs for handling a sequence that contains non-DNA\ncharacters:\n\n<python>\n# Design 1\ndef molecular_weight(seq):\n    if not all(b in 'ATCG' for b in seq):\n        return None\n    ...\n\n# Design 2\ndef molecular_weight(seq):\n    if not all(b in 'ATCG' for b in seq):\n        raise ValueError(f'Non-DNA character in: {seq}')\n    ...\n</python>\n\nA caller writes:\n\n<python>\ntotal = molecular_weight(seq1) + molecular_weight(seq2)\n</python>\n\nIf seq2 contains an invalid character, what happens under each design?\n",
      "choices": {
        "A": "Design 1 returns None for the sum; Design 2 raises ValueError",
        "B": "Design 1 raises TypeError (cannot add int and None); Design 2 raises ValueError with a clear message",
        "C": "Both designs raise ValueError — returning None is automatically converted",
        "D": "Both produce None — the + operator propagates None like SQL null"
      },
      "answer": "B",
      "explanation": "Design 1 returns None for seq2. The expression becomes a valid number +\nNone, which raises TypeError because Python cannot add a number and None.\nThe TypeError message gives no indication that the real problem was an\ninvalid DNA sequence. Design 2 raises ValueError immediately with an\nexplicit message identifying the bad input. This is why returning None\nfor invalid input is discouraged in domain logic — it delays the error\nand obscures the cause. Option A is wrong because Python does not\nsilently propagate None through arithmetic. Option D invents SQL-like\nnull semantics that Python does not have.\n"
    },
    {
      "slug": "propagating-vs-catching-exceptions",
      "difficulty": "medium",
      "topic": "Understanding when to let exceptions propagate versus catching them inside a function",
      "question": "A codon optimization pipeline has three layers:\n\n<python>\ndef optimize_codon_at(cds, pos, codon_table):\n    '''Replace one codon. Raises ValueError if pos is out of range.'''\n    if pos < 0 or pos >= len(cds) // 3:\n        raise ValueError(f'Codon position {pos} out of range')\n    ...\n\ndef optimize_all_codons(cds, codon_table):\n    '''Optimize every codon in the CDS.'''\n    for i in range(len(cds) // 3):\n        cds = optimize_codon_at(cds, i, codon_table)\n    return cds\n</python>\n\n<python>\n# Top-level script\ntry:\n    result = optimize_all_codons(my_cds, table)\nexcept ValueError as e:\n    print(f'Design failed: {e}')\n</python>\n\nWhere is the exception caught, and why is this structure correct?\n",
      "choices": {
        "A": "optimize_all_codons should catch the ValueError so the loop can continue with other codons",
        "B": "optimize_codon_at should catch its own ValueError so it never propagates",
        "C": "The exception propagates from optimize_codon_at through optimize_all_codons to the top-level try/except, which is the appropriate place to handle it",
        "D": "Each layer should have its own try/except block wrapping every call"
      },
      "answer": "C",
      "explanation": "The innermost function raises the exception. The middle function does not\ncatch it — if a codon position is out of range, something is fundamentally\nwrong and continuing would produce garbage. The exception propagates up\nto the top-level script, which is the only layer that knows what to do\nabout failure (report it to the user). This follows the lecture principle:\ndomain logic functions should not catch exceptions they cannot meaningfully\nhandle. Option A would mask a logic error by continuing with corrupted\ndata. Option B would prevent the caller from ever learning about the\nproblem. Option D creates redundant error handling that obscures the\ncode's logic.\n"
    },
    {
      "slug": "distinguishing-caller-error-from-function-bug",
      "difficulty": "medium",
      "topic": "Distinguishing between a bug inside a function and invalid input from its caller",
      "question": "A function translates a DNA sequence and a colleague reports it crashes:\n\n<pre>\nTraceback (most recent call last):\n  File \"design.py\", line 8, in <module>\n    protein = translate(user_seq)\n  File \"bio.py\", line 22, in translate\n    aa = genetic_code[codon]\nKeyError: 'ATN'\n</pre>\n\nThe genetic_code dict contains all 64 standard codons. Is this a bug\nin translate or a caller error?\n",
      "choices": {
        "A": "Bug in translate — it should handle every possible three-letter string",
        "B": "Caller error — 'ATN' is not a valid codon, so the input sequence contains non-ATCG characters that should have been validated before calling translate",
        "C": "Bug in genetic_code — it is missing entries for ambiguous bases",
        "D": "Caller error — the caller should have wrapped the call in try/except"
      },
      "answer": "B",
      "explanation": "The genetic_code dict contains all 64 standard DNA codons (combinations\nof A, T, C, G). 'ATN' contains an ambiguous base N, meaning user_seq\nwas not a valid DNA sequence. The responsibility to provide valid input\nlies with the caller — either by validating before calling translate, or\nby using a function upstream that enforces the DNA alphabet. Option A\nwould require translate to handle an unbounded set of nonsense inputs.\nOption C misframes the contract — the genetic code maps real codons, not\nambiguity codes. Option D treats the symptom (catching the crash) instead\nof the cause (bad input).\n"
    },
    {
      "slug": "choosing-the-right-exception-type",
      "difficulty": "medium",
      "topic": "Selecting the appropriate exception type to communicate why a function rejected its input",
      "question": "A function checks whether a primer sequence is valid for ordering:\n\n<python>\ndef validate_primer(seq):\n    if not isinstance(seq, str):\n        raise ???('seq must be a string, got ' + type(seq).__name__)\n    if len(seq) < 15:\n        raise ???('Primer too short: ' + str(len(seq)) + ' bases (minimum 15)')\n    if not all(b in 'ATCG' for b in seq.upper()):\n        raise ???('Primer contains non-DNA characters: ' + seq)\n</python>\n\nWhat exception types best fill the three ??? slots?\n",
      "choices": {
        "A": "TypeError, ValueError, ValueError",
        "B": "ValueError, ValueError, ValueError",
        "C": "TypeError, IndexError, KeyError",
        "D": "Exception, Exception, Exception"
      },
      "answer": "A",
      "explanation": "The first check rejects a wrong type (not a string) — TypeError signals\nthat the operation received an argument of the wrong type. The second and\nthird checks reject values that are the right type (strings) but violate\ndomain constraints — ValueError signals that the value is inappropriate.\nOption B uses ValueError for the type check, losing the distinction\nbetween \"wrong type\" and \"wrong value.\" Option C uses IndexError and\nKeyError, which signal specific container access failures, not input\nvalidation. Option D uses the generic Exception, which gives callers no\nway to distinguish different failure modes.\n"
    },
    {
      "slug": "traceback-through-multiple-calls",
      "difficulty": "medium",
      "topic": "Reading a multi-level traceback to understand the chain of calls that led to a failure",
      "question": "A gene design pipeline crashes with this traceback:\n\n<pre>\nTraceback (most recent call last):\n  File \"main.py\", line 5, in <module>\n    construct = build_construct(gene, plasmid)\n  File \"assembly.py\", line 18, in build_construct\n    rbs_result = design_rbs(gene['cds'])\n  File \"rbs.py\", line 7, in design_rbs\n    utr = chooser.run(cds)\n  File \"chooser.py\", line 34, in run\n    score = self.proteomics[gene_id]\nKeyError: 'yaaX'\n</pre>\n\nA student says \"the bug is in chooser.py line 34.\" Another says \"the\nreal problem is that proteomics data was never loaded.\" Who is right?\n",
      "choices": {
        "A": "The first student — the fix should be adding 'yaaX' to the proteomics dict at line 34",
        "B": "The second student — the traceback shows where the error surfaced, but the root cause is missing data setup upstream",
        "C": "Both are wrong — the error is in main.py where build_construct is called",
        "D": "Both are wrong — KeyError means the code has a syntax error"
      },
      "answer": "B",
      "explanation": "The traceback shows the chain of calls from main.py down to chooser.py.\nThe KeyError surfaces at line 34 because 'yaaX' is not in self.proteomics.\nBut the root cause is not line 34 itself — it is that the proteomics data\nwas never loaded or is incomplete. The fix belongs at the setup stage (the\ninitiate step), not at the line that happens to access the missing key.\nThis distinction between \"where the error surfaces\" and \"where the root\ncause lives\" is fundamental to debugging. Option A treats the symptom.\nOption C blames the top-level caller for a data-loading problem. Option D\nconfuses a runtime error with a syntax error.\n"
    },
    {
      "slug": "what-happens-without-input-validation",
      "difficulty": "medium",
      "topic": "Predicting the downstream consequences of skipping input validation in a function",
      "question": "A function computes GC content but does not validate its input:\n\n<python>\ndef gc_content(seq):\n    gc = sum(1 for b in seq if b in 'GC')\n    return gc / len(seq)\n</python>\n\nA caller accidentally passes an integer gene ID instead of a sequence:\n\n<python>\ngc = gc_content(1234)\n</python>\n\nWhat happens?\n",
      "choices": {
        "A": "Returns 0.0 — no characters in an integer match 'G' or 'C'",
        "B": "TypeError — iterating over an integer with 'for b in seq' is not supported",
        "C": "Returns 0.25 — the digits are treated as characters",
        "D": "ValueError — the function detects that 1234 is not a DNA sequence"
      },
      "answer": "B",
      "explanation": "Python integers are not iterable. The for loop in the generator expression\ntries to iterate over 1234, which raises TypeError. The error message will\nsay something like \"'int' object is not iterable.\" This is confusing\nbecause the real problem is that the caller passed the wrong type, but the\nerror surfaces inside the function as an iteration failure. A guard clause\nchecking isinstance(seq, str) at the top would catch this immediately with\na clear message. Option A assumes integers are iterable but empty. Option C\nassumes digits become characters. Option D invents validation that was\nexplicitly not written.\n"
    },
    {
      "slug": "error-message-quality",
      "difficulty": "medium",
      "topic": "Evaluating whether an error message gives the caller enough information to diagnose the problem",
      "question": "Two versions of a restriction site checker raise exceptions differently:\n\n<python>\n# Version A\ndef check_forbidden_sites(seq, forbidden):\n    for site in forbidden:\n        if site in seq:\n            raise ValueError('bad')\n\n# Version B\ndef check_forbidden_sites(seq, forbidden):\n    for site in forbidden:\n        if site in seq:\n            pos = seq.index(site)\n            raise ValueError(\n                f'Forbidden site {site} found at position {pos} in sequence'\n            )\n</python>\n\nA designer gets a ValueError while building a construct with 5 forbidden\nsites to check. Why is Version B's error message better?\n",
      "choices": {
        "A": "Version B is not better — both stop execution equally well",
        "B": "Version B names the specific forbidden site and its position, so the designer knows exactly what to fix without re-running any code",
        "C": "Version B is better only because it includes the word \"Forbidden\"",
        "D": "Version B is slower because it calls seq.index, so Version A is preferred"
      },
      "answer": "B",
      "explanation": "Version A's message 'bad' tells the caller nothing about which of the 5\nforbidden sites was found or where it occurs in the sequence. The designer\nwould need to manually check each site to figure out what went wrong.\nVersion B identifies the site (e.g., <pre>GAATTC</pre>) and its position (e.g.,\nposition 142), giving the designer the exact information needed to fix the\nsequence — perhaps by making a synonymous codon substitution at that\nlocation. Good error messages answer \"what went wrong\" and \"where\" so the\ncaller can act without additional investigation."
    }
  ],
  "automated_testing_and_validation": [
    {
      "slug": "validated-example-strength",
      "difficulty": "medium",
      "topic": "Understanding why experimentally confirmed data provides the strongest evidence for test correctness",
      "question": "A student writes three tests for a function that identifies protospacer\nsequences in a CRISPR array. Which test provides the strongest evidence\nthat the function works correctly?\n\n<python>\n# Test A: checks output is a string\ndef test_output_is_string():\n    result = find_protospacer(crispr_array)\n    assert isinstance(result, str)\n\n# Test B: checks output length is 20\ndef test_output_length():\n    result = find_protospacer(crispr_array)\n    assert len(result) == 20\n\n# Test C: uses experimentally confirmed protospacer from cadA\ndef test_cada_protospacer():\n    result = find_protospacer(cada_crispr_array)\n    assert result == 'ATAGTGAATGCTCAACGAAC'\n</python>\n",
      "choices": {
        "A": "Test A — type checking catches the broadest class of bugs",
        "B": "Test B — length constraints are more specific than type checks",
        "C": "Test C — matching a known experimental result validates actual correctness",
        "D": "All three are equally strong because they all use assert"
      },
      "answer": "C",
      "explanation": "Test C compares the function's output to an experimentally confirmed value.\nIf the function returns the exact protospacer that was verified in the lab,\nthat is direct evidence the algorithm produces biologically correct results.\nTests A and B are truisms — they check properties that any plausible output\nwould have, but a function could return the wrong 20-character DNA string\nand still pass both. The strength of evidence goes: validated example >\nspecific property > general type check. Option D incorrectly treats all\nassertions as equivalent regardless of what they check.\n"
    },
    {
      "slug": "truism-property-check",
      "difficulty": "medium",
      "topic": "Recognizing property-based checks that verify necessary but not sufficient conditions for correctness",
      "question": "A function designs DNA oligos for Gibson Assembly. A test checks:\n\n<python>\ndef test_oligo_properties():\n    oligos = design_gibson_oligos(parts)\n    for oligo in oligos:\n        assert set(oligo).issubset({'A', 'T', 'C', 'G'})\n        assert 15 <= len(oligo) <= 80\n</python>\n\nBoth assertions pass. Can you conclude the oligos are correct?\n",
      "choices": {
        "A": "Yes — if the oligos contain only ATCG and are the right length, they must be correct",
        "B": "No — these are necessary properties of any valid oligo, but a completely wrong sequence could also pass",
        "C": "Yes — checking two independent properties is sufficient for validation",
        "D": "No — the test is wrong because it should use assertEqual instead of assert"
      },
      "answer": "B",
      "explanation": "These checks are truisms — properties that any reasonable oligo must have,\nbut that do not verify the specific content. An oligo with the right length\nand alphabet but the wrong sequence would still pass. Truisms catch gross\nfailures (e.g., returning RNA or a 500bp sequence) but cannot confirm that\nthe oligos will actually amplify the intended product. Full validation\nrequires either a validated example or an inverse function check. Option A\nconfuses necessary conditions with sufficient conditions. Option C assumes\ntwo weak checks combine into a strong one. Option D misidentifies the\nproblem as syntactic rather than logical.\n"
    },
    {
      "slug": "fixture-expensive-setup",
      "difficulty": "medium",
      "topic": "Using fixtures to share expensive initialization across tests without repeating computation",
      "question": "An RBSChooser requires loading a proteomics database and computing\nthermodynamic models — a process that takes 30 seconds. A student writes:\n\n<python>\ndef test_rbs_high_expression():\n    chooser = RBSChooser()\n    chooser.initiate()               # 30 seconds\n    result = chooser.run('ATGAAAGCGTAA', target='high')\n    assert result is not None\n\ndef test_rbs_low_expression():\n    chooser = RBSChooser()\n    chooser.initiate()               # 30 seconds again\n    result = chooser.run('ATGAAAGCGTAA', target='low')\n    assert result is not None\n</python>\n\nRunning both tests takes 60 seconds. What is the standard pytest\nmechanism to initialize the chooser once and share it across both tests?\n",
      "choices": {
        "A": "Move the initialization into a global variable at module level",
        "B": "Use a pytest fixture that creates and initiates the chooser once per session",
        "C": "Combine both tests into a single test function with two assertions",
        "D": "Cache the result by writing it to a file between test runs"
      },
      "answer": "B",
      "explanation": "A pytest fixture decorated with an appropriate scope (e.g., session or\nmodule) runs the expensive setup once and injects the result into every\ntest that requests it. This keeps each test function independent and\nfocused on a single behavior while avoiding redundant 30-second\ninitializations. Option A works mechanically but bypasses pytest's\ndependency injection and makes test isolation harder. Option C sacrifices\ntest independence — if the first assertion fails, the second never runs.\nOption D introduces file I/O complexity and stale-cache risks that\nfixtures handle cleanly.\n"
    },
    {
      "slug": "edge-case-identification",
      "difficulty": "medium",
      "topic": "Identifying inputs at domain boundaries that expose assumptions in biological sequence algorithms",
      "question": "A function finds CRISPR guide RNA targets by searching for the pattern\nNGG (PAM site) in a DNA sequence and returning the 20bp upstream:\n\n<python>\ndef find_guides(seq):\n    guides = []\n    for i in range(20, len(seq)):\n        if seq[i+1:i+3] == 'GG':\n            guides.append(seq[i-20:i])\n    return guides\n</python>\n\nWhich of the following inputs is the BEST edge case to include in a test?\n",
      "choices": {
        "A": "A 1000bp sequence with multiple NGG sites",
        "B": "A sequence passed in as lowercase letters like 'atgccaattgg...'",
        "C": "A 1000bp sequence with exactly one NGG site",
        "D": "A sequence consisting of only 'A' repeated 100 times"
      },
      "answer": "B",
      "explanation": "Lowercase input is a classic edge case for biological sequence functions.\nThe comparison seq[i+1:i+3] == 'GG' checks for uppercase letters, so\nlowercase input would cause the function to silently find no guides even\nwhen PAM sites are present. This tests whether the function handles the\ncommon real-world situation where sequences come from databases or user\ninput in mixed or lowercase format. Option A is a normal case, not an\nedge case. Option C tests basic functionality. Option D tests the no-match\ncase, which is useful but less likely to expose hidden assumptions than\nthe case-sensitivity issue.\n"
    },
    {
      "slug": "inverse-function-testing",
      "difficulty": "medium",
      "topic": "Using inverse operations to validate that a design function produces correct outputs",
      "question": "DesignPCRPrimers takes a template and a target region and returns a pair\nof primers. PredictPCRProduct takes primers and a template and returns\nthe sequence that would be amplified. A test uses both:\n\n<python>\ndef test_pcr_roundtrip():\n    primers = DesignPCRPrimers(template, target_region)\n    product = PredictPCRProduct(primers, template)\n    assert product.sequence == target_region.sequence\n</python>\n\nWhy is this inverse function pattern a strong validation strategy?\n",
      "choices": {
        "A": "It eliminates the need for any other tests because it is mathematically complete",
        "B": "It verifies the design against an independent implementation of the domain logic, not just property checks",
        "C": "It is weaker than a truism because it depends on two functions both being correct",
        "D": "It only works for PCR and cannot be generalized to other design problems"
      },
      "answer": "B",
      "explanation": "The inverse function pattern uses a simulator (PredictPCRProduct) as an\nindependent check on the designer (DesignPCRPrimers). If the designed\nprimers, when fed into a simulator that models the actual chemistry,\nproduce the intended product, that is strong evidence the design is\ncorrect. This is stronger than truisms because it checks the specific\noutput against domain logic, not just general properties. Option A\noverstates the case — edge cases and validated examples are still needed.\nOption C raises a valid concern (both must be correct), but having two\nindependent implementations agree is much stronger than checking one in\nisolation. Option D is wrong because the pattern generalizes to any\ndomain with design-simulate pairs (e.g., codon optimization and\nback-translation).\n"
    },
    {
      "slug": "checker-pattern-centralized",
      "difficulty": "medium",
      "topic": "Centralizing domain knowledge in reusable checkers shared between algorithm and test code",
      "question": "A ForbiddenSequenceChecker is used inside the codon optimization\nalgorithm to avoid restriction sites, and the same checker is called\nin the test to verify the output:\n\n<python>\n# Inside the algorithm\ndef optimize_codons(protein, ...):\n    candidate = generate_candidate(protein)\n    checker = ForbiddenSequenceChecker(['GGTCTC', 'CGTCTC'])\n    if not checker.run(candidate):\n        candidate = retry(...)\n    return candidate\n\n# In the test\ndef test_no_forbidden_sites():\n    result = optimize_codons('MKALM...')\n    checker = ForbiddenSequenceChecker(['GGTCTC', 'CGTCTC'])\n    assert checker.run(result)\n</python>\n\nWhat is the key advantage of using the same checker in both places?\n",
      "choices": {
        "A": "It makes the test run faster because the checker is already compiled",
        "B": "It ensures the algorithm and the test encode identical domain knowledge, preventing definition drift",
        "C": "It means the test is trivially guaranteed to pass and therefore provides no value",
        "D": "It eliminates the need for validated examples because the checker is authoritative"
      },
      "answer": "B",
      "explanation": "When the algorithm and the test both use ForbiddenSequenceChecker, the\ndefinition of \"forbidden\" is centralized in one place. If the list of\nforbidden sites changes, both the algorithm and the test update together.\nWithout this pattern, the algorithm might check for GGTCTC while the test\nchecks for a different set, and neither would catch the inconsistency.\nOption A confuses code reuse with performance. Option C is wrong — the\nalgorithm might have a bug that causes it to skip the checker on some code\npaths, which the test would catch. Option D overstates the checker's role;\nvalidated examples still provide the strongest evidence of correctness.\n"
    },
    {
      "slug": "pytest-raises-invalid-input",
      "difficulty": "medium",
      "topic": "Verifying that functions reject invalid inputs by asserting specific exceptions are raised",
      "question": "A function that designs oligos should raise a ValueError when given a\nprotein sequence (containing amino acid letters not in ATCG) instead of\nDNA. A student writes this test:\n\n<python>\ndef test_rejects_protein_input():\n    result = design_oligos('MKALMPRGSL')\n    assert result is None\n</python>\n\nA colleague suggests a different approach:\n\n<python>\ndef test_rejects_protein_input():\n    with pytest.raises(ValueError):\n        design_oligos('MKALMPRGSL')\n</python>\n\nWhy is the colleague's version better?\n",
      "choices": {
        "A": "The first test is equivalent — returning None and raising ValueError are interchangeable signals",
        "B": "The colleague's version explicitly verifies the function fails loudly rather than silently returning a value that could propagate undetected",
        "C": "pytest.raises makes the test run faster than checking return values",
        "D": "The first test would fail because design_oligos would return an empty list, not None"
      },
      "answer": "B",
      "explanation": "A function that silently returns None on invalid input lets the error\npropagate — the caller might pass None into the next step, causing a\nconfusing error far from the source. Raising ValueError immediately\nidentifies the problem and its location. The pytest.raises context manager\nasserts that the specific exception is raised, making the test an\nexecutable specification of the error contract. Option A incorrectly\ntreats silent failure and explicit failure as equivalent. Option C\nconfuses testing patterns with performance. Option D guesses at specific\nbehavior rather than addressing the design principle.\n"
    },
    {
      "slug": "test-passes-vs-design-correct",
      "difficulty": "medium",
      "topic": "Distinguishing between a test suite passing and the underlying design being biologically correct",
      "question": "A student's test suite for their codon optimizer has 15 tests and all\npass. The tests check: output contains only ATCG, output length equals\n3 times the input protein length, output starts with ATG, and output\nends with a stop codon. A colleague examines the output for a well-studied\ngene and discovers the codon usage is heavily biased toward rare codons,\nwhich would give poor expression in E. coli.\n\nWhat does this situation reveal?\n",
      "choices": {
        "A": "The test suite has a bug — if 15 tests pass, the design must be correct",
        "B": "The tests verify structural properties (truisms) but none check whether the codon choices are actually optimized",
        "C": "Rare codons are acceptable because the sequence is still valid DNA",
        "D": "The colleague's observation is irrelevant because automated tests are the gold standard"
      },
      "answer": "B",
      "explanation": "All 15 tests are truisms — they check properties that any valid CDS would\nhave, regardless of whether the codons are well-chosen. A function that\nsimply uses the rarest codon for every amino acid would pass every one of\nthese tests while producing DNA that expresses poorly. The missing tests\nwould use either a validated example (a gene known to express well) or a\nchecker like CAIChecker that encodes the domain knowledge about codon\noptimality. A passing test suite only proves the design satisfies the\nproperties being tested, not that it is biologically correct. Option A\nconflates test passage with correctness. Option C ignores the purpose\nof codon optimization. Option D misunderstands the role of testing.\n"
    },
    {
      "slug": "algorithm-test-shared-knowledge",
      "difficulty": "medium",
      "topic": "Recognizing that meaningful tests require the same domain expertise as the algorithm being tested",
      "question": "Two students test a hairpin checker. Student A writes:\n\n<python>\ndef test_hairpin():\n    result = check_hairpin('ATCGATCG')\n    assert isinstance(result, bool)\n</python>\n\nStudent B writes:\n\n<python>\ndef test_known_hairpin():\n    # AAAACCCCGGGGTTTTT forms a strong hairpin:\n    # 5'-AAAACCCC    (stem)\n    #          GGGG-3' (loop + complementary stem)\n    assert check_hairpin('AAAACCCCGGGGTTTTT') == True\n\ndef test_no_hairpin():\n    # Alternating AT has no self-complementary regions\n    assert check_hairpin('ATATATATATATAT') == False\n</python>\n\nWhy does Student B's approach require more domain knowledge?\n",
      "choices": {
        "A": "Student B uses more assertions, which requires understanding pytest better",
        "B": "Student B had to understand nucleic acid secondary structure to select inputs whose correct outputs are known",
        "C": "Student B's tests are longer, which makes them harder to write but no more informative",
        "D": "Student A's test is actually better because it does not assume specific outputs"
      },
      "answer": "B",
      "explanation": "To write Student B's tests, you must understand which sequences form\nhairpins and which do not — the same thermodynamic knowledge the algorithm\nitself encodes. Selecting an input where you independently know the answer\nrequires domain expertise, and that is what makes the test meaningful. If\nyou do not understand the biology, you cannot construct test cases that\ndistinguish a correct algorithm from a broken one. Student A's test checks\nonly the output type, which requires no understanding of hairpins at all\nand would pass even if the function returned random booleans. Option A\nconfuses quantity of assertions with domain depth. Option C equates line\ncount with quality. Option D confuses generality with strength.\n"
    },
    {
      "slug": "benchmarking-all-inputs",
      "difficulty": "medium",
      "topic": "Using exhaustive input sets to expose failures that hand-picked test cases might miss",
      "question": "A codon optimization function is tested on three hand-picked genes and\npasses all assertions. A senior developer then runs the function on all\n4,391 protein-coding genes in the E. coli proteome:\n\n<python>\n@pytest.fixture(scope='session')\ndef proteome():\n    return load_ecoli_proteome()\n\ndef test_all_genes(proteome):\n    for gene in proteome:\n        result = optimize_codons(gene.protein)\n        assert len(result) == 3 * len(gene.protein)\n        checker = ForbiddenSequenceChecker(['GGTCTC'])\n        assert checker.run(result)\n</python>\n\nThe test fails on 12 genes. What is the most likely reason the hand-picked\ntests did not catch these failures?\n",
      "choices": {
        "A": "The hand-picked genes were too short to trigger bugs",
        "B": "The hand-picked genes may not have contained the specific amino acid combinations or rare subsequences that expose algorithmic edge cases",
        "C": "Three tests are always sufficient if they cover different gene lengths",
        "D": "The proteome test is overfitting to E. coli and does not generalize"
      },
      "answer": "B",
      "explanation": "Hand-picked test cases reflect the author's assumptions about what inputs\nare interesting. The 12 failing genes likely contain amino acid patterns,\nrepeated motifs, or unusual subsequences the developer did not anticipate.\nRunning on the entire proteome is a form of exhaustive benchmarking that\nexposes failures no reasonable set of hand-picked cases would cover. This\nis why the lecture emphasizes benchmarking on all possible inputs when the\ninput space is finite and enumerable. Option A focuses on a single\ndimension (length) when the real issue is input diversity. Option C\nassumes coverage can be measured by count alone. Option D confuses testing\nthoroughness with generalization — the function is designed for E. coli,\nso testing on its proteome is exactly right."
    }
  ],
  "schemas_identity_and_serialization": [
    {
      "slug": "required-vs-optional-fields",
      "difficulty": "medium",
      "topic": "Distinguishing required from optional fields and predicting behavior when optional fields are absent",
      "question": "A Polynucleotide dataclass is defined with some fields required and\nothers optional:\n\n<python>\n@dataclass\nclass Polynucleotide:\n    sequence: str\n    ext5: str = ''\n    ext3: str = ''\n    is_double_stranded: bool = True\n    is_circular: bool = False\n    mod_ext5: str = ''\n    mod_ext3: str = ''\n</python>\n\nA colleague creates an instance with only the sequence:\n\n<python>\ndna = Polynucleotide(sequence='ATGAAATAA')\n</python>\n\nWhat are the values of dna.ext5 and dna.is_circular?\n",
      "choices": {
        "A": "'' and False — optional fields take their default values",
        "B": "None and None — unspecified fields are always None",
        "C": "TypeError — all fields must be provided explicitly",
        "D": "'' and True — is_circular defaults to True for any sequence"
      },
      "answer": "A",
      "explanation": "In a dataclass, fields with default values are optional at construction\ntime. sequence has no default and is required; all other fields have\ndefaults. When only sequence is provided, ext5 gets '' and is_circular\ngets False. Option B confuses Python defaults with None (the defaults\nhere are '' and False, not None). Option C would be true only if no\ndefaults were declared. Option D invents a biological inference that\nthe dataclass does not encode — circularity must be stated explicitly.\n"
    },
    {
      "slug": "frozen-dataclass-immutability",
      "difficulty": "medium",
      "topic": "Understanding how frozen dataclasses enforce immutability and why that matters for data integrity",
      "question": "A strain genotype is modeled as a frozen dataclass:\n\n<python>\n@dataclass(frozen=True)\nclass Strain:\n    name: str\n    genotype: tuple\n\necoli = Strain(name='DH10B', genotype=('lacZ-', 'recA1'))\n</python>\n\nLater, a function tries to record a new mutation:\n\n<python>\necoli.genotype = ('lacZ-', 'recA1', 'endA1')\n</python>\n\nWhat happens?\n",
      "choices": {
        "A": "The genotype is updated to include endA1",
        "B": "FrozenInstanceError — frozen dataclasses do not allow attribute reassignment",
        "C": "The original object is unchanged but a new Strain is silently created",
        "D": "TypeError because tuples cannot be extended"
      },
      "answer": "B",
      "explanation": "The frozen=True parameter makes all attributes read-only after construction.\nAttempting to reassign any attribute raises FrozenInstanceError (a subclass\nof AttributeError). This is a deliberate design choice: a strain's genotype\nis a fixed biological fact at a point in time, and the immutability prevents\naccidental corruption. Option A would be true for a normal (non-frozen)\ndataclass. Option C invents copy-on-write behavior Python does not provide.\nOption D confuses tuple immutability with the dataclass attribute assignment\n— the error comes from frozen, not from tuple.\n"
    },
    {
      "slug": "sequence-invariant-validation",
      "difficulty": "medium",
      "topic": "Enforcing invariants on object fields to prevent construction of invalid biological objects",
      "question": "A Polynucleotide constructor includes a validator:\n\n<python>\n@dataclass\nclass Polynucleotide:\n    sequence: str\n\n    def __post_init__(self):\n        import re\n        if not re.fullmatch(r'[ATCG]+', self.sequence):\n            raise ValueError('Sequence must be non-empty and contain only A, T, C, G')\n</python>\n\nWhich of the following calls raises a ValueError?\n",
      "choices": {
        "A": "Polynucleotide(sequence='ATGCCC')",
        "B": "Polynucleotide(sequence='AUGCCC')",
        "C": "Polynucleotide(sequence='ATCG')",
        "D": "Polynucleotide(sequence='GGGGGGGG')"
      },
      "answer": "B",
      "explanation": "The regex [ATCG]+ requires every character to be A, T, C, or G, and the\nsequence must be at least one character. 'AUGCCC' contains 'U', which is\nan RNA base not in the allowed set, so it fails validation. This invariant\nensures a Polynucleotide always holds a valid DNA sequence — catching the\ncommon mistake of passing an RNA sequence to a DNA data structure. Options\nA, C, and D all consist entirely of valid DNA bases and pass the check.\n"
    },
    {
      "slug": "reference-by-identifier",
      "difficulty": "medium",
      "topic": "Using stable identifiers to reference objects indirectly instead of embedding them directly",
      "question": "A ConstructionFile describes a cloning plan. One approach stores the full\nPolynucleotide object inside each step. Another stores only the name as a\nstring and looks up the object in a registry:\n\n<python>\n# Approach 1: direct embedding\nstep = {'action': 'PCR', 'template': pUC19_object}\n\n# Approach 2: reference by identifier\nstep = {'action': 'PCR', 'template': 'pUC19'}\n# later: registry['pUC19'] returns the full object\n</python>\n\nA collaborator updates pUC19's sequence in the registry to fix a\nsequencing error. What happens to a saved ConstructionFile under each\napproach?\n",
      "choices": {
        "A": "Both approaches automatically see the updated sequence",
        "B": "Only approach 2 sees the update — approach 1 holds a stale copy of the old object",
        "C": "Only approach 1 sees the update — direct references track changes automatically",
        "D": "Neither approach sees the update — saved files are always frozen"
      },
      "answer": "B",
      "explanation": "Approach 2 stores only the name 'pUC19'. When the ConstructionFile is\nreloaded and the name is resolved, it fetches the current object from the\nregistry, which now has the corrected sequence. Approach 1 embedded the\nfull object at save time, so it retains the old sequence unless manually\nupdated. This is the key advantage of reference-by-identifier: it\nintroduces a level of indirection that allows the referenced object to\nevolve independently. Option A incorrectly assumes embedded objects are\nlive references. Option C reverses the logic. Option D ignores that\nregistry lookups happen at resolution time.\n"
    },
    {
      "slug": "sharable-identity-fields",
      "difficulty": "medium",
      "topic": "Identifying the minimal set of fields needed to uniquely identify and describe a shared resource",
      "question": "In the C9 system, all Sharables (models, data, functions, views) carry a\ncommon set of identity fields: id, type, name, description, and keywords.\n\nA student proposes dropping the id field and using name alone as the\nunique identifier, arguing that names are human-readable. Why is a\nseparate id field necessary?\n",
      "choices": {
        "A": "Names may be duplicated or changed over time; a stable id ensures references never break",
        "B": "The id field stores the object's sequence data, which names cannot hold",
        "C": "Python requires an id field for all objects to enable garbage collection",
        "D": "The name field is optional in Sharables, so it cannot serve as an identifier"
      },
      "answer": "A",
      "explanation": "Names are mutable and non-unique — two different labs might name their\nconstruct 'pET-GFP', or a name might be updated for clarity. A stable id\n(typically a UUID or hash) ensures that any reference to the object remains\nvalid regardless of name changes. This is the same principle as using accession\nnumbers in GenBank rather than gene names. Option B confuses the id with\nsequence storage. Option C confuses Python's built-in id() with a domain\nidentifier. Option D is wrong because name is a required Sharable field,\nbut even if it were required, uniqueness is the deeper issue.\n"
    },
    {
      "slug": "json-schema-type-enforcement",
      "difficulty": "medium",
      "topic": "Using schema definitions to validate data types and prevent silent errors in serialized data",
      "question": "A JSON schema for a Polynucleotide requires:\n\n<pre>\n{\n  \"sequence\": {\"type\": \"string\"},\n  \"is_circular\": {\"type\": \"boolean\"}\n}\n</pre>\n\nA researcher exports their construct as JSON, but their script writes\nis_circular as the string \"true\" instead of the boolean true:\n\n<pre>{\"sequence\": \"ATGAAATAA\", \"is_circular\": \"true\"}</pre>\n\nWhat should happen when this JSON is validated against the schema?\n",
      "choices": {
        "A": "Validation passes — \"true\" and true are equivalent in JSON",
        "B": "Validation fails — the schema requires a boolean, not a string",
        "C": "Validation passes — JSON schemas ignore type mismatches",
        "D": "Validation fails — \"true\" is not a valid JSON value"
      },
      "answer": "B",
      "explanation": "JSON distinguishes between the string \"true\" and the boolean true. A\nschema specifying {\"type\": \"boolean\"} rejects the string \"true\". This\nmatters because downstream code checking `if data['is_circular']:` would\nget True for both the boolean true and the non-empty string \"true\", but\nthe data would be semantically wrong — the string \"false\" is also truthy\nin Python. Schema validation catches this class of serialization bug\nbefore it causes silent errors. Option A conflates string and boolean\ntypes. Option C misunderstands the purpose of schemas. Option D is wrong\nbecause \"true\" is a valid JSON string, just the wrong type.\n"
    },
    {
      "slug": "cf-shorthand-name-resolution",
      "difficulty": "medium",
      "topic": "Parsing a shorthand notation that uses names to reference objects and resolving them in order",
      "question": "A ConstructionFile uses CF shorthand where each line defines a new DNA\nby name, and subsequent lines can reference previously defined DNAs:\n\n<pre>\nPCR p1 p2 pUC19   -> frag1\nPCR p3 p4 genomic  -> frag2\nGibson frag1 frag2 -> product\n</pre>\n\nThe Gibson step references frag1 and frag2 by name. What happens if the\nlines are reordered so that the Gibson step comes before the PCR steps?\n",
      "choices": {
        "A": "It still works — CF shorthand resolves names after parsing all lines",
        "B": "It fails — frag1 and frag2 have not been defined yet when Gibson is parsed",
        "C": "It works only if frag1 and frag2 are pre-registered in a global registry",
        "D": "It produces the same product but with reversed fragment order"
      },
      "answer": "B",
      "explanation": "CF shorthand is parsed top-to-bottom. Each line's output (the name after\n->) is only available to lines that come after it. If Gibson references\nfrag1 before the PCR line that creates frag1, the name cannot be resolved.\nThis is analogous to variable declaration order in code — you cannot use a\nvariable before it is defined. Option A would require a two-pass parser,\nwhich CF shorthand does not use. Option C introduces a mechanism not part\nof the standard CF format. Option D confuses ordering of lines with\nordering of fragments within an assembly.\n"
    },
    {
      "slug": "serialization-preserves-semantics",
      "difficulty": "medium",
      "topic": "Ensuring that serialization and deserialization preserve all semantically meaningful distinctions",
      "question": "Two Polynucleotide objects differ only in circularity:\n\n<python>\nlinear = Polynucleotide(sequence='ATGAAATAA', is_circular=False)\ncircular = Polynucleotide(sequence='ATGAAATAA', is_circular=True)\n</python>\n\nA student writes a serializer that saves only the sequence to a FASTA file\nand a deserializer that reconstructs the object with default values:\n\n<python>\ndef serialize(poly):\n    return f'>construct\\n{poly.sequence}'\n\ndef deserialize(fasta_text):\n    seq = fasta_text.split('\\n')[1]\n    return Polynucleotide(sequence=seq)\n</python>\n\nWhat happens when the circular plasmid is round-tripped through\nserialize then deserialize?\n",
      "choices": {
        "A": "The circular plasmid is correctly reconstructed as circular",
        "B": "The circular plasmid is reconstructed as linear — the circularity information is lost",
        "C": "A ValueError is raised because FASTA cannot store DNA sequences",
        "D": "The sequence itself is corrupted during serialization"
      },
      "answer": "B",
      "explanation": "The serializer only writes the sequence, discarding is_circular. The\ndeserializer reconstructs with defaults, and is_circular defaults to\nFalse. So a circular plasmid becomes linear after round-tripping. This\ndemonstrates why serialization must capture all semantically meaningful\nfields — the sequence alone is insufficient to reconstruct the full\nobject. A proper format (like GenBank) includes topology annotations.\nOption A would require the format to preserve circularity. Option C\nis wrong because FASTA is a standard sequence format. Option D is wrong\nbecause the sequence string itself is preserved faithfully.\n"
    },
    {
      "slug": "registry-lookup-failure",
      "difficulty": "medium",
      "topic": "Handling the case where a referenced identifier does not exist in the registry",
      "question": "A ConstructionFile references a plasmid by name:\n\n<pre>PCR oJC101 oJC102 pSB1C3 -> pcr_product</pre>\n\nThe parser looks up 'pSB1C3' in a local registry dict:\n\n<python>\ntemplate = registry['pSB1C3']\n</python>\n\nBut the researcher forgot to add pSB1C3 to their registry before running\nthe parser. What happens, and what is the best way to handle it?\n",
      "choices": {
        "A": "template is set to None, and the PCR step proceeds with no template",
        "B": "KeyError is raised; the parser should catch it and report which DNA name is missing",
        "C": "The parser automatically downloads pSB1C3 from a remote database",
        "D": "An empty Polynucleotide is created as a placeholder"
      },
      "answer": "B",
      "explanation": "Accessing a missing key in a dict raises KeyError. The best practice is\nfor the parser to catch this exception and produce a clear error message\nidentifying which name could not be resolved and which line of the\nConstructionFile references it. This follows the error-handling principle\nfrom Lec 2: fail early with a meaningful message rather than propagating\na None or placeholder that causes a confusing error later. Option A would\nlet the program silently continue with invalid data. Option C invents\nbehavior the parser does not have. Option D masks the problem.\n"
    },
    {
      "slug": "polynucleotide-extensions-meaning",
      "difficulty": "medium",
      "topic": "Understanding how optional fields modify the interpretation of a core required field",
      "question": "A Polynucleotide has a required sequence field and optional ext5 and ext3\nfields representing single-stranded overhangs:\n\n<python>\nfrag = Polynucleotide(\n    sequence='ATGAAAGGGCCC',\n    ext5='AATT',\n    ext3='',\n    is_double_stranded=True\n)\n</python>\n\nIn the physical DNA this represents, what is the structure at the 5' end\nversus the 3' end?\n",
      "choices": {
        "A": "The 5' end has a 4-nt single-stranded overhang; the 3' end is blunt",
        "B": "Both ends are blunt — ext5 and ext3 are metadata labels, not structural features",
        "C": "The 5' end is blunt; the 3' end has a 4-nt overhang",
        "D": "Both ends have 4-nt overhangs — ext3 defaults to matching ext5"
      },
      "answer": "A",
      "explanation": "The ext5 field represents a single-stranded extension on the 5' end of the\ntop strand. 'AATT' means there are 4 unpaired nucleotides hanging off the\n5' end. The ext3 field is '' (empty string), meaning no extension at the 3'\nend — the 3' end is blunt. This distinction matters for assembly: a 5'\noverhang can anneal with a complementary overhang on another fragment in\nGibson assembly or ligation. Option B misunderstands ext fields as mere\nlabels. Option C reverses which end has the overhang. Option D invents a\ndefaulting rule that does not exist — each extension is independent."
    }
  ],
  "api_contracts_and_mcp": [
    {
      "slug": "function-signature-as-contract",
      "difficulty": "medium",
      "topic": "Understanding that a function signature defines a contract between the implementer and every caller",
      "question": "A codon optimization function is documented as:\n\n<python>\ndef optimize_codons(cds: str, organism: str) -> str:\n    '''Accepts a DNA coding sequence and a host organism name.\n    Returns a codon-optimized DNA sequence of the same length.\n    Raises ValueError if cds length is not a multiple of 3.'''\n    ...\n</python>\n\nA colleague writes code that calls this function and checks the output:\n\n<python>\nresult = optimize_codons('ATGAAAGGG', 'ecoli')\nassert len(result) == len('ATGAAAGGG')\nassert result.startswith('ATG')\n</python>\n\nWhy is the len assertion justified but the startswith assertion risky?\n",
      "choices": {
        "A": "The signature guarantees same-length output; it makes no promise about preserving the start codon",
        "B": "Both assertions are guaranteed by the contract — ATG always maps to ATG",
        "C": "Neither assertion is safe — the return type str could be any string",
        "D": "The startswith check is safe because biological convention requires a start codon"
      },
      "answer": "A",
      "explanation": "The docstring explicitly states the return is \"a codon-optimized DNA sequence\nof the same length.\" That is a contractual guarantee the caller can rely on.\nHowever, the contract says nothing about preserving specific codons, including\nthe start codon. While most real optimizers would preserve ATG (the only\nmethionine codon in the standard code), the contract does not promise this.\nOption B assumes a biological fact that the API does not guarantee. Option C\nignores the explicit length guarantee in the docstring. Option D confuses\nbiological convention with an API contract — unless the documentation states\nit, callers should not assume it.\n"
    },
    {
      "slug": "separate-computation-from-io",
      "difficulty": "medium",
      "topic": "Recognizing why separating pure computation from I/O makes functions reusable and testable",
      "question": "Two approaches to computing the melting temperature of a primer:\n\n<python>\n# Version A\ndef get_tm_from_user():\n    seq = input('Enter primer sequence: ')\n    tm = 2 * seq.count('AT') + 4 * seq.count('GC')\n    print(f'Tm = {tm}')\n\n# Version B\ndef compute_tm(seq: str) -> float:\n    return 2 * seq.count('AT') + 4 * seq.count('GC')\n</python>\n\nA design pipeline needs to compute Tm for 500 primers stored in a list.\nWhich version can it use directly?\n",
      "choices": {
        "A": "Version A — it can be called in a loop with each primer",
        "B": "Version B — it accepts a sequence argument and returns a value, so it works with any data source",
        "C": "Both work equally well — print and return are interchangeable",
        "D": "Neither — both are incorrect because the Tm formula is oversimplified"
      },
      "answer": "B",
      "explanation": "Version A is tangled with I/O: it reads from the keyboard (input) and writes\nto the console (print). A pipeline processing 500 primers from a list cannot\nfeed sequences into input() or capture results from print(). Version B\nseparates the pure computation from all I/O — it takes a string and returns\na number. This makes it callable from any context: a loop, a test, a web\nserver, or another function. Option A fails because input() blocks waiting\nfor keyboard entry. Option C confuses print (a side effect) with return\n(a value the caller receives). Option D critiques the formula rather than\nthe design, which is the point of the question.\n"
    },
    {
      "slug": "pure-function-guarantees",
      "difficulty": "medium",
      "topic": "Identifying the guarantees a pure function provides and why they matter for reproducible pipelines",
      "question": "A gene design pipeline calls three functions in sequence:\n\n<python>\ndef codon_optimize(cds, codon_table):\n    '''Pure function: returns optimized CDS.'''\n    ...\n\ndef log_to_database(cds, timestamp):\n    '''Writes the CDS and timestamp to a remote database.'''\n    ...\n\ndef add_flanking_sequences(cds, vector):\n    '''Pure function: returns CDS with appropriate flanks.'''\n    ...\n</python>\n\nThe pipeline runs once and produces a correct result. The server hosting\nthe database then goes offline. What happens when the pipeline is rerun\nwith identical inputs?\n",
      "choices": {
        "A": "All three functions fail — the database outage propagates to pure functions",
        "B": "codon_optimize and add_flanking_sequences produce the same results; log_to_database fails",
        "C": "The pipeline produces a different result because the database cached state from the first run",
        "D": "All three succeed — Python automatically retries failed network calls"
      },
      "answer": "B",
      "explanation": "Pure functions depend only on their inputs and have no side effects. They\nwill produce identical results regardless of network status, database state,\nor any other external condition. log_to_database performs I/O (a side effect)\nand will fail when the database is unreachable. This illustrates why pure\nfunctions are preferred for the computational core of a pipeline: they are\nreproducible and resilient. Option A incorrectly claims pure functions are\naffected by external failures. Option C invents a caching dependency. Option D\ninvents an automatic retry mechanism that Python does not provide.\n"
    },
    {
      "slug": "mcp-host-client-server-roles",
      "difficulty": "medium",
      "topic": "Distinguishing the roles of host, client, and server in a layered protocol architecture",
      "question": "In the Model Context Protocol (MCP), three roles cooperate:\n\n- Server: exposes capabilities (Resources, Tools, Prompts)\n- Client: maintains a 1:1 connection with a server\n- Host: the user-facing application that coordinates clients\n\nA bioinformatics lab sets up an MCP server that exposes a codon\noptimization Tool. A researcher uses an LLM-powered assistant (the host)\nthat connects to this server. The LLM proposes calling the codon\noptimization tool for the sequence 'ATGAAACCC'.\n\nWho decides whether the tool is actually invoked?\n",
      "choices": {
        "A": "The server — it controls access to all tools it exposes",
        "B": "The LLM — it has already decided by including the tool call in its response",
        "C": "The host — it mediates between the LLM and the client, applying approval policies",
        "D": "The client — it autonomously executes any request the LLM generates"
      },
      "answer": "C",
      "explanation": "In MCP architecture, the LLM can propose tool invocations, but the host\napplication is responsible for applying approval policies before any tool\nis actually executed. The host sits between the user and the LLM, ensuring\nthat the human (or an automated policy) approves actions before they happen.\nThis is the \"human-in-the-loop\" or \"controlled action\" principle. Option A\nconfuses the server's role (exposing capabilities) with access control at\nthe host level. Option B mistakes a proposal for an execution. Option D\nremoves the approval step that is central to MCP's safety model.\n"
    },
    {
      "slug": "mcp-resources-vs-tools",
      "difficulty": "medium",
      "topic": "Distinguishing read-only data access from actions that produce side effects",
      "question": "An MCP server for a genetic design platform exposes the following:\n\nResource: \"parts-catalog\" — returns the current list of BioBrick parts\nResource: \"codon-tables\" — returns codon usage tables for supported organisms\nTool: \"run-optimization\" — accepts a CDS and returns an optimized sequence\nTool: \"order-dna\" — submits a DNA sequence to a synthesis vendor\n\nA student claims that Resources and Tools are interchangeable and that\n\"parts-catalog\" could just as easily be a Tool. What is wrong with this claim?\n",
      "choices": {
        "A": "Resources are for read-only data retrieval; Tools are for actions that may have side effects — conflating them defeats the safety model",
        "B": "Resources return JSON and Tools return plain text, so the formats are incompatible",
        "C": "Tools are faster than Resources, which is why computation should be a Tool",
        "D": "Resources can only be accessed by the server itself, not by external clients"
      },
      "answer": "A",
      "explanation": "MCP explicitly separates Resources (read-only, safe to access without\napproval) from Tools (actions that may modify state or trigger side effects).\nResources like \"parts-catalog\" are analogous to GET requests — the client\ncan read them freely. Tools like \"order-dna\" are analogous to POST requests\n— they require approval because they cause real-world effects. If the\nparts catalog were exposed as a Tool, the host would need to prompt for\napproval on every read, adding unnecessary friction. Option B invents a\nformat distinction that does not exist. Option C invents a performance\ndifference. Option D is wrong because Resources are specifically designed\nto be accessed by clients.\n"
    },
    {
      "slug": "tool-invocation-approval",
      "difficulty": "medium",
      "topic": "Understanding why proposed actions require explicit approval before execution",
      "question": "An MCP-connected assistant is helping a researcher design a plasmid.\nThe assistant has access to these tools:\n\nTool: \"blast-sequence\" — runs BLAST against NCBI (network call)\nTool: \"order-dna\" — submits a sequence to IDT for synthesis ($$$)\nTool: \"write-genbank\" — writes a GenBank file to disk\n\nThe LLM generates a plan: \"I'll BLAST your insert, write the GenBank file,\nand order the DNA.\" Under MCP's controlled invocation model, what should\nhappen next?\n",
      "choices": {
        "A": "All three tools execute immediately — the user already asked for help",
        "B": "The host presents the proposed tool calls to the user for approval before any execute",
        "C": "Only order-dna requires approval; blast and write-genbank run automatically",
        "D": "The server decides which tools are safe and executes those without asking"
      },
      "answer": "B",
      "explanation": "MCP treats all tool invocations as controlled actions. The LLM proposes\ntool calls, but the host must present them to the user (or evaluate them\nagainst a policy) before execution. This is critical because tools can have\nside effects: BLAST makes a network call, write-genbank modifies the\nfilesystem, and order-dna spends money. Even seemingly safe tools should go\nthrough the approval flow because the host cannot reliably judge safety\nwithout user context. Option A skips the approval step entirely. Option C\nassumes the host can selectively auto-approve, which may be possible as a\npolicy but is not the default model. Option D incorrectly places the\napproval decision at the server rather than the host.\n"
    },
    {
      "slug": "error-modes-raise-vs-return-none",
      "difficulty": "medium",
      "topic": "Choosing between raising an exception and returning a sentinel value to communicate failure",
      "question": "A function validates a DNA sequence before processing:\n\n<python>\n# Approach 1: raise on error\ndef validate_cds(seq):\n    if len(seq) % 3 != 0:\n        raise ValueError(f'CDS length {len(seq)} is not a multiple of 3')\n    return seq\n\n# Approach 2: return None on error\ndef validate_cds(seq):\n    if len(seq) % 3 != 0:\n        return None\n    return seq\n</python>\n\nA caller passes an invalid sequence and then immediately calls translate()\non the result without checking:\n\n<python>\ncds = validate_cds('ATGAA')\nprotein = translate(cds)\n</python>\n\nWhich approach leads to a more diagnosable failure?\n",
      "choices": {
        "A": "Approach 2 — returning None lets the caller decide how to handle the error",
        "B": "Approach 1 — the ValueError halts immediately with a message explaining the problem",
        "C": "Both are equivalent — translate will fail either way",
        "D": "Approach 2 — None is automatically skipped by translate"
      },
      "answer": "B",
      "explanation": "Approach 1 raises a ValueError at the point of failure with a clear message\nidentifying the problem. The traceback points directly to the validation\nstep. Approach 2 returns None silently; when translate(None) is called, it\nwill likely raise a TypeError or AttributeError inside translate — far from\nthe actual cause. The programmer must then trace backward to figure out\nwhere None came from. Option A correctly notes that None gives the caller a\nchoice, but the question asks about diagnosability when the caller does not\ncheck. Option C ignores that the quality of the error message differs\ndrastically. Option D invents behavior that translate does not have.\n"
    },
    {
      "slug": "function-scope-documentation",
      "difficulty": "medium",
      "topic": "Documenting what a function does and does not handle to set correct expectations",
      "question": "A function's docstring states:\n\n<python>\ndef remove_restriction_sites(cds: str, sites: list[str]) -> str:\n    '''Silently replaces codons to eliminate the specified restriction\n    sites from cds while preserving the encoded protein.\n\n    Scope: operates only on the coding region. Does not modify UTRs,\n    promoters, or flanking sequences. Does not check whether the\n    replacement introduces new forbidden sites not in the input list.\n\n    Raises ValueError if cds is not a valid reading frame.\n    Returns the modified CDS as a string.'''\n    ...\n</python>\n\nA researcher passes a full plasmid sequence (promoter + CDS + terminator)\nand finds that a BsaI site in the promoter is still present after the call.\nWhat went wrong?\n",
      "choices": {
        "A": "The function has a bug — it should scan the entire input for restriction sites",
        "B": "The researcher used the function outside its documented scope — it only operates on a coding region",
        "C": "BsaI sites cannot be removed computationally, only by manual design",
        "D": "The function silently failed because the promoter confused its reading-frame parser"
      },
      "answer": "B",
      "explanation": "The docstring explicitly states the function \"operates only on the coding\nregion\" and \"does not modify UTRs, promoters, or flanking sequences.\" The\nresearcher passed a full plasmid, violating the documented scope. This is\nnot a bug but a misuse: the function's contract clearly defines what input\nit expects and what it will and will not do. The fix is to extract the CDS,\ncall the function, and reassemble the full sequence. Option A blames the\nfunction for a scope the documentation intentionally excludes. Option C is\nfactually wrong. Option D invents a silent failure mode that contradicts\nthe documented ValueError behavior.\n"
    },
    {
      "slug": "reference-by-identifier-serialization",
      "difficulty": "medium",
      "topic": "Understanding why storing identifiers rather than full objects enables reliable serialization",
      "question": "A cloning plan is stored as a Python dict and serialized to JSON:\n\n<python>\n# Approach 1: embed full objects\nplan = {\n    'step': 'Gibson',\n    'fragments': [polynucleotide_obj_1, polynucleotide_obj_2]\n}\n\n# Approach 2: reference by identifier\nplan = {\n    'step': 'Gibson',\n    'fragment_ids': ['frag_001', 'frag_002']\n}\n</python>\n\nWhen json.dumps(plan) is called on each approach, what happens?\n",
      "choices": {
        "A": "Both serialize successfully — json.dumps handles any Python object",
        "B": "Approach 1 raises TypeError because custom objects are not JSON-serializable; Approach 2 succeeds because it stores only strings",
        "C": "Approach 2 fails because the identifiers cannot be resolved during serialization",
        "D": "Both fail — dicts cannot be serialized to JSON"
      },
      "answer": "B",
      "explanation": "json.dumps can serialize dicts, lists, strings, numbers, booleans, and None.\nCustom Python objects like Polynucleotide instances are not natively JSON-\nserializable and will raise TypeError unless a custom encoder is provided.\nApproach 2 stores only string identifiers, which serialize trivially. This\nis why reference-by-identifier is preferred in systems that exchange data\nas JSON: the plan becomes a lightweight document of identifiers, and each\nidentifier is resolved to its full object only when needed. Option A\noverstates json.dumps capabilities. Option C confuses serialization (writing\nthe identifier string) with resolution (looking up the object). Option D\nis wrong because dicts of basic types serialize fine.\n"
    },
    {
      "slug": "json-schema-contract-enforcement",
      "difficulty": "medium",
      "topic": "Using a schema as a machine-readable contract that enforces structure before data enters a system",
      "question": "A design tool accepts JSON input validated against this schema:\n\n<pre>\n{\n  \"type\": \"object\",\n  \"required\": [\"sequence\", \"organism\"],\n  \"properties\": {\n    \"sequence\": {\"type\": \"string\", \"pattern\": \"^[ATCG]+$\"},\n    \"organism\": {\"type\": \"string\", \"enum\": [\"ecoli\", \"yeast\", \"human\"]},\n    \"circular\": {\"type\": \"boolean\"}\n  },\n  \"additionalProperties\": false\n}\n</pre>\n\nWhich of the following JSON inputs passes validation?\n",
      "choices": {
        "A": "<pre>{\"sequence\": \"ATGCCC\", \"organism\": \"ecoli\"}</pre>",
        "B": "<pre>{\"sequence\": \"ATGCCC\", \"organism\": \"zebrafish\"}</pre>",
        "C": "<pre>{\"sequence\": \"ATGCCC\"}</pre>",
        "D": "<pre>{\"sequence\": \"ATGCCC\", \"organism\": \"ecoli\", \"temperature\": 37}</pre>"
      },
      "answer": "A",
      "explanation": "Option A provides both required fields (sequence and organism), the sequence\nmatches the regex pattern ^[ATCG]+$, organism is one of the allowed enum\nvalues, and circular is optional so its absence is fine. Option B fails\nbecause \"zebrafish\" is not in the enum [\"ecoli\", \"yeast\", \"human\"]. Option C\nfails because organism is listed in \"required\" but is missing. Option D\nfails because \"additionalProperties\": false forbids any key not listed in\n\"properties\" — temperature is not a declared property. The schema acts as\na machine-readable contract: it enforces structure, types, allowed values,\nand completeness before data enters the system, catching errors at the\nboundary rather than deep inside the computation."
    }
  ],
  "dna_rna_protein_and_core_processes": [
    {
      "slug": "transcription-directionality",
      "difficulty": "medium",
      "topic": "Understanding how enzyme movement on the template determines product directionality",
      "question": "RNA polymerase binds to a promoter and begins transcribing a gene. The\ntemplate strand is read 3'->5', and the new RNA is synthesized 5'->3'.\n\nA student claims that the mRNA sequence is identical to the template strand\nbecause the polymerase \"copies\" the template. What is wrong with this claim?\n",
      "choices": {
        "A": "The mRNA is complementary to the template strand, not identical to it",
        "B": "The mRNA is identical to the template strand but in the reverse direction",
        "C": "RNA polymerase does not use a template at all — it synthesizes RNA randomly",
        "D": "The mRNA is identical to the template strand except that T is replaced by U"
      },
      "answer": "A",
      "explanation": "RNA polymerase reads the template strand and synthesizes a complementary RNA.\nAt each position it pairs A with U, T with A, C with G, and G with C. The\nresulting mRNA is therefore complementary to the template strand and has the\nsame sequence as the coding (non-template) strand, except with U replacing T.\nOption D describes the relationship between the mRNA and the coding strand,\nnot the template strand — a common source of confusion.\n"
    },
    {
      "slug": "coding-vs-template-strand",
      "difficulty": "medium",
      "topic": "Distinguishing which strand carries the sequence that matches the product versus which strand is read",
      "question": "A gene has the following coding strand sequence in the region around the\nstart codon:\n\n<pre>\n5'-...ATGAAACCC...-3'  (coding strand)\n3'-...TACTTTAGGG...-5'  (template strand)\n</pre>\n\nWhich strand does RNA polymerase physically read, and what is the\ncorresponding mRNA sequence for this region?\n",
      "choices": {
        "A": "It reads the coding strand (5'->3'); mRNA is 5'-AUGAAACCC...-3'",
        "B": "It reads the template strand (3'->5'); mRNA is 5'-AUGAAACCC...-3'",
        "C": "It reads the template strand (3'->5'); mRNA is 5'-UACUUUGGG...-3'",
        "D": "It reads the coding strand (3'->5'); mRNA is 5'-CCCAAAGUA...-3'"
      },
      "answer": "B",
      "explanation": "RNA polymerase reads the template strand in its 3'->5' direction while\nsynthesizing the new RNA 5'->3'. Because the RNA is complementary to the\ntemplate, its sequence matches the coding strand with U substituted for T:\n5'-AUGAAACCC...-3'. Option A gives the correct mRNA but names the wrong\nstrand as the template. Option C shows the complement of the coding strand\nin RNA form, which would be the template re-read in the wrong direction.\nUnderstanding which strand is read versus which strand \"looks like\" the\nproduct is essential for interpreting gene annotations.\n"
    },
    {
      "slug": "uracil-in-rna",
      "difficulty": "medium",
      "topic": "Reasoning about why molecular differences between DNA and RNA have functional consequences",
      "question": "DNA uses thymine (T) while RNA uses uracil (U). Both bases pair with\nadenine. A student asks: \"If T and U both pair with A, does it matter which\none is used?\"\n\nWhich answer best explains why the distinction matters biologically?\n",
      "choices": {
        "A": "U pairs with A more strongly than T does, making RNA more stable",
        "B": "The cell uses the presence of U versus T to distinguish RNA from DNA, enabling selective degradation of RNA while preserving DNA",
        "C": "U cannot form base pairs in double-stranded structures, which is why RNA is always single-stranded",
        "D": "T and U are interchangeable; the difference is a historical accident with no functional significance"
      },
      "answer": "B",
      "explanation": "Although T and U both pair with A, the chemical difference (a single methyl\ngroup) allows the cell to discriminate between DNA and RNA. Enzymes like\nRNases specifically target RNA for rapid turnover, while DNA repair enzymes\nrecognize and remove uracil from DNA (treating it as a damaged cytosine).\nThis selective degradation is essential: mRNA must be transient to allow\nregulation, while the genome must be stable. Option A is backwards — the\nmethyl group on T actually contributes to DNA stability. Option C is false;\nRNA can and does form double-stranded regions (e.g., hairpins).\n"
    },
    {
      "slug": "genetic-code-direction",
      "difficulty": "medium",
      "topic": "Understanding why a lookup table is structured in one direction and what that implies for the reverse problem",
      "question": "The genetic code maps 64 codons to 20 amino acids plus stop signals.\nA student wants to go in the reverse direction: given an amino acid,\ndetermine the DNA codon to use. They try:\n\n<python>\ncodon = genetic_code[amino_acid]\n</python>\n\nwhere genetic_code maps codons to amino acids. This fails. But beyond the\ncoding error, why is the reverse problem fundamentally harder?\n",
      "choices": {
        "A": "Some amino acids have no codon at all",
        "B": "The reverse mapping is one-to-many — most amino acids are encoded by multiple codons, so there is no single answer",
        "C": "The genetic code is only valid in the 5'->3' direction and cannot be reversed",
        "D": "Amino acids map to codons in a different reading frame"
      },
      "answer": "B",
      "explanation": "The genetic code is degenerate: most amino acids are encoded by 2, 3, 4, or\n6 different codons. Translation (codon->amino acid) is a many-to-one mapping,\nso the forward lookup always has a unique answer. Reverse translation\n(amino acid->codon) is one-to-many, meaning you must choose among synonymous\ncodons. This choice is the basis of codon optimization. Option A is wrong —\nall 20 standard amino acids have at least one codon. Option C confuses\ndirectionality of reading with the reversibility of the mapping.\n"
    },
    {
      "slug": "start-stop-codon-roles",
      "difficulty": "medium",
      "topic": "Distinguishing the roles of signals that initiate versus terminate a molecular process",
      "question": "A gene's CDS begins with ATG and ends just before a stop codon (TAA, TAG,\nor TGA). A student designs a CDS but accidentally places a TAA codon in\nthe middle of the reading frame. The gene is transcribed normally. What is\nthe consequence during translation?\n",
      "choices": {
        "A": "The ribosome skips the internal TAA because stop codons only function at the end of a gene",
        "B": "The ribosome terminates translation at the internal TAA, producing a truncated protein",
        "C": "The internal TAA is read as an amino acid because context determines codon meaning",
        "D": "Transcription terminates at the internal TAA, so no mRNA is produced past that point"
      },
      "answer": "B",
      "explanation": "The ribosome reads codons sequentially from the start codon. When it\nencounters any in-frame stop codon — UAA in the mRNA — it terminates\ntranslation and releases the incomplete polypeptide. Stop codons have no\npositional requirement; they function wherever they appear in the reading\nframe. Option A reflects a misconception that stop codons are only\n\"active\" at designated gene boundaries. Option D confuses translation\ntermination with transcription termination, which depends on terminators,\nnot stop codons. This is why an accidental frameshift that introduces a\npremature stop codon is so damaging.\n"
    },
    {
      "slug": "gene-structure-element-order",
      "difficulty": "medium",
      "topic": "Understanding how the spatial arrangement of gene elements determines functional sequence of events",
      "question": "In E. coli, a gene is organized as:\n\n<pre>promoter (-35, -10) -> +1 -> 5'UTR (with RBS) -> ATG -> CDS -> stop -> terminator</pre>\n\nA student rearranges the design and places the RBS after the start codon.\nThe promoter, CDS, and terminator are correct. What happens?\n",
      "choices": {
        "A": "Transcription fails because the RBS is required for RNA polymerase binding",
        "B": "The mRNA is made normally, but the ribosome cannot initiate translation at the correct ATG because the RBS must be upstream of the start codon",
        "C": "Translation still works because the ribosome scans for any ATG regardless of RBS position",
        "D": "The protein is produced but in the wrong reading frame"
      },
      "answer": "B",
      "explanation": "The RBS (Shine-Dalgarno sequence) must be located in the 5'UTR, upstream of\nthe start codon, because the ribosome uses it to position itself so that the\nATG falls in the P site. Moving the RBS downstream of ATG means the ribosome\nhas no signal to land near the correct start codon. Transcription is\nunaffected because RNA polymerase uses the promoter, not the RBS. Option A\nconfuses the ribosome with RNA polymerase. Option C describes eukaryotic\nscanning, not prokaryotic translation initiation. This illustrates that gene\nelements are not interchangeable — their order reflects the sequence of\nmolecular events.\n"
    },
    {
      "slug": "replication-vs-transcription-products",
      "difficulty": "medium",
      "topic": "Comparing two processes that use template-directed synthesis but produce fundamentally different outputs",
      "question": "Both replication and transcription use a DNA template to synthesize a new\npolymer. A student says: \"They are basically the same process — one just\nuses a different polymerase.\"\n\nWhich statement best captures the key difference in what each process\nproduces?\n",
      "choices": {
        "A": "Replication produces two complete double-stranded DNA copies of the entire genome; transcription produces a single-stranded RNA copy of one gene",
        "B": "Replication produces RNA that is later converted to DNA; transcription produces DNA that is later converted to RNA",
        "C": "Replication copies only the coding strand; transcription copies only the template strand",
        "D": "Replication is error-free while transcription always introduces mutations"
      },
      "answer": "A",
      "explanation": "Replication duplicates the full genome, producing two dsDNA molecules — each\nan exact copy of the original. Transcription selectively copies individual\ngenes (or operons) into single-stranded RNA molecules, producing many copies\nof a transient message from one region of the genome. The processes differ in\nscope (whole genome vs. individual genes), product chemistry (DNA vs. RNA),\nand product lifespan (permanent vs. transient). Option C is wrong because\nreplication copies both strands. Option D overstates the fidelity difference;\nboth processes have error rates, though replication includes proofreading.\n"
    },
    {
      "slug": "information-carriers-comparison",
      "difficulty": "medium",
      "topic": "Reasoning about what each type of biological polymer encodes and why the system uses three rather than one",
      "question": "DNA, RNA, and protein each carry biological information, but they serve\ndifferent roles. A student proposes simplifying the system: \"Why not just\nuse DNA for everything? It is more stable and can encode information.\"\n\nWhat is the strongest argument for why the cell uses all three?\n",
      "choices": {
        "A": "DNA cannot fold into functional shapes, so proteins are needed for catalysis and structure while RNA serves as a disposable intermediate whose abundance can be regulated independently of gene copy number",
        "B": "RNA and protein are needed only because DNA is too expensive for the cell to produce in large quantities",
        "C": "Proteins are just folded RNA molecules, so the cell really only uses two information carriers",
        "D": "The three-polymer system exists because evolution has not yet optimized it to use only DNA"
      },
      "answer": "A",
      "explanation": "Each polymer has distinct capabilities. DNA is optimized for stable, long-term\nstorage but has limited catalytic and structural repertoire. Proteins, built\nfrom 20 chemically diverse amino acids, can fold into enzymes, structural\nelements, and signaling molecules that DNA cannot replicate. RNA serves as a\nregulatable intermediate: the cell can control how many mRNA copies exist\nindependently of the single gene in the genome, enabling dynamic responses.\nOption B ignores the functional differences. Option C is biochemically wrong.\nThe three-polymer system is not redundant — each step adds a different\ncapability.\n"
    },
    {
      "slug": "plasmid-origin-and-marker",
      "difficulty": "medium",
      "topic": "Understanding why autonomous genetic elements require both replication and selection functions",
      "question": "A minimal plasmid requires at least an origin of replication and a\nselectable marker (e.g., antibiotic resistance gene). A student removes\nthe origin of replication to make room for a larger insert, reasoning\nthat the host's chromosomal origin will replicate the plasmid too.\n\nWhat happens after transformation?\n",
      "choices": {
        "A": "The plasmid replicates using the host's origin and is maintained normally",
        "B": "The plasmid cannot replicate independently and is diluted out as cells divide, even under antibiotic selection",
        "C": "The plasmid integrates into the chromosome at the host's origin",
        "D": "The host cell cannot survive because plasmids without origins are toxic"
      },
      "answer": "B",
      "explanation": "A plasmid must carry its own origin of replication to be replicated by the\nhost's DNA polymerase as an independent molecule. The chromosomal origin only\ndirects replication of the chromosome itself. Without its own origin, the\nplasmid is not copied when the cell divides. It persists briefly in one\ndaughter cell but is progressively diluted with each division. Even under\nantibiotic selection, cells that still carry the plasmid are not viable long-\nterm because the plasmid copy number drops to zero. Option A reflects a\nmisconception that any origin can replicate any DNA in the cell. Option C\nwould require homologous sequences, which were not described.\n"
    },
    {
      "slug": "polycistronic-mrna-and-operons",
      "difficulty": "medium",
      "topic": "Connecting gene organization to mRNA structure and understanding what one transcript can encode",
      "question": "In E. coli, the lac operon contains three genes (lacZ, lacY, lacA) under\na single promoter. When the operon is induced, RNA polymerase transcribes\nall three genes into one mRNA molecule.\n\nHow many separate proteins can the ribosome produce from this single mRNA?\n",
      "choices": {
        "A": "One — each mRNA can only encode one protein",
        "B": "Three — each gene has its own RBS and start codon within the mRNA, so the ribosome initiates translation independently at each one",
        "C": "Three — but only if the mRNA is first cut into three separate pieces",
        "D": "It depends on the reading frame — all three genes must be in the same frame to be translated"
      },
      "answer": "B",
      "explanation": "A polycistronic mRNA contains multiple coding sequences, each preceded by its\nown RBS and start codon. Ribosomes in E. coli can initiate translation\nindependently at each RBS, producing separate proteins from the same\ntranscript. The mRNA does not need to be cut. Option A describes the\neukaryotic default (monocistronic mRNA), not the prokaryotic case. Option C\ninvents a processing step that is not required for bacterial translation.\nOption D is wrong because each gene has its own start codon defining its own\nreading frame — the three CDSs do not need to share a frame. This\norganization allows coordinated expression of functionally related genes."
    }
  ],
  "regulation_control_points": [
    {
      "slug": "promoter-elements-transcription-rate",
      "difficulty": "medium",
      "topic": "Identifying which molecular features of a promoter determine transcription initiation rate",
      "question": "You are comparing two promoters that drive expression of the same\ngene in E. coli. Promoter A has a -10 box of <pre>TATAAT</pre> and a -35 box of\n<pre>TTGACA</pre>. Promoter B has a -10 box of <pre>CATAAT</pre> and a -35 box of <pre>TTGACA</pre>.\nBoth use sigma-70. Promoter A produces 10x more transcript than\nPromoter B.\n\nWhich explanation best accounts for the difference?\n",
      "choices": {
        "A": "The single base change in the -10 box reduces sigma factor affinity, lowering RNAP recruitment",
        "B": "The -10 box change alters the mRNA sequence, destabilizing the ribosome binding site",
        "C": "Sigma factor only recognizes the -35 box, so the -10 change has no effect",
        "D": "The -10 mutation changes the protein sequence of the downstream gene"
      },
      "answer": "A",
      "explanation": "The sigma factor recognizes both the -10 and -35 boxes of the promoter.\nTATAAT is the consensus -10 sequence; a mismatch (CATAAT) reduces\nsigma binding affinity and therefore the rate at which RNA polymerase\nforms a stable open complex. This is a transcriptional control point.\nOption B confuses promoter DNA with the mRNA region that contains the\nRBS. Option C is wrong because sigma binds both boxes. Option D is\nwrong because the promoter is upstream of the coding sequence and is\nnot part of the translated region.\n"
    },
    {
      "slug": "rbs-sequence-translation-initiation",
      "difficulty": "medium",
      "topic": "Reasoning about how Shine-Dalgarno sequence complementarity affects translation rate",
      "question": "Two constructs encode the same protein but differ only in their\nribosome binding site (RBS) region. Construct 1 has the Shine-Dalgarno\nsequence <pre>AGGAGG</pre> at position -8 relative to the start codon. Construct 2\nhas <pre>ACCACC</pre> at the same position. Both produce identical mRNA levels.\n\nWhat is the most likely effect on protein expression?\n",
      "choices": {
        "A": "Construct 2 produces more protein because ACCACC avoids stalling",
        "B": "Both produce equal protein because the mRNA levels are the same",
        "C": "Construct 1 produces more protein because AGGAGG base-pairs more strongly with 16S rRNA",
        "D": "Construct 2 produces more protein because its SD sequence recruits additional ribosomes"
      },
      "answer": "C",
      "explanation": "The Shine-Dalgarno sequence works by base-pairing with the anti-SD\nsequence (UCCUCC) on the 3' end of 16S rRNA. AGGAGG is the consensus\nand provides the strongest complementarity. ACCACC has two mismatches,\ngreatly reducing base-pairing and therefore translation initiation rate.\nEqual mRNA levels do not guarantee equal protein — translation initiation\nis a separate, independently regulated control point. Option A and D\nhave no mechanistic basis; Option B confuses transcription with\ntranslation.\n"
    },
    {
      "slug": "secondary-structure-blocks-translation",
      "difficulty": "medium",
      "topic": "Understanding how mRNA secondary structure near the start codon can occlude the RBS",
      "question": "You design a construct with a strong Shine-Dalgarno sequence and\noptimal spacing to the start codon. However, when you run an RNA\nfolding prediction, you find that the SD sequence is sequestered in\na stable hairpin formed between the SD region and nucleotides\ndownstream of the start codon. Protein expression is very low\ndespite high mRNA levels.\n\nWhat is the most likely cause?\n",
      "choices": {
        "A": "The hairpin is acting as a Rho-independent terminator, ending transcription early",
        "B": "The hairpin occludes the SD sequence, preventing 30S ribosomal subunit binding",
        "C": "The hairpin changes the codon usage of the downstream CDS",
        "D": "The hairpin causes RNase E to degrade the mRNA before translation can begin"
      },
      "answer": "B",
      "explanation": "For translation to initiate, the 30S ribosomal subunit must access the\nShine-Dalgarno sequence to base-pair with 16S rRNA. If the SD is\ntrapped in a stable hairpin, the ribosome cannot bind, and translation\ninitiation is blocked regardless of how strong the SD sequence would\nbe if it were single-stranded. This is why secondary structure in the\nregion from roughly -4 to +37 relative to the start codon is a major\ndeterminant of expression. Option A describes a terminator, which\nrequires a hairpin followed by a U-rich tract at a specific location.\nOption C confuses structure with sequence. Option D is possible in\ngeneral but does not explain low protein with high mRNA.\n"
    },
    {
      "slug": "steady-state-mrna-levels",
      "difficulty": "medium",
      "topic": "Reasoning about how synthesis and degradation rates jointly determine steady-state mRNA concentration",
      "question": "Two genes are transcribed at the same rate from identical promoters.\nGene A's mRNA has a half-life of 2 minutes, while Gene B's mRNA has\na half-life of 20 minutes. Both are measured at steady state.\n\nWhat is the expected relationship between their mRNA levels?\n",
      "choices": {
        "A": "Gene A has ~10x more mRNA because faster turnover means faster production",
        "B": "Gene B has ~10x more mRNA because it persists longer before being degraded",
        "C": "Both have equal mRNA levels because they have the same transcription rate",
        "D": "Gene A has more mRNA because short-lived mRNAs are preferentially stabilized by ribosomes"
      },
      "answer": "B",
      "explanation": "At steady state, mRNA level is proportional to the synthesis rate\ndivided by the degradation rate. Since both genes have the same\ntranscription rate but Gene B's mRNA is degraded 10x more slowly\n(half-life 20 min vs 2 min), Gene B accumulates roughly 10x more\nmRNA. This is a fundamental principle: steady-state concentration\ndepends on both production and destruction. Option A reverses the\nrelationship. Option C ignores degradation entirely. Option D has\nno biological basis.\n"
    },
    {
      "slug": "codon-usage-expression-variation",
      "difficulty": "medium",
      "topic": "Understanding how synonymous codon choice affects protein expression independently of regulation",
      "question": "Two constructs encode the exact same GFP protein with identical\npromoters, RBS sequences, and terminators. The only difference is\nthat Construct 1 uses codons abundant in E. coli, while Construct 2\nuses rare codons throughout the CDS. Construct 1 produces 100x more\nfluorescence.\n\nWhich statement best explains this result?\n",
      "choices": {
        "A": "Rare codons change the amino acid sequence, producing a nonfunctional protein",
        "B": "Rare codons slow ribosome elongation, reducing the rate of completed protein and potentially destabilizing the mRNA",
        "C": "Rare codons prevent transcription by blocking RNA polymerase",
        "D": "Rare codons change the Shine-Dalgarno sequence, blocking translation initiation"
      },
      "answer": "B",
      "explanation": "Synonymous codons encode the same amino acid, so the protein sequence\nis unchanged (ruling out A). Rare codons correspond to low-abundance\ntRNAs, causing ribosome stalling during elongation. This reduces the\nrate at which completed proteins are produced and can also expose the\nmRNA to degradation. Studies like Plotkin's GFP codon variation work\nshow up to a 250-fold range in expression from codon choice alone.\nOption C is wrong because RNAP transcribes DNA without regard to codon\nidentity. Option D is wrong because the RBS region is in the 5' UTR,\nnot the CDS.\n"
    },
    {
      "slug": "rbs-swap-what-changes",
      "difficulty": "medium",
      "topic": "Distinguishing which molecular properties change vs. remain constant when an RBS part is swapped",
      "question": "You are tuning expression of an enzyme in a metabolic pathway. You\nswap the RBS in your construct from a strong RBS (high translation\ninitiation rate) to a weak RBS (low translation initiation rate).\nThe CDS, promoter, and terminator remain unchanged.\n\nWhich of the following changes as a result of this swap?\n",
      "choices": {
        "A": "The amino acid sequence of the enzyme",
        "B": "The metabolite concentrations in the pathway",
        "C": "The post-translational modifications of the enzyme",
        "D": "The enzymatic activity per molecule of protein"
      },
      "answer": "B",
      "explanation": "Swapping the RBS changes the translation initiation rate, which changes\nthe amount of enzyme produced. Less enzyme means the pathway's metabolic\nflux changes, altering metabolite concentrations. Critically, the RBS\nis in the 5' UTR and does not affect the coding sequence, so the amino\nacid sequence (A), protein function per molecule (D), and post-\ntranslational modifications (C) are all unchanged. This is a key\nprinciple in genetic design: the RBS tunes how much protein is made,\nnot what the protein is.\n"
    },
    {
      "slug": "transcriptional-vs-translational-control",
      "difficulty": "medium",
      "topic": "Classifying genetic parts by whether they act at the transcriptional or translational level",
      "question": "A student is debugging a construct that produces no detectable protein.\nThey measure mRNA and find abundant transcript. They then check the\n5' UTR and find the Shine-Dalgarno sequence has been deleted.\n\nAt which level of gene expression is the problem?\n",
      "choices": {
        "A": "Transcriptional — the promoter is not recruiting RNA polymerase",
        "B": "Translational — without an SD sequence, ribosomes cannot initiate translation on the mRNA",
        "C": "Post-translational — the protein is being degraded immediately after synthesis",
        "D": "Transcriptional — without the SD, RNA polymerase cannot terminate properly"
      },
      "answer": "B",
      "explanation": "The presence of abundant mRNA rules out a transcriptional defect — the\npromoter is working fine and the transcript is stable. The Shine-\nDalgarno sequence is required for 30S ribosomal subunit recruitment\nto the mRNA. Without it, translation cannot initiate, so no protein\nis made despite plentiful mRNA. This is a purely translational\ncontrol point. Option A is contradicted by the mRNA data. Option C\nrequires protein to have been made first. Option D confuses the SD\nwith the terminator.\n"
    },
    {
      "slug": "same-protein-different-cds-expression",
      "difficulty": "medium",
      "topic": "Explaining why identical proteins can have different expression levels from different DNA encodings",
      "question": "A lab orders two synthetic genes encoding the identical lysozyme\nprotein. Gene version 1 is codon-optimized for E. coli. Gene version 2\nuses the original bacteriophage codon usage. Both are cloned into the\nsame vector with the same promoter, RBS, and terminator. Version 1\nproduces 50x more lysozyme.\n\nWhat is the BEST explanation for why two DNA sequences encoding the\nsame protein yield such different expression levels?\n",
      "choices": {
        "A": "The different DNA sequences produce different amino acid sequences",
        "B": "The different codons result in different mRNA sequences, affecting secondary structure near the start codon and ribosome elongation rate",
        "C": "Codon-optimized genes have stronger promoters",
        "D": "The bacteriophage version has a weaker Shine-Dalgarno sequence"
      },
      "answer": "B",
      "explanation": "Synonymous codons change the mRNA nucleotide sequence without changing\nthe protein. This affects two things: (1) secondary structure in the\nregion around the start codon (-4 to +37), which can occlude the RBS\nand impair translation initiation, and (2) elongation rate, since rare\ncodons correspond to scarce tRNAs. Together these mechanisms explain\nlarge expression differences. Option A is wrong because synonymous\ncodons encode the same amino acids. Option C is wrong because both\nuse the same promoter. Option D is wrong because both use the same\nRBS — the SD sequence is in the 5' UTR, not the CDS.\n"
    },
    {
      "slug": "terminator-transcript-boundary",
      "difficulty": "medium",
      "topic": "Understanding how terminators define the 3' boundary of a transcript and prevent read-through",
      "question": "An operon contains Gene A followed by Gene B, each with its own RBS\nand start codon. A strong Rho-independent terminator is placed between\nGene A and Gene B. When the terminator is present, Gene B protein\nlevels are very low. When the terminator is removed, Gene B is\nexpressed at high levels from the same promoter driving Gene A.\n\nWhat role is the terminator playing?\n",
      "choices": {
        "A": "The terminator is degrading Gene B's protein after it is translated",
        "B": "The terminator hairpin is blocking the ribosome from reaching Gene B's start codon",
        "C": "The terminator causes RNA polymerase to dissociate before it can transcribe Gene B, so Gene B has no mRNA",
        "D": "The terminator changes the reading frame of Gene B"
      },
      "answer": "C",
      "explanation": "A Rho-independent terminator forms a stable hairpin followed by a\nU-rich tract in the nascent RNA, causing RNA polymerase to dissociate\nfrom the DNA template. When placed between Gene A and Gene B, it\nprevents transcriptional read-through, so Gene B is not transcribed\nand produces no mRNA. Removing the terminator allows RNAP to continue\nthrough Gene B, creating a polycistronic mRNA from which Gene B can\nbe translated using its own RBS. Option A confuses transcription with\nprotein degradation. Option B confuses the terminator with RBS\nocclusion. Option D has no mechanistic basis.\n"
    },
    {
      "slug": "rna-stability-expression-level",
      "difficulty": "medium",
      "topic": "Reasoning about how RNA degradation rate contributes to steady-state protein expression",
      "question": "You are engineering a biosensor where the output protein must respond\nquickly to the disappearance of an inducer signal. You want protein\nlevels to drop rapidly when transcription stops.\n\nWhich design strategy would MOST help achieve fast signal decay?\n",
      "choices": {
        "A": "Use a very stable mRNA with no RNase E cleavage sites so that translation continues efficiently",
        "B": "Engineer the mRNA to contain RNase E cleavage sites and use a protein degradation tag, so both mRNA and protein turn over rapidly",
        "C": "Use the strongest possible RBS to maximize translation before the mRNA is degraded",
        "D": "Remove the terminator so that read-through transcription produces more mRNA"
      },
      "answer": "B",
      "explanation": "Rapid signal decay requires that both the mRNA and the protein are\ncleared quickly once transcription stops. If the mRNA is stable (A),\nit continues to be translated long after the signal is gone, creating\na slow response. Adding RNase E sites destabilizes the mRNA so it is\ndegraded quickly, and a protein degradation tag (e.g., ssrA tag)\nensures existing protein is actively destroyed. Option C increases\npeak expression but does nothing for decay kinetics. Option D would\nincrease mRNA production, the opposite of what is needed. At steady\nstate, expression = synthesis - degradation, so tuning degradation\nrates of both mRNA and protein is essential for temporal control."
    }
  ],
  "genome_strain_and_chassis_constraints": [
    {
      "slug": "strain-vs-genotype-distinction",
      "difficulty": "medium",
      "topic": "Distinguishing between a population-level identity and the specific genetic changes that define it",
      "question": "A lab maintains a freezer stock labeled \"Mach1.\" A new student asks\nwhether \"Mach1\" refers to the specific mutations (recA1398, endA1, etc.)\nor to the population of cells in the tube.\n\nWhich answer is most precise?\n",
      "choices": {
        "A": "Mach1 is the genotype — it lists every mutation present in the cells",
        "B": "Mach1 is a strain — a genetically homogeneous population derived from a single cell; the genotype is the list of mutations that distinguish it from its parent",
        "C": "Mach1 is a phenotype — it describes what the cells can do, not what DNA they carry",
        "D": "Mach1 is a composition — it specifies what proteins should be present"
      },
      "answer": "B",
      "explanation": "A strain is a population-level concept: a genetically uniform group of cells\ntraced back to a single colony. The genotype is the specific set of genetic\nchanges (expressed as deltas from a parent strain) that characterize that\npopulation. Option A conflates the two — the name \"Mach1\" identifies the\nstrain, not the genotype itself. Option C confuses genotype with phenotype.\nOption D confuses strain with composition, which is an abstract design\nspecification rather than a living population.\n"
    },
    {
      "slug": "composition-specifies-vs-leaves-open",
      "difficulty": "medium",
      "topic": "Identifying what an abstract specification commits to and what it deliberately leaves unresolved",
      "question": "A Composition for a biosynthetic pathway specifies:\n- Host: E. coli\n- Proteins: LuxA, LuxB, LuxC, LuxD, LuxE\n\nA student assumes this Composition also determines the promoter\ndriving each gene and whether the genes are on a plasmid or integrated\ninto the chromosome. Is the student correct?\n",
      "choices": {
        "A": "Yes — a Composition must specify all implementation details to be useful",
        "B": "No — a Composition specifies the chassis and protein sequences but deliberately leaves expression level, regulatory elements, codon usage, and genomic vs plasmid unspecified",
        "C": "No — a Composition specifies only the DNA sequence, not the proteins",
        "D": "Yes — the host choice automatically determines promoters and gene location"
      },
      "answer": "B",
      "explanation": "A Composition is an abstract specification: it commits to what proteins\nshould be present in which host, but intentionally does not dictate how\nthose proteins are expressed. Regulatory elements, codon usage, expression\nlevels, and whether genes live on a plasmid or the chromosome are all\nimplementation decisions made later. This separation allows the same\nComposition to be realized in many different ways. Option A confuses an\nabstract spec with a complete build plan. Option C inverts the abstraction\nlevel — Composition specifies proteins, not DNA. Option D incorrectly\nassumes that choosing a host resolves all downstream decisions.\n"
    },
    {
      "slug": "genotype-as-delta-from-parent",
      "difficulty": "medium",
      "topic": "Understanding why genetic descriptions use relative changes from a reference rather than absolute sequences",
      "question": "The genotype of Mach1 is written as:\n\n<pre>str. W  deltarecA1398 endA1 fhuA phi80delta(lac)M15 delta(lac)X74 hsdR(rK- mK+)</pre>\n\nA student argues it would be simpler to just store the complete genome\nsequence instead of these cryptic delta annotations. What is the main\nreason genotypes are expressed as deltas from a parent strain?\n",
      "choices": {
        "A": "Delta notation compresses the file size so it fits in a database field",
        "B": "Deltas highlight what was intentionally changed, making it clear which mutations confer which properties — a full genome hides that information in millions of irrelevant bases",
        "C": "The complete genome of E. coli is unknown, so deltas are the only option",
        "D": "Delta notation is required by law for genetically modified organisms"
      },
      "answer": "B",
      "explanation": "The delta notation serves a cognitive and informational purpose: it tells\nyou exactly which mutations distinguish this strain from its parent and\ntherefore which properties were engineered or selected for. A full genome\nsequence contains millions of bases, and the handful of meaningful changes\nwould be invisible without comparison. The same principle applies in\nsoftware version control — a diff is more informative than two complete\nsnapshots. Option A treats it as a storage optimization, missing the\nsemantic point. Option C is factually wrong — E. coli genomes are well\nsequenced. Option D is fabricated.\n"
    },
    {
      "slug": "antibiotic-selection-compatibility",
      "difficulty": "medium",
      "topic": "Reasoning about why a selection system requires a specific relationship between host and vector properties",
      "question": "A researcher wants to transform a plasmid carrying a kanamycin resistance\ngene (KanR) into a strain that already has a chromosomal KanR insertion\nfrom a previous engineering step. They plan to select transformants on\nkanamycin plates.\n\nWhat is wrong with this plan?\n",
      "choices": {
        "A": "Nothing — more copies of KanR will make colonies grow faster, distinguishing transformants",
        "B": "The strain already survives on kanamycin, so both transformants and non-transformants form colonies — the selection cannot distinguish them",
        "C": "Two copies of KanR will be lethal to the cells due to overexpression toxicity",
        "D": "Kanamycin resistance only works when carried on a plasmid, not on the chromosome"
      },
      "answer": "B",
      "explanation": "Antibiotic selection works by killing cells that lack the resistance gene.\nIf the host strain already carries KanR chromosomally, all cells survive\non kanamycin plates regardless of whether they took up the plasmid. The\nselection has no power to distinguish transformed from untransformed cells.\nThe fix is to use a plasmid with a different resistance marker that the\nstrain does not already carry. Option A misunderstands selection — growth\nrate differences are not reliable enough. Option C invents a toxicity\nthat does not generally occur. Option D is factually wrong — chromosomal\nresistance genes function normally.\n"
    },
    {
      "slug": "same-composition-different-genotypes",
      "difficulty": "medium",
      "topic": "Understanding how an abstract specification can be realized as multiple distinct concrete implementations",
      "question": "Two labs independently implement the same Composition:\n- Host: E. coli\n- Proteins: GFP, LacI\n\nLab A puts both genes on a high-copy plasmid with strong promoters.\nLab B integrates both genes into the chromosome under weak promoters\nwith codon optimization for E. coli.\n\nBoth labs have cells expressing GFP and LacI. How do their results\nrelate to the Composition?\n",
      "choices": {
        "A": "Only Lab A correctly implements the Composition because plasmids are the standard method",
        "B": "Neither lab implements the Composition because they used different strategies",
        "C": "Both satisfy the Composition — it specifies which proteins must be present, not how they are expressed — but they have different genotypes and likely different phenotypes",
        "D": "Both have the same genotype because they started from the same Composition"
      },
      "answer": "C",
      "explanation": "A Composition specifies what (which proteins in which host) but not how\n(regulatory elements, copy number, codon usage, genomic location). Both\nlabs satisfy the abstract specification, but they made different\nimplementation choices, resulting in different genotypes (different DNA\nsequences and genome architectures) and likely different phenotypes\n(different expression levels, growth rates, metabolic burden). This is\nthe key distinction between abstract specification and concrete\nimplementation. Option A invents a preference the Composition does not\nencode. Option B misunderstands what satisfying a spec means. Option D\nconfuses Composition with genotype.\n"
    },
    {
      "slug": "chassis-constrains-design",
      "difficulty": "medium",
      "topic": "Reasoning about how the choice of host organism constrains which design elements are valid",
      "question": "A researcher designs a gene expression cassette using an E. coli sigma-70\npromoter and a strong E. coli ribosome binding site. They then attempt to\nmove this cassette into Saccharomyces cerevisiae (yeast) without any\nmodifications.\n\nWhat is most likely to happen?\n",
      "choices": {
        "A": "The gene will express normally — promoters and RBS sequences are universal across all organisms",
        "B": "The gene will express at a lower level due to codon usage differences, but the promoter and RBS will function",
        "C": "The gene will likely fail to express — yeast does not recognize bacterial sigma-70 promoters or Shine-Dalgarno-based RBS elements",
        "D": "The gene will express but produce a non-functional protein because yeast ribosomes translate faster"
      },
      "answer": "C",
      "explanation": "Transcription and translation machinery differ fundamentally between\nbacteria and eukaryotes. Yeast RNA polymerase does not recognize bacterial\nsigma-70 promoters, and yeast ribosomes do not use Shine-Dalgarno\nsequences for translation initiation. The cassette would need a yeast-\ncompatible promoter (e.g., GAL1), a Kozak-like context for translation\ninitiation, and potentially intron removal if the gene were from a\neukaryotic source. The chassis choice constrains which regulatory elements\nare valid. Option A falsely assumes universality. Option B underestimates\nthe problem — it is not just codon usage. Option D invents an incorrect\nmechanism.\n"
    },
    {
      "slug": "what-makes-a-strain-engineerable",
      "difficulty": "medium",
      "topic": "Identifying which genetic features of a host strain facilitate routine molecular cloning work",
      "question": "Mach1 carries several mutations including recA1398 (defective\nrecombination), endA1 (defective endonuclease), and hsdR(rK- mK+)\n(does not restrict foreign DNA but does methylate it).\n\nWhy are these mutations helpful for plasmid-based genetic engineering,\nas opposed to being random changes?\n",
      "choices": {
        "A": "They increase the growth rate of the bacteria, making experiments faster",
        "B": "They each remove a host defense system that would otherwise destroy or rearrange incoming DNA — recA prevents recombination of repeats, endA prevents nuclease degradation, and hsdR- prevents restriction of unmethylated DNA",
        "C": "They are auxotrophic markers that allow selection on minimal media",
        "D": "They enable the cells to survive at higher temperatures for heat-shock transformation"
      },
      "answer": "B",
      "explanation": "Each mutation in a cloning strain like Mach1 is chosen to disable a\nspecific host defense that would interfere with maintaining foreign DNA.\nrecA1398 prevents RecA-mediated recombination that could rearrange\nrepetitive sequences on plasmids. endA1 eliminates an endonuclease that\ndegrades plasmid DNA during miniprep extraction. hsdR(rK- mK+) prevents\nthe restriction system from cutting incoming unmethylated DNA while still\nmethylating DNA for protection. These are deliberate engineering choices,\nnot random mutations. Option A is not the primary purpose. Option C\nconfuses cloning mutations with nutritional markers. Option D confuses\nstrain genotype with transformation protocol.\n"
    },
    {
      "slug": "genotype-tokens-and-dna-changes",
      "difficulty": "medium",
      "topic": "Interpreting genotype notation tokens and connecting each token to a specific physical change in the DNA",
      "question": "A genotype includes the token \"delta(lac)X74\". A student interprets\nthis as meaning the lac operon is overexpressed because \"delta\" sounds\nlike it could mean \"enhanced.\"\n\nWhat does the delta symbol actually indicate in genotype notation,\nand what is the physical consequence?\n",
      "choices": {
        "A": "Delta means the gene is duplicated, so there are two copies of the lac operon",
        "B": "Delta means a deletion — the lacX74 region has been physically removed from the chromosome, so the strain cannot metabolize lactose via that pathway",
        "C": "Delta means the gene has been moved to a different chromosomal location",
        "D": "Delta means the gene is under a different promoter than the wild-type version"
      },
      "answer": "B",
      "explanation": "In standard genotype notation, the Greek letter delta (or the word\n\"delta\") denotes a deletion. delta(lac)X74 means a specific deletion\n(designated X74) has removed part of the lac operon from the chromosome.\nThe physical consequence is that the deleted DNA is gone — the strain\nlacks the corresponding gene products. This is important for blue-white\nscreening strains where the chromosomal lacZ is deleted and complemented\nby a partial copy on a plasmid. Option A invents a meaning for delta.\nOption C describes a translocation, not a deletion. Option D describes\na promoter swap, which would use different notation.\n"
    },
    {
      "slug": "context-changes-design-outcomes",
      "difficulty": "medium",
      "topic": "Reasoning about why the same genetic part produces different results in different genomic contexts",
      "question": "A researcher characterizes a promoter-RBS-GFP cassette on a high-copy\nplasmid (~100 copies per cell) in E. coli strain DH10B and measures\nstrong fluorescence. They then integrate the identical cassette as a\nsingle chromosomal copy in the same strain. Fluorescence drops by\nroughly 100-fold.\n\nWhat is the best explanation?\n",
      "choices": {
        "A": "The chromosomal DNA polymerase introduces mutations into the GFP gene during integration",
        "B": "Gene expression is proportional to gene copy number — a single chromosomal copy produces far less total mRNA and protein than ~100 plasmid copies",
        "C": "Chromosomal DNA cannot be transcribed by RNA polymerase",
        "D": "The promoter only functions when it is on a circular plasmid, not on a linear chromosome"
      },
      "answer": "B",
      "explanation": "Expression output depends on context, and gene copy number is a major\ncontextual variable. A high-copy plasmid provides roughly 100 templates\nfor transcription per cell, while a single chromosomal insertion provides\nonly one. With proportionally less mRNA produced, protein levels drop\naccordingly. This illustrates why Composition (which does not specify\ncopy number or location) is distinct from genotype — the same gene\nin a different context produces a very different phenotype. Option A\nis unlikely for a standard integration method. Option C is false —\nchromosomal genes are transcribed normally. Option D is false — promoters\nfunction regardless of DNA topology.\n"
    },
    {
      "slug": "dna-string-vs-composition-information",
      "difficulty": "medium",
      "topic": "Identifying what semantic information is lost when a biological design is reduced to a raw sequence string",
      "question": "A collaborator sends you a 3,000 bp DNA string with no other annotation.\nYou know it encodes a gene, but you don't know what organism it came from\nor how it should be used. Compared to receiving a Composition object that\nspecifies \"Host: E. coli, Protein: LuxA\", what information are you\nmissing from the raw DNA string alone?\n",
      "choices": {
        "A": "Nothing is missing — the DNA string contains all necessary information because you can derive the protein from the sequence",
        "B": "You are missing the host organism, the intended protein identity, and whether it should be on a plasmid or chromosome — information a Composition explicitly provides or that a Composition paired with design context would supply",
        "C": "You are missing only the host organism — the protein sequence can be derived by translating all six reading frames",
        "D": "The DNA string actually contains more information than the Composition because it specifies codon usage and regulatory elements"
      },
      "answer": "B",
      "explanation": "A raw DNA string lacks semantic context. You cannot determine from the\nsequence alone which organism it was designed for, what protein it is\nintended to encode (without knowing the correct reading frame and start\nsite), or where it belongs in a build plan. A Composition provides the\nhost and target protein identities explicitly. Conversely, option D is\npartially true — the DNA does encode codon choices and regulatory\nelements that Composition leaves open — but the question asks what you\nare *missing*, and the answer is the higher-level intent and context.\nOption A is wrong because translating a sequence requires knowing where\nthe CDS starts. Option C understates the problem — even finding the\nright ORF among six frames requires additional context."
    }
  ],
  "targeting_rules_and_design_logic": [
    {
      "slug": "reverse-complement-basic",
      "difficulty": "medium",
      "topic": "Applying a sequence transformation to make hidden information visible",
      "question": "What is the reverse complement of the DNA sequence:\n\n<pre>ATCGAGA</pre>\n",
      "choices": {
        "A": "<pre>3'-ATCGAGA-5'</pre>",
        "B": "<pre>5'-TCTCGAT-3'</pre>",
        "C": "<pre>ATCGAGA</pre>",
        "D": "<pre>TAGCTCT</pre>"
      },
      "answer": "B",
      "explanation": "The reverse complement is found in two steps: first take the complement\nof each base (A↔T, C↔G), so ATCGAGA becomes TAGCTCT. Then reverse that\nstring to keep the opposite strand in the standard 5'→3' orientation,\ngiving TCTCGAT.\n\nOption D is the complement only (not reversed). Option A is just the\noriginal sequence shown with reversed end labels, not the reverse\ncomplement. Option C is the unchanged input.\n\nTherefore the correct answer is 5'-TCTCGAT-3'.\n"
    },
    {
      "slug": "pam-constrains-editing-sites",
      "difficulty": "medium",
      "topic": "Understanding how a recognition rule limits where a tool can act on a sequence",
      "question": "A Cas9 CRISPR system requires an NGG PAM adjacent to the target site.\nA researcher wants to knock out a gene but finds no NGG motif within the\nfirst 200 bp of the coding sequence on either strand.\n\nWhat is the most accurate conclusion?\n",
      "choices": {
        "A": "Cas9 cannot target this region; a different CRISPR system or a target further downstream must be used",
        "B": "The researcher should add an NGG sequence to the gene before targeting it",
        "C": "Cas9 can still target the region if the guide RNA is made longer than 20 nt",
        "D": "The PAM requirement only applies to the forward strand, so checking one strand is sufficient"
      },
      "answer": "A",
      "explanation": "The PAM is a fixed requirement of the Cas9 protein — it must be present\nin the genomic DNA adjacent to the target. Without an NGG on either strand,\nCas9 has no valid binding site in that region. Option B is nonsensical\nbecause adding a PAM would require already editing the gene. Option C is\nwrong because guide length does not override the PAM requirement. Option D\nis wrong because DNA is double-stranded and the PAM can appear on either\nstrand.\n"
    },
    {
      "slug": "protospacer-extraction-indexing",
      "difficulty": "medium",
      "topic": "Translating a biological positional rule into correct sequence indices",
      "question": "A function searches a target DNA string for the Cas9 PAM and extracts\nthe 20 bp protospacer. Given:\n\n<python>\ntarget = 'ATGCCCTAGATGCCTGGCTCAGAAACCTGCC'\npam_index = target.find('GG', 21)   # returns 24\n</python>\n\nWhich slice correctly extracts the protospacer?\n",
      "choices": {
        "A": "target[pam_index - 21 : pam_index - 1]",
        "B": "target[pam_index - 20 : pam_index]",
        "C": "target[pam_index - 20 : pam_index - 1]",
        "D": "target[pam_index - 21 : pam_index]"
      },
      "answer": "A",
      "explanation": "The PAM is NGG, where the N is not part of the protospacer. The two G's\nfound at pam_index are the GG of NGG, so the N sits at pam_index - 1.\nThe 20 bp protospacer ends just before the N, spanning indices\npam_index - 21 through pam_index - 2 inclusive, which in Python slice\nnotation is target[pam_index - 21 : pam_index - 1]. Option B includes\nthe N in the protospacer. Option C is only 19 bp. Option D is 21 bp\nand includes the N.\n"
    },
    {
      "slug": "off-by-one-consequence",
      "difficulty": "medium",
      "topic": "Reasoning about how an indexing error propagates into a biological design failure",
      "question": "A student's gRNA design function extracts the protospacer as:\n\n<python>\nprotospacer = target[pam_index - 20 : pam_index]\n</python>\n\ninstead of the correct target[pam_index - 21 : pam_index - 1].\nThe resulting guide RNA is synthesized and tested. What is the most\nlikely outcome?\n",
      "choices": {
        "A": "The guide targets a shifted position that overlaps the PAM by one base, likely reducing or eliminating editing",
        "B": "The guide will work identically because one base difference is tolerated",
        "C": "The function will raise an IndexError at runtime",
        "D": "The guide RNA will be 19 bp instead of 20 bp"
      },
      "answer": "A",
      "explanation": "The incorrect slice includes the N of the NGG PAM and excludes the first\nbase of the true protospacer. The resulting 20-mer is shifted by one\nposition toward the PAM. Because the guide must pair with the target\nadjacent to (not overlapping) the PAM, this mismatch at the PAM-proximal\nend — the seed region critical for binding — will likely abolish or\nseverely reduce editing. The slice still produces a 20 bp string\n(not 19), and it will not cause an IndexError.\n"
    },
    {
      "slug": "both-strands-must-be-checked",
      "difficulty": "medium",
      "topic": "Recognizing when a search must consider complementary representations of the same data",
      "question": "A function searches for Cas9 PAM sites on a target gene:\n\n<python>\ndef find_pam(target):\n    return target.find('GG', 21)\n</python>\n\nIt returns -1 for a known targetable gene. A colleague points out the\nerror. What did the function fail to do?\n",
      "choices": {
        "A": "Search the reverse complement of the target for GG on the opposite strand",
        "B": "Search for 'CC' instead, since that is the complement of GG",
        "C": "Use a regular expression instead of .find()",
        "D": "Search from position 0 instead of position 21"
      },
      "answer": "A",
      "explanation": "DNA is double-stranded. A PAM site can be on either strand. If the\nforward strand has no GG in a valid position, the reverse complement\nstrand might. The function must generate the reverse complement and\nsearch it as well. Option B is wrong because searching for CC on the\nforward strand is not equivalent to finding GG on the reverse strand —\nthe spatial relationship to the protospacer differs. Option C would not\nfix the missing-strand problem. Option D would find GG's too close to\nthe start for a valid 20 bp protospacer.\n"
    },
    {
      "slug": "guide-rna-from-protospacer",
      "difficulty": "medium",
      "topic": "Tracing a data transformation through multiple encoding steps",
      "question": "Given a DNA target with protospacer <pre>CATCGCCGCAGCGGTTTCAG</pre> adjacent to\nan NGG PAM, a function must produce the guide RNA. The gRNA scaffold is\na constant string appended after the targeting sequence. Which step\ncorrectly converts the protospacer to the targeting portion of the gRNA?\n",
      "choices": {
        "A": "Replace every T in the protospacer with U to produce the RNA version of the same sequence",
        "B": "Take the reverse complement of the protospacer and then replace T with U",
        "C": "Translate the protospacer into amino acids using the genetic code",
        "D": "Reverse the protospacer string without complementing, then replace T with U"
      },
      "answer": "A",
      "explanation": "The guide RNA base-pairs with the target strand, so its sequence is\ncomplementary to the target strand — which is the same as the non-target\n(protospacer) strand. Therefore the gRNA targeting sequence is simply\nthe protospacer sequence rewritten as RNA (T→U). Option B would produce\na sequence complementary to the protospacer, which is the target strand\nitself — the guide would pair with itself conceptually. Option C confuses\ntranscription with translation. Option D reverses without complementing,\nwhich produces a meaningless sequence.\n"
    },
    {
      "slug": "cas12a-vs-cas9-rules",
      "difficulty": "medium",
      "topic": "Recognizing how changing a system's rules changes the algorithm that implements it",
      "question": "Cas9 uses an NGG PAM on the 3' side of the protospacer, while Cas12a\nuses a TTTV PAM on the 5' side. A student has a working Cas9 gRNA\ndesign function. Which change is necessary to adapt it for Cas12a?\n",
      "choices": {
        "A": "Search for TTTV instead of NGG, and extract the protospacer downstream (3') of the PAM instead of upstream",
        "B": "Simply replace the string 'GG' with 'TTTV' in the search; the protospacer extraction stays the same",
        "C": "Keep the same PAM search but reverse complement the entire target before running the function",
        "D": "Use the same function but extend the protospacer from 20 bp to 24 bp"
      },
      "answer": "A",
      "explanation": "Cas12a has a fundamentally different PAM position relative to the\nprotospacer. The PAM sits on the 5' side, so the protospacer is\nextracted from positions downstream (3') of the PAM — the opposite\ndirection from Cas9. Option B changes only the search pattern but not\nthe extraction direction, which would grab the wrong region. Option C\ndoes not address the different spatial relationship. Option D changes\nprotospacer length but not the extraction logic.\n"
    },
    {
      "slug": "no-valid-pam-error-handling",
      "difficulty": "medium",
      "topic": "Deciding what a function should do when a required precondition is not met",
      "question": "A gRNA design function searches for a PAM in the target sequence but\nfinds none. Which is the best way to handle this case?\n",
      "choices": {
        "A": "Raise a ValueError with a message explaining that no valid PAM was found",
        "B": "Return None silently so the caller can check for it",
        "C": "Return a gRNA using positions 0–19 as a default protospacer",
        "D": "Print a warning message and return an empty string"
      },
      "answer": "A",
      "explanation": "When a required biological precondition (the PAM must exist) is not met,\nthe function cannot produce a valid result. Raising a ValueError with a\nclear message immediately signals the problem and prevents downstream\ncode from using an invalid design. Option B forces every caller to check\nfor None, and forgetting this check leads to subtle bugs. Option C\nreturns an incorrect design that would fail experimentally. Option D\nmixes output channels and returns a value that could be mistaken for\na valid (but empty) result.\n"
    },
    {
      "slug": "reverse-complement-for-strand-check",
      "difficulty": "medium",
      "topic": "Applying a sequence transformation to make hidden information visible",
      "question": "To check for PAM sites on the opposite strand of a target, a function\nbuilds the reverse complement. Given:\n\n<pre>target = 'ATGCCAGTGC'</pre>\n\nWhat is the reverse complement?\n",
      "choices": {
        "A": "<pre>GCACTGGCAT</pre>",
        "B": "<pre>TACGGTCACG</pre>",
        "C": "<pre>CGTGACCGTA</pre>",
        "D": "GCACTGGCAT reversed is TACGGTCACG"
      },
      "answer": "A",
      "explanation": "The reverse complement is computed in two steps: (1) complement each base\n(A↔T, C↔G), giving TACGGTCACG, then (2) reverse the string, giving\nGCACTGGCAT. Option B is only the complement without reversing. Option C\nis only the reverse without complementing. Option D describes two\ndifferent strings and is not a valid answer. The reverse complement\npreserves 5'→3' reading convention for the opposite strand.\n"
    },
    {
      "slug": "parameterizing-pam-rule",
      "difficulty": "medium",
      "topic": "Designing a function interface that accommodates varying biological rules",
      "question": "A lab uses both Cas9 (PAM = NGG) and Cas12a (PAM = TTTV) in different\nexperiments. A developer wants a single gRNA design function that works\nfor both systems. What is the best approach?\n",
      "choices": {
        "A": "Accept the PAM pattern, protospacer length, and PAM-side (5' or 3') as parameters",
        "B": "Hard-code both PAM rules with an if/else and a system_name string parameter",
        "C": "Write two completely separate functions with no shared code",
        "D": "Always search for both PAMs and return whichever match is found first"
      },
      "answer": "A",
      "explanation": "Parameterizing the PAM pattern, protospacer length, and orientation\nmakes the function extensible to any CRISPR system without code changes.\nOption B works for two systems but requires modifying the function body\nfor every new system. Option C duplicates code. Option D conflates two\ndifferent design tasks — the user must specify which system is being used,\nsince the two systems produce incompatible guides.\n"
    },
    {
      "slug": "strand-orientation-and-protospacer",
      "difficulty": "medium",
      "topic": "Reasoning about how two complementary representations of the same data relate to each other",
      "question": "A target gene's forward strand (5'→3') reads:\n\n<pre>\n...ACGTTGACCGATCCTGAAGG TCA...\n                        ^^\n                     GG = PAM\n</pre>\n\nThe GG at positions shown is the Cas9 PAM. The 20 bp protospacer on\nthis strand would read 5'-ACGTTGACCGATCCTGAAGG-3' minus the last two\nbases (the GG). But a colleague says the protospacer should come from\nthe reverse strand. Who is correct?\n",
      "choices": {
        "A": "The protospacer is read from the strand that contains the NGG PAM, upstream of the PAM — the forward strand in this case",
        "B": "The protospacer always comes from the reverse strand regardless of which strand has the PAM",
        "C": "Both strands give the same protospacer because DNA is double-stranded",
        "D": "The protospacer comes from whichever strand has a higher GC content"
      },
      "answer": "A",
      "explanation": "The protospacer is defined as the 20 bp immediately upstream (5') of the\nNGG PAM, on the same strand where the PAM is found. The guide RNA will\nmatch this protospacer sequence (as RNA). If the PAM were found on the\nreverse strand instead, the protospacer would be read from the reverse\nstrand. Option B is incorrect because strand choice depends on PAM\nlocation. Option C is wrong — the two strands give complementary, not\nidentical, sequences. Option D is nonsensical."
    }
  ],
  "transcription_and_translation_control_elements": [
    {
      "slug": "promoter-elements-and-transcription-rate",
      "difficulty": "medium",
      "topic": "Understanding how sequence features at defined positions control the rate of a process",
      "question": "In E. coli, the sigma-70 factor recognizes two conserved regions in a\npromoter. A researcher mutates the -10 box from <pre>TATAAT</pre> to <pre>TGTAAT</pre> and\nobserves a large drop in mRNA production.\n\nWhich explanation best accounts for this result?\n",
      "choices": {
        "A": "The -10 box is where sigma factor binds to initiate transcription; mutating it reduces RNAP recruitment",
        "B": "The -10 box is the ribosome binding site; mutating it prevents translation",
        "C": "The mutation introduced a premature stop codon in the mRNA",
        "D": "The -10 box controls mRNA degradation rate, not transcription initiation"
      },
      "answer": "A",
      "explanation": "The -10 box (Pribnow box) and the -35 box are recognized by the sigma\nfactor, which recruits RNA polymerase to initiate transcription. Changing\nthe -10 consensus reduces sigma binding affinity and thus transcription\nrate. Option B confuses promoter elements with the RBS. Option C is\nwrong because the -10 box is upstream of the coding region. Option D\nis incorrect — mRNA degradation is controlled by RNase activity and\nRNA structure, not the -10 box.\n"
    },
    {
      "slug": "shine-dalgarno-and-translation-initiation",
      "difficulty": "medium",
      "topic": "Reasoning about how complementary base-pairing between two molecules determines interaction strength",
      "question": "The Shine-Dalgarno (SD) sequence in an mRNA base-pairs with the 3' end\nof 16S rRNA in the ribosome. If a synthetic 5' UTR has the SD sequence\n<pre>AGGAGG</pre>, and another has <pre>AAGAAG</pre>, which construct is expected to have\nhigher translation initiation rate, and why?\n",
      "choices": {
        "A": "AGGAGG, because it has stronger complementarity to the 16S rRNA anti-SD sequence",
        "B": "AAGAAG, because more A residues form stronger hydrogen bonds",
        "C": "Both will have equal translation rates because the start codon is what matters",
        "D": "AGGAGG, because it has higher GC content which stabilizes the mRNA"
      },
      "answer": "A",
      "explanation": "The anti-Shine-Dalgarno sequence on the 16S rRNA is complementary to\nAGGAGG. Stronger complementarity means more stable base-pairing, which\nrecruits the ribosome more effectively. AAGAAG has mismatches at two\npositions, weakening the interaction. Option B is incorrect — A-U pairs\nare actually weaker than G-C pairs. Option C ignores the well-established\nrole of the SD in translation initiation. Option D confuses GC content\nof the SD with mRNA stability.\n"
    },
    {
      "slug": "hairpin-occlusion-of-rbs",
      "difficulty": "medium",
      "topic": "Understanding how competing molecular interactions can mask a functional site",
      "question": "An RBS with a strong Shine-Dalgarno sequence (<pre>AGGAGG</pre>) is paired with a\nnew coding sequence. Despite the strong SD, almost no protein is produced.\nA secondary structure prediction reveals a stable hairpin that includes\nthe SD region.\n\nWhat is the most likely explanation?\n",
      "choices": {
        "A": "The hairpin sequesters the SD in a double-stranded stem, preventing ribosome binding",
        "B": "The hairpin blocks RNA polymerase from transcribing past the RBS",
        "C": "The hairpin causes the ribosome to translate the mRNA in the wrong reading frame",
        "D": "The hairpin degrades the mRNA before it can be translated"
      },
      "answer": "A",
      "explanation": "When the SD sequence is trapped in a hairpin stem, it is base-paired with\na nearby complementary region and physically unavailable for pairing with\nthe 16S rRNA. The ribosome cannot bind, so translation does not initiate.\nThis is \"RBS occlusion.\" Option B is wrong — hairpins downstream of the\npromoter don't block RNAP (terminators require specific structures).\nOption C — hairpins don't shift reading frame. Option D — while RNA\nstructure can affect stability, the described mechanism is occlusion of\nthe binding site, not degradation.\n"
    },
    {
      "slug": "context-dependent-rbs-performance",
      "difficulty": "medium",
      "topic": "Recognizing that a component's function depends on its neighbors, not just its own properties",
      "question": "A standard BioBrick RBS part is reported to produce high expression of\nGFP. When the same RBS is placed upstream of a different gene, expression\ndrops to near zero. What is the most plausible explanation?\n",
      "choices": {
        "A": "The new CDS sequence forms a hairpin with the RBS, occluding the Shine-Dalgarno site",
        "B": "The RBS has mutated during the cloning process",
        "C": "BioBrick RBS parts only work with GFP",
        "D": "The new gene's protein product is toxic, so the cells cannot grow"
      },
      "answer": "A",
      "explanation": "RBS function is context-dependent: the sequence immediately downstream\n(the beginning of the CDS) can form secondary structures with the RBS\nregion. If the new CDS has a sequence complementary to the SD region, a\nhairpin forms that occludes ribosome binding. This is why \"standardized\"\nRBS parts work approximately 2/3 of the time — the other 1/3 fail due\nto context effects. Option B is possible but unlikely as the primary\nexplanation. Option C is incorrect — RBS parts are general. Option D\nis a different failure mode unrelated to the RBS itself.\n"
    },
    {
      "slug": "sd-spacing-affects-expression",
      "difficulty": "medium",
      "topic": "Understanding how spatial relationships between functional elements affect system output",
      "question": "An RBS design tool reports that the optimal spacing between the\nShine-Dalgarno sequence and the start codon (ATG) is 7 nucleotides for\na given system. If a designer accidentally inserts 2 extra bases between\nthe SD and the ATG, what is the expected effect?\n",
      "choices": {
        "A": "Translation initiation rate will decrease because the ribosome is positioned incorrectly relative to the start codon",
        "B": "Translation will not be affected because the SD sequence itself is unchanged",
        "C": "Transcription will fail because the promoter spacing is disrupted",
        "D": "The protein will be produced but with two extra amino acids at the N-terminus"
      },
      "answer": "A",
      "explanation": "The spacing between the SD and the start codon determines where the\nribosome is physically positioned when it scans for the AUG. If the\nspacing is wrong by even 1–2 bases, the ribosome may not be correctly\naligned with the start codon, reducing or abolishing translation\ninitiation. Option B ignores the well-documented importance of spacing.\nOption C confuses RBS spacing with promoter spacing. Option D is wrong\nbecause the bases between SD and ATG are in the 5' UTR, not the coding\nregion.\n"
    },
    {
      "slug": "secondary-structure-near-start-codon",
      "difficulty": "medium",
      "topic": "Identifying which region of a sequence has the greatest impact on a measured output",
      "question": "In a study of 154 GFP variants with different codon usage but identical\nprotein sequences, researchers found a 250-fold range in fluorescence.\nWhich sequence region's secondary structure best predicted expression\nlevel?\n",
      "choices": {
        "A": "The region from -4 to +37 relative to the start codon",
        "B": "The full-length mRNA secondary structure",
        "C": "The last 50 bp of the coding sequence near the stop codon",
        "D": "The promoter region from -35 to +1"
      },
      "answer": "A",
      "explanation": "The Plotkin GFP study showed that secondary structure in the region from\napproximately -4 to +37 (spanning the RBS–CDS junction) explained\nroughly 44–57% of expression variation. Full-length mRNA folding energy\ndid not significantly correlate with expression. The 3' end of the CDS\nwas not predictive. The promoter was identical across all variants, so\nit cannot explain the variation.\n"
    },
    {
      "slug": "operon-structure-and-transcription",
      "difficulty": "medium",
      "topic": "Reasoning about how a structural arrangement implies shared control of multiple components",
      "question": "In an operon design, three genes (A, B, C) are placed under a single\npromoter and a single terminator, each with its own RBS. If the\npromoter is repressed, what happens to expression of genes A, B, and C?\n",
      "choices": {
        "A": "All three genes lose transcription simultaneously because they share one promoter",
        "B": "Only gene A is affected because it is closest to the promoter",
        "C": "Gene C is affected first because the terminator blocks it",
        "D": "Each gene is affected independently because each has its own RBS"
      },
      "answer": "A",
      "explanation": "In an operon, a single promoter drives transcription of one polycistronic\nmRNA containing all three genes. If the promoter is repressed, no mRNA\nis made for any of the three genes. Individual RBS elements control\ntranslation initiation of each gene independently, but they cannot\nfunction without the mRNA that the promoter produces. Option B\nmisunderstands polycistronic transcription. Option C confuses terminator\nfunction. Option D confuses transcriptional and translational control.\n"
    },
    {
      "slug": "promoter-vs-rbs-vs-codon-effects",
      "difficulty": "medium",
      "topic": "Distinguishing which level of control is responsible for an observed change in output",
      "question": "A designer wants to reduce expression of a protein by 10-fold without\nchanging the protein sequence. Which modification targets the correct\nlevel of control?\n",
      "choices": {
        "A": "Replace the RBS with a weaker Shine-Dalgarno sequence",
        "B": "Change the stop codon from TAA to TGA",
        "C": "Remove the origin of replication from the plasmid",
        "D": "Add a His-tag to the protein's C-terminus"
      },
      "answer": "A",
      "explanation": "The RBS controls translation initiation rate. A weaker SD sequence\nreduces ribosome recruitment, directly lowering protein output without\naltering the protein sequence. Option B changes the stop codon but both\nare valid stops — the effect on expression is minimal. Option C would\nprevent the plasmid from replicating entirely, not modulate expression.\nOption D changes the protein sequence (adds a tag), violating the\nconstraint.\n"
    },
    {
      "slug": "rbs-does-not-change-protein",
      "difficulty": "medium",
      "topic": "Distinguishing which design changes affect information content versus expression level",
      "question": "A Composition specifies that protein X should be expressed in E. coli.\nAn engineer creates two constructs with different RBS parts but identical\nCDS sequences. Which of the following is true about the two constructs?\n",
      "choices": {
        "A": "They produce the same protein at different expression levels",
        "B": "They produce different proteins because the RBS is translated",
        "C": "They have different mRNA sequences and different protein sequences",
        "D": "They will have identical expression levels because the CDS is the same"
      },
      "answer": "A",
      "explanation": "The RBS is in the 5' UTR, upstream of the start codon. It is not\ntranslated into protein. Changing the RBS alters how efficiently\nribosomes initiate translation (and changes the mRNA sequence in the\nUTR region), but the protein product is determined solely by the CDS.\nOption B is wrong — the RBS is not part of the open reading frame.\nOption C is half right (mRNA differs) but wrong about protein. Option D\nignores the established role of RBS strength in determining expression.\n"
    },
    {
      "slug": "construct-parts-interaction",
      "difficulty": "medium",
      "topic": "Reasoning about how parts of an assembly interact rather than function in isolation",
      "question": "A genetic construct consists of: promoter → RBS → CDS → terminator.\nA designer tests 5 different RBS parts with the same CDS and finds that\nexpression varies by 100-fold. However, when the same 5 RBS parts are\ntested with a different CDS, the ranking of the parts changes.\n\nWhat does this result demonstrate?\n",
      "choices": {
        "A": "RBS performance depends on the downstream CDS context, likely through secondary structure interactions at the RBS–CDS junction",
        "B": "The CDS somehow modifies the RBS DNA sequence during replication",
        "C": "The ranking changed because the two experiments were done on different days",
        "D": "RBS parts have inherent expression levels that are independent of context"
      },
      "answer": "A",
      "explanation": "The fact that the ranking changes with different CDS proves that RBS\nfunction is context-dependent. The most established mechanism is\nsecondary structure formation between the RBS region and the beginning\nof the CDS, which can occlude the Shine-Dalgarno site to varying\ndegrees depending on the CDS sequence. Option B invokes a biologically\nimplausible mechanism. Option C attributes the result to noise rather\nthan the systematic effect observed. Option D directly contradicts the\nobservation."
    }
  ],
  "construction_methods_and_constraints": [
    {
      "slug": "pcr-primer-3prime-matching",
      "difficulty": "medium",
      "topic": "Understanding why only part of a component must match for a process to initiate",
      "question": "In PCR, a primer is designed with a 20 bp 3' annealing region that\nmatches the template and a 15 bp 5' tail that adds a new sequence.\nWhy does the 5' tail not need to match the template?\n",
      "choices": {
        "A": "DNA polymerase extends only from the 3' end, so only the 3' region needs to base-pair with the template for priming",
        "B": "The 5' tail is removed by an exonuclease during the first PCR cycle",
        "C": "The 5' tail anneals to the opposite strand of the template",
        "D": "Both ends must match the template, but mismatches at the 5' end are tolerated by polymerase"
      },
      "answer": "A",
      "explanation": "DNA polymerase requires a base-paired 3' hydroxyl to begin synthesis.\nThe 3' end of the primer anneals to the template and provides this\nsubstrate. The 5' tail hangs free during the first cycle but becomes\nincorporated into the product, which then serves as a template in\nsubsequent cycles. Option B is wrong — the tail is not removed. Option C\nis incorrect — the tail is not designed to anneal anywhere. Option D\noverstates it — the 5' end genuinely does not need to match.\n"
    },
    {
      "slug": "gibson-assembly-homology",
      "difficulty": "medium",
      "topic": "Understanding how shared sequence between fragments enables joining without specific recognition sites",
      "question": "In Gibson assembly, two DNA fragments are joined by including ~20 bp\nof identical sequence at the ends that should connect. What is the role\nof this shared homology?\n",
      "choices": {
        "A": "After T5 exonuclease creates single-stranded overhangs, the homologous regions anneal to join the fragments",
        "B": "The homologous regions are recognized by a restriction enzyme that cuts and ligates them",
        "C": "The shared sequence serves as a primer for PCR amplification of the joined product",
        "D": "The homology encodes a protein that catalyzes the assembly reaction"
      },
      "answer": "A",
      "explanation": "Gibson assembly works by: (1) T5 exonuclease chews back 5' ends to\nexpose single-stranded overhangs, (2) complementary homologous regions\non adjacent fragments anneal, (3) polymerase fills gaps, and (4) ligase\nseals nicks. The shared homology is essential for the annealing step —\nwithout it, fragments cannot find their correct partners. Option B\nconfuses Gibson with restriction/ligation cloning. Option C confuses\nGibson with PCR. Option D is nonsensical.\n"
    },
    {
      "slug": "forbidden-restriction-sites",
      "difficulty": "medium",
      "topic": "Recognizing how a downstream process constrains what sequences are allowed in a design",
      "question": "A gene synthesis order is rejected because the sequence contains a BsaI\nrecognition site (<pre>GGTCTC</pre>). The gene will later be assembled using Golden\nGate cloning, which requires BsaI. Why must the internal site be removed?\n",
      "choices": {
        "A": "If BsaI cuts at the internal site during assembly, the fragment will be split into unintended pieces, ruining the assembly",
        "B": "BsaI sites slow down gene synthesis and increase cost",
        "C": "The GGTCTC sequence encodes a toxic peptide that kills the host cell",
        "D": "Restriction sites cannot appear in coding sequences because they disrupt translation"
      },
      "answer": "A",
      "explanation": "Golden Gate cloning uses BsaI to cut DNA at defined positions for\nassembly. If BsaI also cuts internally within the gene, it generates\nextra fragments that participate incorrectly in the assembly, producing\nthe wrong product. The site must be removed by silent codon changes\nthat preserve the protein sequence. Option B is incorrect — synthesis\ncompanies can make any sequence, though some flag problematic sites.\nOption C is wrong — GGTCTC does not inherently encode anything toxic.\nOption D is wrong — restriction sites in coding regions are normal and\ndo not affect translation.\n"
    },
    {
      "slug": "construction-file-representation",
      "difficulty": "medium",
      "topic": "Understanding how a structured representation captures an experiment as a sequence of operations",
      "question": "A Construction File (CF) contains these steps:\n\n<pre>\npcr   fwd1 rev1 pTemplate product1\ndigest product1 EcoRI 1 frag1\nligate frag1 lig1\ntransform lig1 Mach1 Amp pFinal\n</pre>\n\nWhat does this CF describe?\n",
      "choices": {
        "A": "A cloning experiment that amplifies DNA by PCR, cuts it with a restriction enzyme, ligates it into a circle, and transforms it into cells",
        "B": "A gene expression experiment that transcribes and translates a protein",
        "C": "A sequencing protocol that reads the DNA sequence of pTemplate",
        "D": "A codon optimization workflow that redesigns the coding sequence"
      },
      "answer": "A",
      "explanation": "Each line of a CF is a step in a DNA construction experiment. The PCR\nstep amplifies a region using two oligos and a template. Digest cuts the\nproduct with EcoRI. Ligate joins the ends. Transform introduces the\nligated DNA into Mach1 cells with ampicillin selection. This is a\nstandard cloning workflow. The CF is a domain-specific representation\nof the physical experiment, not a computational pipeline.\n"
    },
    {
      "slug": "pcr-product-prediction",
      "difficulty": "medium",
      "topic": "Tracing the output of a process given its inputs and rules",
      "question": "A PCR reaction uses:\n<pre>\nForward oligo: 5'-AAAA-cccc-3'  (AAAA is 5' tail, cccc anneals to template)\nReverse oligo: 5'-TTTT-gggg-3'  (TTTT is 5' tail, gggg anneals to template)\nTemplate: 5'-...ccccXXXXXXXXcccc...-3' (cccc regions match oligos)\n</pre>\n\nAfter 30 cycles, what is the dominant product?\n",
      "choices": {
        "A": "A double-stranded DNA with AAAA on one end, TTTT on the other, and the template region plus tails in between",
        "B": "Only the original template sequence with no modifications",
        "C": "Single-stranded DNA matching the forward oligo sequence",
        "D": "A product containing only the XXXXXXXX region with no oligo sequences"
      },
      "answer": "A",
      "explanation": "In the first cycle, each primer's 3' end anneals to the template and\npolymerase extends, incorporating the 5' tails. In subsequent cycles,\nthe extended products become templates themselves, so the tails are\nnow part of the template. After ~30 cycles, the dominant product is a\ndouble-stranded DNA bounded by the full oligo sequences including their\n5' tails. This is how PCR adds synthetic sequence to ends of a natural\ntemplate.\n"
    },
    {
      "slug": "fragment-size-limits-strategy",
      "difficulty": "medium",
      "topic": "Understanding how physical limits on component size force a divide-and-assemble strategy",
      "question": "Gene synthesis companies can reliably produce fragments up to ~5,000 bp.\nA designer needs to build a 15,000 bp plasmid. What is the standard\napproach?\n",
      "choices": {
        "A": "Order three ~5 kb fragments with overlapping ends and assemble them using Gibson or similar method",
        "B": "Order one 15 kb fragment, since special rush orders can exceed the limit",
        "C": "Order 15,000 individual oligos and assemble them directly by PCA",
        "D": "Clone the 15 kb sequence from a natural organism using restriction enzymes"
      },
      "answer": "A",
      "explanation": "Current gene synthesis technology is limited to ~3–5 kb per fragment due\nto error accumulation. Longer constructs are built by assembling multiple\nverified fragments using methods like Gibson assembly, which requires\n~20 bp overlaps between adjacent fragments. Option B exceeds the\ntechnological limit. Option C is impractical — PCA from oligos works\nfor ~600 bp, not 15 kb. Option D assumes the sequence exists naturally,\nwhich it likely does not for a synthetic design.\n"
    },
    {
      "slug": "restriction-digest-and-ligation",
      "difficulty": "medium",
      "topic": "Understanding how specific cutting and joining operations transform DNA topology",
      "question": "A linear PCR product has an EcoRI site near each end. After digesting\nwith EcoRI and then ligating, what is the expected product?\n",
      "choices": {
        "A": "A circular DNA formed by ligation of the compatible sticky ends generated by EcoRI at both ends",
        "B": "Two separate fragments that cannot be joined",
        "C": "The same linear DNA, unchanged by the enzymes",
        "D": "A larger DNA formed by concatenation of multiple copies of the fragment"
      },
      "answer": "A",
      "explanation": "EcoRI cuts at <pre>GAATTC</pre> to produce compatible 4-base sticky ends (5'-AATT\noverhangs). When the same enzyme cuts both ends of a linear fragment,\nthe two ends have complementary overhangs that can anneal and be sealed\nby ligase, forming a circle. This is the basis of EIPCR-based cloning.\nOption B is wrong because the ends are compatible. Option C ignores that\ndigestion removes bases to create overhangs. Option D can happen at high\nDNA concentration but the dominant intramolecular product is a circle.\n"
    },
    {
      "slug": "pca-vs-standard-pcr",
      "difficulty": "medium",
      "topic": "Distinguishing how the same core mechanism produces different outcomes with different inputs",
      "question": "Standard PCR uses two primers and a single template to amplify a\nspecific region. Polymerase Chain Assembly (PCA) uses a pool of\noverlapping oligos with no separate template. What does PCA produce?\n",
      "choices": {
        "A": "A gene-length DNA assembled from the overlapping oligos, which serve as both templates and primers for each other",
        "B": "Many copies of the longest oligo in the pool",
        "C": "A random library of all possible combinations of the oligos",
        "D": "Single-stranded DNA because there is no template to copy"
      },
      "answer": "A",
      "explanation": "In PCA, overlapping oligos anneal to each other at their complementary\nregions and are extended by polymerase. Through successive cycles of\ndenaturation, annealing, and extension, progressively longer fragments\nare built. Outer primers then amplify the full-length product. This is\nhow gene-length DNA (~600 bp) can be assembled from short oligos\n(~40–60 bp each). Option B misunderstands the assembly mechanism.\nOption C overstates the randomness. Option D is wrong because the\noligos serve as templates for each other.\n"
    },
    {
      "slug": "oligo-design-constraints",
      "difficulty": "medium",
      "topic": "Understanding how multiple physical constraints simultaneously restrict a design choice",
      "question": "When designing a PCR primer's annealing region, several constraints must\nbe satisfied simultaneously. Which set of constraints is correct?\n",
      "choices": {
        "A": "18–25 bp length, 50–65% GC content, G or C at the 3' end, no long homopolymeric runs",
        "B": "Exactly 20 bp length, any GC content, must start with ATG, no constraints on sequence",
        "C": "50–100 bp length, 30–40% GC content, must end with a stop codon",
        "D": "10–15 bp length, 80% GC content, A or T at both ends"
      },
      "answer": "A",
      "explanation": "Primer annealing regions are typically 18–25 bp to ensure specificity.\nGC content of 50–65% provides appropriate melting temperature. A G or C\nat the 3' end (GC clamp) stabilizes binding at the critical end where\npolymerase initiates. Homopolymeric runs cause mispriming. Option B has\nwrong constraints and confuses primer design with CDS design (ATG is a\nstart codon). Option C describes something far too long with wrong GC\nrange. Option D is too short and too GC-rich.\n"
    },
    {
      "slug": "design-vs-fabrication-feasibility",
      "difficulty": "medium",
      "topic": "Recognizing that a computationally valid design may be physically impossible to build",
      "question": "A codon optimization algorithm produces a 4,000 bp coding sequence.\nThe sequence passes all checks — no forbidden restriction sites, good\nCAI, no hairpins. However, a fabrication engineer flags a problem.\n\nWhich issue could make this sequence difficult to synthesize?\n",
      "choices": {
        "A": "A 30 bp region with 95% GC content that is prone to synthesis errors due to strong secondary structure in the single-stranded intermediates",
        "B": "The sequence uses too many different codons (high diversity)",
        "C": "The sequence does not begin with ATG",
        "D": "The protein it encodes is too large for E. coli to express"
      },
      "answer": "A",
      "explanation": "Gene synthesis involves single-stranded DNA intermediates (oligos) that\ncan form strong secondary structures if they have extreme GC content.\nRegions of very high or very low GC content are notorious synthesis\nfailure points. This is a fabrication constraint that the checker\nmight miss if it only examines the double-stranded design. Option B —\nhigh codon diversity is actually desirable. Option C would be a design\nerror caught by the algorithm. Option D is about expression, not\nsynthesis."
    }
  ],
  "coding_sequence_design_and_optimization": [
    {
      "slug": "many-valid-encodings",
      "difficulty": "medium",
      "topic": "Understanding why a mapping from output to input has many solutions while the reverse does not",
      "question": "The genetic code maps 61 sense codons to 20 amino acids. A protein of\n100 amino acids must be reverse-translated into a DNA coding sequence.\nWhy does this problem have many valid solutions while translation\n(DNA → protein) does not?\n",
      "choices": {
        "A": "Most amino acids are encoded by multiple codons (degeneracy), so each position has several choices; in translation, each codon maps to exactly one amino acid",
        "B": "DNA polymerase can introduce random mutations during replication",
        "C": "The genetic code is ambiguous — some codons encode multiple amino acids",
        "D": "Reverse translation always produces a single unique answer because organisms use preferred codons"
      },
      "answer": "A",
      "explanation": "The genetic code is degenerate but unambiguous: multiple codons can\nencode the same amino acid, but each codon encodes exactly one amino\nacid. When going from protein to DNA, each amino acid position offers\nbetween 1 (Met, Trp) and 6 (Leu, Ser, Arg) codon choices, creating a\ncombinatorial explosion. A 100-amino-acid protein could have roughly\n3^100 to 6^100 valid encodings. Option B is about replication errors,\nnot the design problem. Option C is false — the code is unambiguous.\nOption D incorrectly claims there is one answer.\n"
    },
    {
      "slug": "one-aa-one-codon-limitations",
      "difficulty": "medium",
      "topic": "Recognizing why the simplest solution to a design problem is often insufficient",
      "question": "The 'one amino acid–one codon' strategy assigns the most frequent codon\nfor each amino acid and concatenates them. A designer uses this approach\nfor the peptide <pre>MKKK</pre>. The result is <pre>ATG AAA AAA AAA</pre>.\n\nWhat fabrication problem does this create?\n",
      "choices": {
        "A": "The poly-A run (AAAAAAAAA) is a homopolymeric forbidden sequence that can cause synthesis errors and replication slippage",
        "B": "The sequence has too high GC content for synthesis",
        "C": "Three consecutive lysines are toxic to E. coli",
        "D": "The codon AAA is rare in E. coli and will cause low expression"
      },
      "answer": "A",
      "explanation": "When the same codon is repeated for consecutive identical amino acids,\nit creates homopolymeric runs. AAAAAAAAA (9 A's) exceeds the typical\n8-base threshold for forbidden homopolymeric sequences. These runs cause\nproblems during DNA synthesis (oligo-based assembly) and in vivo\n(polymerase slippage). The fix is to alternate between synonymous codons\n(e.g. AAA and AAG for lysine). Option B is wrong — poly-A is low GC.\nOption C — lysine runs are not inherently toxic. Option D — AAA is\nactually the most common lysine codon in E. coli.\n"
    },
    {
      "slug": "guided-random-codon-selection",
      "difficulty": "medium",
      "topic": "Understanding how weighted random sampling produces solutions biased toward desired properties",
      "question": "The guided random method of codon optimization creates a list of 100\nentries for each amino acid, where each codon appears a number of times\nproportional to its usage frequency. For leucine:\n\n<pre>CTG: 49 entries, TTA: 13, TTG: 13, CTT: 11, CTC: 10, CTA: 4</pre>\n\nA random integer from 0–99 selects a codon. What is true about this\napproach?\n",
      "choices": {
        "A": "Frequently used codons are chosen more often, but rare codons still appear occasionally, producing diverse solutions",
        "B": "CTG is always chosen because it has the most entries",
        "C": "Each codon is chosen with equal probability regardless of the frequency table",
        "D": "The method guarantees that no forbidden sequences will appear in the result"
      },
      "answer": "A",
      "explanation": "The integer-based lookup table implements weighted random selection.\nCTG has a 49% chance of being chosen for each leucine position, but\nTTA has a 13% chance, and even CTA has a 4% chance. Across a full\ngene, this produces sequences that statistically reflect the organism's\ncodon bias while introducing diversity. Option B is wrong — selection\nis probabilistic, not deterministic. Option C ignores the weighting.\nOption D is wrong — forbidden sequences can still arise by chance and\nmust be checked separately.\n"
    },
    {
      "slug": "cai-measures-codon-bias",
      "difficulty": "medium",
      "topic": "Understanding what a summary metric captures about a sequence relative to a reference",
      "question": "The Codon Adaptation Index (CAI) for a gene is calculated as the\ngeometric mean of the relative adaptiveness (w) values for all its\ncodons. A gene with CAI = 0.85 uses codons that are mostly preferred\nin the reference organism. What does a CAI of 0.15 indicate?\n",
      "choices": {
        "A": "The gene predominantly uses rare codons relative to the reference organism's highly expressed genes",
        "B": "The gene has 15% GC content",
        "C": "Only 15% of the gene's codons are valid",
        "D": "The gene encodes a protein that is 15% identical to the reference organism's proteome"
      },
      "answer": "A",
      "explanation": "CAI ranges from 0 to 1 and measures how well a gene's codon usage\nmatches the codon preferences of highly expressed genes in the host.\nHigh CAI means the gene uses preferred codons; low CAI means it uses\nrare codons that may slow translation. CAI is about codon choice, not\nGC content (B), codon validity (C), or protein similarity (D). A\nlow-CAI gene may still produce functional protein but at reduced\nefficiency.\n"
    },
    {
      "slug": "restriction-site-removal-preserves-protein",
      "difficulty": "medium",
      "topic": "Making a constrained change that preserves one property while fixing a violation of another",
      "question": "A coding sequence contains the BsaI site <pre>GGTCTC</pre> starting at position\n120. The overlapping codons at that position are <pre>GGT</pre> (Gly) and <pre>CTC</pre>\n(Leu). To remove the BsaI site without changing the protein, the\ndesigner should:\n",
      "choices": {
        "A": "Change GGT to GGC (still Gly) or CTC to CTG (still Leu), breaking the GGTCTC recognition sequence",
        "B": "Delete the six bases GGTCTC and shift the reading frame",
        "C": "Insert a stop codon before position 120 to prevent the enzyme from reaching the site",
        "D": "Change GGT to AAA (Lys), which will reliably break the restriction site"
      },
      "answer": "A",
      "explanation": "Synonymous codon substitution changes the DNA sequence while preserving\nthe encoded amino acid. Changing GGT→GGC changes the third position of\nthe glycine codon (Gly is encoded by GGN), which breaks the GGTCTC\nrecognition pattern. Similarly, CTC→CTG still encodes leucine but\ndisrupts the site. Option B would destroy the protein by causing a\nframeshift. Option C would truncate the protein. Option D changes the\namino acid from Gly to Lys, altering the protein.\n"
    },
    {
      "slug": "multiple-competing-objectives",
      "difficulty": "medium",
      "topic": "Recognizing that optimization across multiple criteria involves tradeoffs, not a single best answer",
      "question": "A codon optimization tool must simultaneously maximize CAI, avoid\nforbidden sequences (e.g. BsaI sites), minimize secondary structure\nnear the start codon, and avoid homopolymeric runs. Why is there\ngenerally no single \"best\" coding sequence?\n",
      "choices": {
        "A": "Improving one objective (e.g. high CAI) can worsen another (e.g. creating homopolymeric runs), so the solution is a tradeoff",
        "B": "The genetic code is too simple to encode all constraints",
        "C": "There is always exactly one optimal solution but it is too expensive to compute",
        "D": "Codon optimization does not actually affect expression, so all solutions are equivalent"
      },
      "answer": "A",
      "explanation": "The highest-CAI solution uses the most frequent codon for each amino\nacid, but this can create homopolymeric runs (like AAA AAA AAA for\nconsecutive lysines) or accidentally introduce restriction sites.\nFixing those issues requires using less-preferred codons, lowering CAI.\nThis is a multi-objective optimization problem where the designer must\nbalance competing constraints. Option C is wrong — there is no single\noptimum. Option D is contradicted by the 250-fold expression range\nobserved in codon-variant GFP studies.\n"
    },
    {
      "slug": "rscu-vs-cai-distinction",
      "difficulty": "medium",
      "topic": "Distinguishing between a per-element metric and a per-collection summary metric",
      "question": "RSCU (Relative Synonymous Codon Usage) and CAI (Codon Adaptation Index)\nboth relate to codon usage bias. What is the key difference between them?\n",
      "choices": {
        "A": "RSCU describes the usage frequency of a single codon relative to its synonymous codons; CAI summarizes the overall codon adaptation of an entire gene",
        "B": "RSCU applies to RNA while CAI applies to DNA",
        "C": "RSCU is calculated from protein sequences while CAI is calculated from DNA",
        "D": "RSCU and CAI are identical metrics expressed in different units"
      },
      "answer": "A",
      "explanation": "RSCU is a per-codon metric: it tells you how much more (or less)\nfrequently a specific codon is used compared to equal usage of all\nsynonymous codons. A value of 1.0 means average usage; above 1.0 means\npreferred. CAI is a per-gene metric: it computes the geometric mean of\nthe relative adaptiveness values for all codons in a coding sequence,\nyielding a single number between 0 and 1. RSCU describes the reference\nset; CAI scores a specific gene against that reference.\n"
    },
    {
      "slug": "secondary-structure-affects-expression",
      "difficulty": "medium",
      "topic": "Understanding how a local structural property of a molecule affects a global functional outcome",
      "question": "Two coding sequences encode the same protein but differ in codon usage.\nSequence A has strong predicted secondary structure in the first 40\nnucleotides, while Sequence B has weak structure in the same region.\nBased on the Plotkin GFP study, what is the expected difference?\n",
      "choices": {
        "A": "Sequence B will likely have higher protein expression because weak structure near the start codon allows ribosome access",
        "B": "Sequence A will have higher expression because secondary structure stabilizes the mRNA",
        "C": "Both will have identical expression because they encode the same protein",
        "D": "Sequence A will have higher expression because strong structure increases transcription rate"
      },
      "answer": "A",
      "explanation": "The Plotkin study demonstrated that secondary structure in the region\nfrom approximately -4 to +37 relative to the start codon is a major\ndeterminant of expression. Strong structure in this region occludes the\nribosome's path and reduces translation initiation. Weak structure\nallows the ribosome to access the start codon and begin translating\nefficiently. Option B confuses stabilization of mRNA (not relevant at\nthe 5' end in this way). Option C ignores the well-documented codon\neffect. Option D confuses translation with transcription.\n"
    },
    {
      "slug": "codon-context-matters",
      "difficulty": "medium",
      "topic": "Understanding why adjacent elements interact to produce emergent effects not predicted by individual properties",
      "question": "Research shows that the identity of adjacent codons (codon context or\ncodon pairs) affects translation elongation rate beyond what individual\ncodon frequency predicts. A codon context (CC) optimization approach\ngave better expression than individual codon usage (ICU) optimization.\n\nWhat does this imply for algorithm design?\n",
      "choices": {
        "A": "An optimization algorithm should evaluate codons in windows that include neighbors, not just one codon at a time",
        "B": "Only the first codon after ATG matters for expression",
        "C": "Codon optimization is unnecessary because context effects dominate",
        "D": "The algorithm should use the rarest codons to maximize context diversity"
      },
      "answer": "A",
      "explanation": "If adjacent codon pairs affect expression beyond what single-codon\nfrequency predicts, then evaluating each position independently (as in\none-aa-one-codon) misses important interactions. Sliding-window\napproaches that score windows of 2–3 codons together can capture these\neffects. Option B is too narrow — context effects occur throughout the\ngene. Option C is a non-sequitur — both individual and context effects\nmatter. Option D contradicts the goal of using well-adapted codons.\n"
    },
    {
      "slug": "iterative-generation-and-checking",
      "difficulty": "medium",
      "topic": "Understanding a generate-and-test loop as a strategy when constraints cannot all be satisfied analytically",
      "question": "A guided-random codon optimization algorithm works as follows:\n1. For each amino acid, randomly select a codon weighted by frequency\n2. Check the full sequence against all constraints (forbidden sequences,\n   homopolymeric runs, etc.)\n3. If any check fails, go to step 1 and regenerate\n\nWhat is a practical risk of this approach?\n",
      "choices": {
        "A": "For proteins with many consecutive identical amino acids (e.g. MKKKKKKK), the loop may iterate many times before finding a valid sequence",
        "B": "The algorithm will always produce the same sequence regardless of the random seed",
        "C": "The algorithm cannot check for forbidden sequences because the sequence changes each iteration",
        "D": "Guided random selection always produces invalid sequences"
      },
      "answer": "A",
      "explanation": "For peptides with runs of identical amino acids (like poly-lysine), the\nmost frequent codon (AAA) is selected most often, creating\nhomopolymeric runs that fail the forbidden sequence check. The algorithm\nmust then regenerate, but the same bias applies each time. While it will\neventually find a solution (using alternate codons like AAG), it may\nrequire many iterations. In extreme cases, this can appear to loop\nindefinitely. Option B is wrong — different random seeds produce\ndifferent results. Option C is wrong — the check happens on each\ncomplete sequence. Option D overstates the problem."
    }
  ],
  "verification_strategies_and_failure_modes": [
    {
      "slug": "checker-purpose",
      "difficulty": "medium",
      "topic": "Understanding why domain logic is encapsulated in a reusable function rather than duplicated",
      "question": "A ForbiddenSequenceChecker is a function that inputs a DNA sequence and\nreturns True if the sequence is free of forbidden restriction sites.\nThis checker is used both inside the TranscriptDesigner algorithm and\nin the pytest suite that tests TranscriptDesigner.\n\nWhy is the checker written as a separate, shared function?\n",
      "choices": {
        "A": "Both the algorithm and the test need the same domain logic; a shared checker avoids code duplication and ensures consistency",
        "B": "The checker runs faster as a standalone function than as inline code",
        "C": "Python does not allow the same logic to appear in two different files",
        "D": "The checker is needed only for testing and is never used inside the algorithm itself"
      },
      "answer": "A",
      "explanation": "If the algorithm checks for forbidden sequences internally and the test\nalso checks for them independently, both must implement the same logic.\nDuplicating that logic creates a maintenance risk — if one copy is\nupdated but the other is not, they can silently diverge. The checker\npattern centralizes this domain knowledge in one place that both the\nalgorithm and tests can call. This also makes the checker independently\ntestable.\n"
    },
    {
      "slug": "which-checker-for-which-region",
      "difficulty": "medium",
      "topic": "Recognizing that different validation rules apply to different parts of a composite design",
      "question": "A genetic construct has three regions: the RBS (5' UTR), the CDS\n(coding sequence), and the terminator. A developer considers applying\nInternalRBSChecker to the full construct.\n\nWhat is the problem with this approach?\n",
      "choices": {
        "A": "The construct intentionally contains an RBS, so the checker would always report a violation — it should only be applied to the CDS and terminator regions",
        "B": "InternalRBSChecker only works on protein sequences, not DNA",
        "C": "The checker is too slow to run on a full construct",
        "D": "There is no problem; InternalRBSChecker should be applied to all regions"
      },
      "answer": "A",
      "explanation": "The InternalRBSChecker looks for Shine-Dalgarno-like sequences followed\nby a start codon. Every transcript intentionally has an RBS at the\nbeginning, so applying the checker to the full construct (including the\nreal RBS) would always flag it as a violation. The checker should only\nbe applied to regions where an RBS would be unintended — the internal\nCDS and downstream regions. This illustrates that different checkers\nhave different valid scopes.\n"
    },
    {
      "slug": "checker-test-validates-checker",
      "difficulty": "medium",
      "topic": "Understanding that a validation tool itself must be tested to ensure it catches known cases",
      "question": "A test for ForbiddenSequenceChecker includes these assertions:\n\n<python>\nassert checker.run('AAAAGGTCTCAAAAA') == False  # contains BsaI site\nassert checker.run('ACACACACACACAC') == True     # no forbidden sites\nassert raises(ValueError, checker.run, 'BOB')    # invalid input\n</python>\n\nWhat is the purpose of testing the checker itself?\n",
      "choices": {
        "A": "To verify that the checker correctly identifies known forbidden sequences and correctly passes clean sequences before using it to validate designs",
        "B": "To benchmark the speed of the checker function",
        "C": "To test whether the TranscriptDesigner algorithm works correctly",
        "D": "To generate a list of all possible forbidden sequences"
      },
      "answer": "A",
      "explanation": "If the checker has a bug (e.g. it fails to detect GGTCTC, or it\nfalse-positives on clean sequences), then both the algorithm and the\ntest that rely on it would silently produce incorrect results. Testing\nthe checker on known positive cases (sequences that do contain forbidden\nsites), known negative cases (clean sequences), and invalid inputs\n(non-DNA strings) ensures the checker itself is trustworthy before it\nis used to validate designs.\n"
    },
    {
      "slug": "edge-case-reveals-algorithm-weakness",
      "difficulty": "medium",
      "topic": "Identifying inputs that stress a specific weakness in an algorithm's logic",
      "question": "The peptide <pre>MKKKKKKK</pre> is used as an edge case for testing\nTranscriptDesigner. Why is this particular input challenging?\n",
      "choices": {
        "A": "Lysine's most common codon is AAA, so consecutive lysines tend to produce poly-A runs that violate the forbidden homopolymeric sequence constraint",
        "B": "The peptide is too short for the algorithm to process",
        "C": "Lysine cannot be encoded by any codon in E. coli",
        "D": "The sequence has too many methionines, which confuses the start codon detection"
      },
      "answer": "A",
      "explanation": "Lysine is encoded by AAA (most common) and AAG. A naive algorithm that\nalways picks the most common codon produces <pre>ATGAAAAAAAAAAAAAAAAAAAAA</pre> —\na poly-A run that fails the forbidden sequence check for homopolymeric\nruns (typically 8+ consecutive identical bases). This edge case forces\nthe algorithm to use synonymous codon variation (alternating AAA and\nAAG). It reveals whether the algorithm can handle the constraint. The\npeptide has only one Met (the start), not \"too many.\"\n"
    },
    {
      "slug": "inverse-function-validation",
      "difficulty": "medium",
      "topic": "Using a reverse operation to verify that a forward operation produced a correct result",
      "question": "DesignPCRPrimers inputs a template and desired product, and outputs two\noligos. PredictPCRProduct inputs two oligos and a template, and outputs\nthe expected product sequence.\n\nHow can these two functions be used together for validation?\n",
      "choices": {
        "A": "Run DesignPCRPrimers to get oligos, then run PredictPCRProduct with those oligos and the template, and verify the predicted product matches the desired product",
        "B": "Run both functions simultaneously and check that they have the same runtime",
        "C": "Use DesignPCRPrimers to test PredictPCRProduct's error handling",
        "D": "Run PredictPCRProduct first, then use its output as input to DesignPCRPrimers to check for exceptions"
      },
      "answer": "A",
      "explanation": "DesignPCRPrimers and PredictPCRProduct are inverse functions. If the\ndesign function works correctly, feeding its output (the oligos) into\nthe simulation function (the predictor) should reproduce the original\ndesired product. If the predicted product does not match, either the\ndesign or the simulation has a bug. This pattern — design then simulate\n— is a powerful validation strategy that avoids manually computing\nexpected results.\n"
    },
    {
      "slug": "truism-as-property-check",
      "difficulty": "medium",
      "topic": "Using necessarily true properties to catch errors without computing exact expected values",
      "question": "A test for RBSChooser asserts that the output RBS sequence contains\nonly valid DNA characters (A, T, C, G) and is between 6 and 30\nnucleotides long. These assertions are examples of:\n",
      "choices": {
        "A": "Truisms — properties that must be true for any valid output, regardless of the specific input",
        "B": "Validated examples — experimentally confirmed input/output pairs",
        "C": "Edge cases — inputs designed to break the algorithm",
        "D": "Benchmarks — performance measurements of the algorithm"
      },
      "answer": "A",
      "explanation": "Truisms are broad property checks that should hold for any valid output\nof a function. \"Output is valid DNA\" and \"output length is within a\nbiologically plausible range\" are truisms. They do not verify that the\noutput is the *best* or *correct* RBS for the specific input, but they\ncatch gross errors (e.g. returning None, returning RNA characters, or\nreturning an impossibly long sequence). Validated examples check specific\nknown input/output pairs. Edge cases are specific tricky inputs.\n"
    },
    {
      "slug": "validated-example-strongest-evidence",
      "difficulty": "medium",
      "topic": "Understanding why empirical data provides stronger validation than purely computational checks",
      "question": "A researcher tests a gRNA design function using the cadA gene from\nE. coli. The protospacer found in the published pTargetF plasmid\n(experimentally confirmed to edit cadA) is used as the expected output.\n\nWhy is this test stronger than a truism like \"output contains only ATCG\"?\n",
      "choices": {
        "A": "It verifies the function's specific biological logic against a real, experimentally validated result — not just that the output looks plausible",
        "B": "It runs faster than truism-based tests",
        "C": "It tests more edge cases simultaneously",
        "D": "Validated examples are easier to write than truisms"
      },
      "answer": "A",
      "explanation": "A truism catches gross errors but cannot verify whether the function\nfound the *correct* protospacer. A validated example uses a real\nexperimental result — the actual protospacer sequence from a published,\nworking CRISPR system — to verify the function's biological logic. If\nthe function extracts the wrong 20-mer (e.g. off-by-one), the truism\nstill passes (it's valid DNA and the right length) but the validated\nexample fails. Validated examples are the \"best evidence short of\nexperimentally testing designs yourself.\"\n"
    },
    {
      "slug": "benchmarking-on-proteome",
      "difficulty": "medium",
      "topic": "Understanding how testing at scale reveals failure rates that individual tests cannot",
      "question": "A proteome benchmarker runs TranscriptDesigner on all 2,458 E. coli\nproteins and reports:\n- Forbidden sequence violations: 1,924\n- Hairpin violations: 2,326\n- Translation match failures: 130\n\nWhat does this benchmark reveal that individual test cases cannot?\n",
      "choices": {
        "A": "The overall failure rate and which types of violations are most common across the full input space",
        "B": "The exact DNA sequence that should be designed for each protein",
        "C": "Whether the algorithm runs without syntax errors",
        "D": "Which specific codon causes each violation"
      },
      "answer": "A",
      "explanation": "Individual test cases verify behavior on specific inputs, but a proteome\nbenchmark evaluates the algorithm across the entire space of valid\ninputs. It reveals the aggregate failure rate (e.g. 78% of proteins\nhave hairpin issues) and identifies which constraints are hardest to\nsatisfy. This guides algorithm improvement: hairpin violations are most\ncommon, so the algorithm should prioritize secondary structure\navoidance. Individual tests cannot reveal these population-level\nstatistics.\n"
    },
    {
      "slug": "pwm-promoter-checking",
      "difficulty": "medium",
      "topic": "Understanding how a statistical model of sequence features can detect unintended functional sites",
      "question": "InternalPromoterChecker uses a position weight matrix (PWM) to score\nwhether a region of DNA resembles a sigma-70 promoter. The PWM encodes\nthe probability of each base at each position in the -35 and -10 boxes.\n\nWhy is a PWM used instead of an exact sequence match?\n",
      "choices": {
        "A": "Promoters are not a single exact sequence — they are a family of related sequences with position-dependent variation, so a probabilistic model is more sensitive than exact matching",
        "B": "PWMs run faster than exact string matching",
        "C": "Exact matching would find too many false positives",
        "D": "The PWM also detects restriction enzyme sites"
      },
      "answer": "A",
      "explanation": "Sigma-70 promoters are not defined by one exact sequence but by a\nconsensus pattern with variation at each position (e.g. the -10 box is\n<pre>TATAAT</pre> but functional variants exist). A PWM captures this variation by\nscoring how likely a given sequence is to function as a promoter. An\nexact match for TATAAT alone would miss functional promoters with single\nsubstitutions, and a search for partial matches would produce too many\nfalse positives. The PWM balances sensitivity and specificity.\n"
    },
    {
      "slug": "passing-checks-vs-being-correct",
      "difficulty": "medium",
      "topic": "Understanding the difference between satisfying known constraints and achieving the true design goal",
      "question": "A TranscriptDesigner output passes all checkers: ForbiddenSequenceChecker,\nHairpinChecker, CodonChecker, and InternalPromoterChecker all return\nTrue. Does this guarantee the design will express well in E. coli?\n",
      "choices": {
        "A": "No — the checkers verify known constraints are satisfied, but real expression depends on factors beyond what the checkers model (e.g. mRNA stability, tRNA interactions, protein folding)",
        "B": "Yes — if all checkers pass, the design is guaranteed to work experimentally",
        "C": "No — because the checkers have false positive rates above 50%",
        "D": "Yes — the checkers collectively model all aspects of gene expression"
      },
      "answer": "A",
      "explanation": "Checkers enforce a defined set of domain-specific constraints (no\nforbidden sites, low hairpin count, acceptable CAI, no internal\npromoters). However, gene expression depends on many additional factors:\nmRNA stability and RNase E cleavage, interactions with other cellular\nRNAs, codon context effects, protein folding during translation, and\nresource competition. No finite set of checkers can model all biological\ncomplexity. Passing the checks means the design is free of known\nproblems, not that it is guaranteed to work. Experimental validation\nremains necessary."
    }
  ]
}
