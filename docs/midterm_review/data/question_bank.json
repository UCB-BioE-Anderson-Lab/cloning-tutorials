{
  "core_types_and_containers": [
    {
      "slug": "name-binding-shared-list",
      "difficulty": "medium",
      "topic": "Understanding that variable assignment creates shared references, not independent copies",
      "question": "A construct's sequence is stored as a list of parts. A colleague saves\na reference so they can modify it:\n\n<python>\nparts = ['J23119', 'B0034', 'amilGFP']\nmy_copy = parts\nmy_copy.append('B0015')\n</python>\n\nHow many elements does parts contain after this code runs?\n",
      "choices": {
        "A": "3 — my_copy is a separate list",
        "B": "4 — both names refer to the same list",
        "C": "4 — append always modifies all lists in the program",
        "D": "TypeError — you cannot append to a referenced list"
      },
      "answer": "B",
      "explanation": "Assignment (<python>my_copy = parts</python>) binds a second name to the\nsame list object. It does not create a copy. Appending through my_copy\nmutates that shared list, so parts also has 4 elements. This matters in\ngenetic design code because a construct parts list may be passed to\nmultiple functions, and a mutation through one reference is visible to all\nother references to that same list.\n"
    },
    {
      "slug": "string-substring-search",
      "difficulty": "medium",
      "topic": "Using string operations to answer questions about sequence content",
      "question": "A codon optimization function must verify that a designed CDS does not\ncontain the BsaI recognition site <pre>GGTCTC</pre>. Given:\n\n<python>\ncds = 'ATGAACGGTCTCAAATAA'\n</python>\n\nWhich of the following correctly detects the forbidden site?\n",
      "choices": {
        "A": "'GGTCTC' in cds",
        "B": "cds['GGTCTC']",
        "C": "cds.count('GGTCTC') > 1",
        "D": "cds == 'GGTCTC'"
      },
      "answer": "A",
      "explanation": "The <python>in</python> operator checks whether the left string appears as\na contiguous substring anywhere in the right string. Here <pre>GGTCTC</pre>\nappears once inside the CDS, so the expression returns True. Option B\ntreats the string like a dict lookup (invalid). Option C only flags the\nsite if it appears more than once, which misses a single occurrence.\nOption D checks whether the entire CDS equals the site. Biologically, even\none forbidden restriction site can break a fabrication plan.\n"
    },
    {
      "slug": "dict-as-lookup-table",
      "difficulty": "medium",
      "topic": "Forward vs. reverse lookup in a dict and what the key-value direction implies",
      "question": "The genetic code is stored as a dict mapping codons to amino acids:\n\n<python>\ngenetic_code = {'ATG': 'M', 'TTT': 'F', 'TTC': 'F', 'TAA': '*', ...}\n</python>\n\nA student wants to reverse-translate a protein: given an amino acid,\nfind all codons that encode it. They write:\n\n<python>\ngenetic_code['F']\n</python>\n\nWhat happens?\n",
      "choices": {
        "A": "Returns ['TTT', 'TTC']",
        "B": "Returns 'TTT'",
        "C": "KeyError — 'F' is a value in this dict, not a key",
        "D": "Returns 'F'"
      },
      "answer": "C",
      "explanation": "Dict lookup is by key. In this dict, the keys are codons (<pre>ATG</pre>,\n<pre>TTT</pre>, etc.), not amino acids. <pre>F</pre> is a value, so using\n<python>genetic_code['F']</python> raises a KeyError. To find codons for\nan amino acid, you must iterate over the dict's items and collect the\ncodons whose value matches that amino acid. This reflects a core design\nchoice: the dict is organized for translation (codon → amino acid), not\nreverse translation.\n"
    },
    {
      "slug": "none-guarding-operations",
      "difficulty": "medium",
      "topic": "Handling absent or optional data and ensuring operations are valid before applying them",
      "question": "An RBSChooser function returns an RBSOption object when it finds a\nsuitable ribosome binding site, or None when no candidate passes the\nfilters. A caller writes:\n\n<python>\nresult = rbs_chooser.run(cds)\nutr = result.utr\n</python>\n\nIf the chooser found no valid RBS for this CDS, what happens?\n",
      "choices": {
        "A": "utr is set to None",
        "B": "utr is set to an empty string",
        "C": "AttributeError — None has no attribute 'utr'",
        "D": "The function silently returns a default RBS"
      },
      "answer": "C",
      "explanation": "If the chooser returns None, then <python>result</python> refers to the\nabsence of a result, not an object with fields. Accessing\n<python>result.utr</python> therefore raises an AttributeError. The caller\nmust check whether <python>result is None</python> before accessing its\nattributes. This is a general pattern whenever a function may fail to\nproduce a usable object.\n"
    },
    {
      "slug": "modeling-for-domain-inference",
      "difficulty": "medium",
      "topic": "Modeling a biological object as a data structure and making domain inferences from it",
      "question": "A strain and a plasmid are modeled as:\n\n<python>\nstrain = {'name': 'Mach1', 'resistances': {'AmpR', 'KanR'}}\nplasmid = {'name': 'pUC19', 'marker': 'AmpR'}\n</python>\n\nYou want to check whether the strain already carries the plasmid's\nresistance marker (which would make antibiotic selection unreliable).\nWhich expression performs this check?\n",
      "choices": {
        "A": "plasmid['marker'] in strain['resistances']",
        "B": "strain['resistances'] == plasmid['marker']",
        "C": "plasmid['marker'] in strain['name']",
        "D": "strain['resistances'].append(plasmid['marker'])"
      },
      "answer": "A",
      "explanation": "<python>strain['resistances']</python> is a set, and the\n<python>in</python> operator checks membership in that set. Here\n<pre>AmpR</pre> is already present, so the strain is already ampicillin\nresistant and plating on ampicillin would not distinguish transformants\nfrom background. Option B compares a set to a string. Option C checks for a\nsubstring in the strain name, which is biologically irrelevant. Option D\ncalls <python>.append()</python> on a set; sets use\n<python>.add()</python>.\n"
    },
    {
      "slug": "boolean-validation-logic",
      "difficulty": "medium",
      "topic": "Using boolean expressions to enforce domain constraints on computed values",
      "question": "An oligo design function checks whether the Tm and length of a primer\nare within acceptable bounds:\n\n<python>\ntm = 58.5\nlength = 22\nok = tm >= 55 and tm <= 65 and length >= 18 and length <= 30\n</python>\n\nA second primer has tm = 72.0 and length = 40. What is the value of\nok for each primer?\n",
      "choices": {
        "A": "True for the first, True for the second",
        "B": "True for the first, False for the second",
        "C": "False for both — all four conditions must use 'or'",
        "D": "True for both — 'and' only requires one condition to be True"
      },
      "answer": "B",
      "explanation": "For the first primer, all four conditions are true, so ok is True. For the\nsecond primer, <python>tm <= 65</python> is false and\n<python>length <= 30</python> is false, so the full expression evaluates to\nFalse. The <python>and</python> operator requires every condition to be\ntrue. Biologically, a primer must satisfy multiple constraints at the same\ntime; passing one constraint does not rescue failure on another.\n"
    },
    {
      "slug": "container-choice-for-data",
      "difficulty": "medium",
      "topic": "Selecting a container type based on the properties of the data it must hold",
      "question": "You are designing a data structure to represent a genetic construct.\nIt has an ordered series of CDS names that may repeat (for example, two\ncopies of the same gene in an operon), and a collection of restriction\nenzyme sites that must be absent from the final sequence (duplicates do\nnot matter, and order is irrelevant).\n\nWhich pair of container types best fits these two needs?\n",
      "choices": {
        "A": "list for the CDS names, set for the forbidden sites",
        "B": "set for the CDS names, list for the forbidden sites",
        "C": "dict for the CDS names, set for the forbidden sites",
        "D": "list for both"
      },
      "answer": "A",
      "explanation": "The CDS names are ordered and may contain duplicates, so a list is the\nright fit. The forbidden sites are an unordered collection where\nmembership is what matters, so a set is the natural choice. A set also\nenforces uniqueness automatically. Option B would lose gene order and\nduplicate copies, which changes the represented operon structure. Option C\ndoes not provide a natural key for the CDS sequence in this prompt. Option\nD can work, but it forces you to manage uniqueness manually for forbidden\nsites.\n"
    },
    {
      "slug": "tuple-immutability-consequence",
      "difficulty": "medium",
      "topic": "Immutable containers as fixed records and the consequences of immutability",
      "question": "Proteomics data is loaded as a list of tuples, which are immutable:\n\n<python>\ndata = [('b0002', 498), ('b0003', 181), ('b0004', 889)]\n</python>\n\nYou want to correct an error in the abundance of b0003. You write:\n\n<python>\ndata[1][1] = 200\n</python>\n\nWhat happens?\n",
      "choices": {
        "A": "The abundance of b0003 is updated to 200",
        "B": "TypeError — tuples do not support item assignment",
        "C": "IndexError — tuples can only be accessed at index 0",
        "D": "The entire tuple is replaced with 200"
      },
      "answer": "B",
      "explanation": "<python>data[1]</python> retrieves the tuple <python>('b0003', 181)</python>,\nbut tuples are immutable, so their elements cannot be changed in place.\nTo correct the value, you would replace the entire tuple, for example:\n<python>data[1] = ('b0003', 200)</python>. Treating loaded records as tuples\ncan be useful because it prevents accidental in-place edits to the\noriginal measurements.\n"
    },
    {
      "slug": "restructuring-for-access-pattern",
      "difficulty": "medium",
      "topic": "Choosing how to organize data into containers based on what questions you need to answer",
      "question": "You have a list of (gene_id, abundance) tuples from a proteomics\nexperiment:\n\n<python>\ndata = [('b0002', 498), ('b0003', 181), ('b0004', 889), ...]\n</python>\n\nYou need to repeatedly look up abundances by gene ID. You convert the\ndata to:\n\n<python>\nby_gene = {gid: ab for gid, ab in data}\n</python>\n\nA colleague instead keeps the original list and uses:\n\n<python>\n[ab for gid, ab in data if gid == 'b0004'][0]\n</python>\n\nBoth return 889 for <pre>b0004</pre>. Why is the dict preferable?\n",
      "choices": {
        "A": "The dict finds the value directly by key; the list must scan entries",
        "B": "The dict uses less memory because it discards the gene IDs",
        "C": "The list version returns a different data type",
        "D": "There is no meaningful difference — both are equivalent"
      },
      "answer": "A",
      "explanation": "A dict is organized for key-based lookup, so asking for an abundance by\ngene ID matches the data structure directly. The list comprehension must\nscan through records and test each gene ID until it finds a match. When\nrepeated identifier-based lookups are the dominant operation, converting a\nlist of records into a dict keyed by identifier is the right move.\n"
    },
    {
      "slug": "filtering-structured-records",
      "difficulty": "medium",
      "topic": "Filtering and projecting fields from a collection of structured records",
      "question": "RBS candidates are stored as a list of dicts:\n\n<python>\noptions = [\n    {'source': 'rpsA', 'utr': 'AAAGAGG...', 'hairpins': 0},\n    {'source': 'cspA', 'utr': 'AAGAAGG...', 'hairpins': 3},\n    {'source': 'ompA', 'utr': 'AAGGAG...', 'hairpins': 1},\n]\n</python>\n\nYou want the source gene names of candidates with no predicted\nhairpins. Which expression produces them?\n",
      "choices": {
        "A": "[opt['source'] for opt in options if opt['hairpins'] == 0]",
        "B": "options['hairpins' == 0]",
        "C": "[opt for opt in options if opt['hairpins'] == 0]",
        "D": "options.filter('hairpins', 0)"
      },
      "answer": "A",
      "explanation": "The list comprehension iterates over <python>options</python>, keeps only\nentries where <python>opt['hairpins'] == 0</python>, and projects the\n<python>'source'</python> field from each matching record. The result is\n<python>['rpsA']</python>. Option B attempts to index a list with a boolean\nexpression. Option C returns the full matching dict records rather than the\nsource names. Option D invents a <python>.filter()</python> method that\nPython lists do not have. This filtering-plus-projection pattern is common\nwhen selecting RBS candidates, querying parts registries, or screening\nexperimental records."
    }
  ],
  "control_flow_and_iteration": [
    {
      "slug": "tracing-a-loop-over-sequence",
      "difficulty": "medium",
      "topic": "Tracing a for loop step-by-step to predict what it builds from sequential data",
      "question": "A function translates a DNA coding sequence one codon at a time:\n\n<python>\ngenetic_code = {'ATG': 'M', 'AAA': 'K', 'GGT': 'G', 'TAA': '*'}\ncds = 'ATGAAAGGT'\nprotein = ''\nfor i in range(0, len(cds), 3):\n    codon = cds[i:i+3]\n    protein += genetic_code[codon]\n</python>\n\nWhat is the value of protein after the loop finishes?\n",
      "choices": {
        "A": "MKG",
        "B": "ATGAAAGGT",
        "C": "M",
        "D": "KeyError is raised"
      },
      "answer": "A",
      "explanation": "The loop advances through the CDS in steps of 3. When <python>i = 0</python>,\nthe codon is <pre>ATG</pre> and <pre>M</pre> is appended. When\n<python>i = 3</python>, the codon is <pre>AAA</pre> and <pre>K</pre> is\nappended. When <python>i = 6</python>, the codon is <pre>GGT</pre> and\n<pre>G</pre> is appended. The final protein string is <pre>MKG</pre>.\nOption B confuses the DNA sequence with the translated protein. Option C\nwould be correct only if the loop ran once. Option D would occur only if a\ncodon were missing from the lookup table.\n"
    },
    {
      "slug": "if-elif-else-classification",
      "difficulty": "medium",
      "topic": "Using branching logic to classify items into categories based on multiple criteria",
      "question": "A function classifies genes by their proteomics abundance:\n\n<python>\ndef classify(abundance):\n    if abundance > 1000:\n        return 'high'\n    elif abundance > 100:\n        return 'medium'\n    elif abundance > 0:\n        return 'low'\n    else:\n        return 'not detected'\n</python>\n\nWhat does <python>classify(100)</python> return?\n",
      "choices": {
        "A": "high",
        "B": "medium",
        "C": "low",
        "D": "not detected"
      },
      "answer": "C",
      "explanation": "The conditions are checked in order. <python>100 > 1000</python> is False.\n<python>100 > 100</python> is also False because the comparison is strict\n(<python>></python>, not <python>>=</python>). The next test,\n<python>100 > 0</python>, is True, so the function returns <pre>low</pre>.\nThe <python>elif</python> chain stops at the first matching condition, so\nboundary behavior depends on both the operators and the order of the tests.\n"
    },
    {
      "slug": "early-exit-with-break",
      "difficulty": "medium",
      "topic": "Using break to stop iteration once a condition is met, and understanding what value is retained",
      "question": "A function finds the position of the first <pre>GG</pre> dinucleotide in a\nsequence, which could indicate a PAM site:\n\n<python>\nseq = 'ATCAGATGGCCA'\nposition = -1\nfor i in range(len(seq) - 1):\n    if seq[i:i+2] == 'GG':\n        position = i\n        break\n</python>\n\nWhat is the value of position after the loop finishes?\n",
      "choices": {
        "A": 7,
        "B": 8,
        "C": -1,
        "D": 3
      },
      "answer": "A",
      "explanation": "The loop scans left to right. At <python>i = 7</python>, the slice\n<python>seq[7:9]</python> is <pre>GG</pre>, so <python>position</python> is\nset to 7 and <python>break</python> exits the loop immediately. The\nsentinel value <python>-1</python> would remain only if no match were found.\nThis scan-until-first-hit pattern is common in motif detection.\n"
    },
    {
      "slug": "continue-to-skip-invalid",
      "difficulty": "medium",
      "topic": "Using continue to skip entries that fail a validity check while processing the rest",
      "question": "A function collects abundances for genes that have proteomics data,\nskipping entries marked as missing:\n\n<python>\ndata = [('b0002', 498), ('b0003', None), ('b0004', 889), ('b0005', None)]\nvalid = []\nfor gene_id, abundance in data:\n    if abundance is None:\n        continue\n    valid.append(abundance)\n</python>\n\nWhat is the value of valid?\n",
      "choices": {
        "A": "[498, 889]",
        "B": "[498, None, 889, None]",
        "C": "[('b0002', 498), ('b0004', 889)]",
        "D": "[] — continue skips all remaining iterations"
      },
      "answer": "A",
      "explanation": "When <python>abundance is None</python>, <python>continue</python> skips the\nrest of the current loop body and moves to the next tuple. It does not end\nthe loop. The two non-missing abundances (498 and 889) are appended, so\n<python>valid</python> becomes <python>[498, 889]</python>. Option D is a\ncommon confusion between <python>continue</python> and\n<python>break</python>.\n"
    },
    {
      "slug": "iterating-over-dict-items",
      "difficulty": "medium",
      "topic": "Iterating over key-value pairs in a dict to accumulate or transform structured data",
      "question": "A codon frequency table stores how often each proline codon appears in\nhighly expressed <i>E. coli</i> genes. You want to find the most frequent\ncodon:\n\n<python>\npro_codons = {'CCT': 27340, 'CCC': 19666, 'CCA': 31534, 'CCG': 76644}\nbest_codon = None\nbest_count = 0\nfor codon, count in pro_codons.items():\n    if count > best_count:\n        best_codon = codon\n        best_count = count\n</python>\n\nWhat is the value of best_codon after the loop finishes?\n",
      "choices": {
        "A": "CCG",
        "B": "CCT",
        "C": "CCA",
        "D": "None — the loop never updates best_codon"
      },
      "answer": "A",
      "explanation": "The loop compares each count to the current best. <pre>CCT</pre> beats 0,\nthen <pre>CCC</pre> does not beat 27340, <pre>CCA</pre> beats 27340, and\nfinally <pre>CCG</pre> (76644) beats 31534. The final stored winner is\n<pre>CCG</pre>. This is the standard argmax pattern over\n<python>dict.items()</python>.\n"
    },
    {
      "slug": "nested-loop-combinatorics",
      "difficulty": "medium",
      "topic": "Using nested loops to enumerate combinations and understanding how iteration count scales",
      "question": "A reverse translation function enumerates all possible two-codon\nsequences for the dipeptide Met-Lys:\n\n<python>\nmet_codons = ['ATG']\nlys_codons = ['AAA', 'AAG']\ncombos = []\nfor m in met_codons:\n    for k in lys_codons:\n        combos.append(m + k)\n</python>\n\nHow many elements are in combos, and what would happen if Lys had 6\nsynonymous codons instead of 2?\n",
      "choices": {
        "A": "2 elements now; 6 if Lys had 6 codons",
        "B": "2 elements now; 12 if Lys had 6 codons",
        "C": "3 elements now; 7 if Lys had 6 codons",
        "D": "2 elements now; 6^2 = 36 if Lys had 6 codons"
      },
      "answer": "A",
      "explanation": "Nested loops generate the product of the loop counts. Here there is 1 Met\ncodon and 2 Lys codons, so the total is <python>1 × 2 = 2</python>.\nIf Lys had 6 codons, the total would be <python>1 × 6 = 6</python>.\nThis multiplicative growth is why brute-force reverse translation becomes\ninfeasible for longer proteins.\n"
    },
    {
      "slug": "while-loop-convergence",
      "difficulty": "medium",
      "topic": "Using a while loop that repeats until a condition is satisfied, and reasoning about termination",
      "question": "A guided-random codon optimizer generates candidate CDS sequences\nuntil one passes a forbidden-sequence check:\n\n<python>\nimport random\nrandom.seed(42)\nattempts = 0\npassed = False\nwhile not passed:\n    candidate = generate_random_cds(protein)\n    passed = not has_forbidden_sites(candidate)\n    attempts += 1\n</python>\n\nWhich of the following is true about this loop?\n",
      "choices": {
        "A": "It could run forever if no valid CDS exists for this protein",
        "B": "It always terminates after exactly one iteration",
        "C": "It terminates after a fixed number of iterations regardless of input",
        "D": "Setting the seed guarantees it runs exactly once"
      },
      "answer": "A",
      "explanation": "The loop repeats while <python>passed</python> is False. If no candidate\nCDS can satisfy the constraints, then <python>passed</python> never becomes\nTrue and the loop does not terminate. Setting the random seed makes the\nsequence of random choices reproducible, but it does not guarantee a valid\ncandidate exists or appears on the first try. A practical implementation\nshould include a maximum-attempt limit.\n"
    },
    {
      "slug": "loop-accumulator-pattern",
      "difficulty": "medium",
      "topic": "Building up a result incrementally inside a loop and understanding the final accumulated value",
      "question": "A function builds the reverse complement of a DNA sequence:\n\n<python>\ncomplement = {'A': 'T', 'T': 'A', 'C': 'G', 'G': 'C'}\ndna = 'ATCG'\nresult = ''\nfor base in dna:\n    result = complement[base] + result\n</python>\n\nWhat is the value of result after the loop finishes?\n",
      "choices": {
        "A": "CGAT",
        "B": "TAGC",
        "C": "GCTA",
        "D": "ATCG"
      },
      "answer": "A",
      "explanation": "Each iteration looks up the complement of the current base and prepends it\nto the existing string. Starting from an empty string, the sequence of\nvalues is: <pre></pre> → <pre>T</pre> → <pre>AT</pre> → <pre>GAT</pre> →\n<pre>CGAT</pre>. Prepending causes reversal while the lookup provides the\ncomplement, so the final result is the reverse complement.\n"
    },
    {
      "slug": "conditional-guard-before-operation",
      "difficulty": "medium",
      "topic": "Using an if-check inside a loop to guard against invalid operations on certain elements",
      "question": "A function processes a mixed-case DNA sequence, skipping any character\nthat is not a valid base:\n\n<python>\nseq = 'ATCnGNtt'\ncleaned = ''\nfor ch in seq.upper():\n    if ch in 'ATCG':\n        cleaned += ch\n</python>\n\nWhat is the value of cleaned?\n",
      "choices": {
        "A": "ATCGTT",
        "B": "ATCnGNtt",
        "C": "ATCG",
        "D": "ValueError is raised on 'n'"
      },
      "answer": "A",
      "explanation": "First, <python>seq.upper()</python> becomes <pre>ATCNGNTT</pre>. The loop\nappends only characters that are in <pre>ATCG</pre>. The letters\n<pre>A</pre>, <pre>T</pre>, <pre>C</pre>, <pre>G</pre>, <pre>T</pre>, and\n<pre>T</pre> are kept, while both <pre>N</pre> characters are skipped. The\nresult is <pre>ATCGTT</pre>. The guard prevents invalid characters from\nbeing processed without raising an error.\n"
    },
    {
      "slug": "iteration-order-matters",
      "difficulty": "medium",
      "topic": "Understanding that the order of iteration affects the result when operations are position-dependent",
      "question": "Two functions both scan a sequence for all <pre>GG</pre> dinucleotides, but\none scans left to right and the other scans right to left:\n\n<python>\nseq = 'GGGAT'\n\n# Left to right\nhits_lr = []\nfor i in range(len(seq) - 1):\n    if seq[i:i+2] == 'GG':\n        hits_lr.append(i)\n\n# Right to left\nhits_rl = []\nfor i in range(len(seq) - 2, -1, -1):\n    if seq[i:i+2] == 'GG':\n        hits_rl.append(i)\n</python>\n\nWhat are hits_lr and hits_rl after both loops finish?\n",
      "choices": {
        "A": "[0, 1] and [1, 0] — same positions, different order",
        "B": "Both are [0, 1] — iteration order does not affect which positions match",
        "C": "hits_lr is [0] and hits_rl is [1] — each finds only one",
        "D": "hits_lr is [0, 1] and hits_rl is [0, 1] — same list"
      },
      "answer": "A",
      "explanation": "The sequence <pre>GGGAT</pre> contains overlapping <pre>GG</pre> matches at\npositions 0 and 1. Both loops test the same match condition, so both find\nthe same positions. However, the left-to-right loop appends in the order\n<python>[0, 1]</python>, while the right-to-left loop appends in the order\n<python>[1, 0]</python>. The set of positions is the same, but the output\nlist order depends on iteration order."
    }
  ],
  "functions_parameters_and_scope": [
    {
      "slug": "return-vs-print-in-design",
      "difficulty": "medium",
      "topic": "Understanding that functions communicate results through return values, not side effects",
      "question": "A student writes a function to translate a CDS into a protein:\n\n<python>\ndef translate(cds, genetic_code):\n    protein = ''\n    for i in range(0, len(cds), 3):\n        codon = cds[i:i+3]\n        protein += genetic_code[codon]\n    print(protein)\n\nresult = translate('ATGAAATAA', genetic_code)\n</python>\n\nThey then try to check whether the protein starts with methionine:\n\n<python>\nresult.startswith('M')\n</python>\n\nWhat happens?\n",
      "choices": {
        "A": "Returns True — the protein starts with 'M'",
        "B": "AttributeError — result is None because the function prints but does not return",
        "C": "Returns False — print converts the protein to a different format",
        "D": "NameError — protein is not accessible outside the function"
      },
      "answer": "B",
      "explanation": "The function uses <python>print()</python> instead of <python>return</python>,\nso it displays the protein but returns <python>None</python> by default.\nCalling <python>.startswith()</python> on <python>None</python> raises an\nAttributeError. Option A would be correct if the function returned the\nprotein string. Option D states a true scoping fact (<python>protein</python>\nis local), but that is not the immediate error in the code shown.\n"
    },
    {
      "slug": "local-scope-isolation",
      "difficulty": "medium",
      "topic": "Recognizing that local variables inside a function are invisible to the caller",
      "question": "A function computes the GC content of a DNA sequence:\n\n<python>\ndef gc_content(seq):\n    gc_count = 0\n    for base in seq:\n        if base in 'GC':\n            gc_count += 1\n    fraction = gc_count / len(seq)\n    return fraction\n\nresult = gc_content('ATGCGC')\nprint(gc_count)\n</python>\n\nWhat happens when <python>print(gc_count)</python> executes?\n",
      "choices": {
        "A": "Prints 4 — gc_count was computed inside the function",
        "B": "Prints 0 — gc_count is reset after the function returns",
        "C": "NameError — gc_count is local to gc_content and does not exist in the caller's scope",
        "D": "Prints 0.667 — gc_count holds the fraction, not the count"
      },
      "answer": "C",
      "explanation": "Variables created inside a function are local to that function unless they\nare explicitly returned or otherwise exposed. <python>gc_count</python>\nexists only inside <python>gc_content()</python>, so the caller cannot read\nit directly. The function returns the fraction (stored in\n<python>result</python>), but <python>gc_count</python> itself is out of\nscope in the caller.\n"
    },
    {
      "slug": "default-argument-override",
      "difficulty": "medium",
      "topic": "Using default arguments to provide sensible fallbacks that callers can override",
      "question": "A CRISPR guide RNA design function has a default PAM:\n\n<python>\ndef find_targets(seq, pam='NGG'):\n    targets = []\n    for i in range(len(seq) - len(pam)):\n        if matches_pam(seq[i:i+len(pam)], pam):\n            targets.append(i)\n    return targets\n\na = find_targets(genome_seq)\nb = find_targets(genome_seq, 'NGG')\nc = find_targets(genome_seq, 'NNGRRT')\n</python>\n\nWhich calls use <pre>NGG</pre> and which use <pre>NNGRRT</pre>?\n",
      "choices": {
        "A": "a and b use 'NGG'; c uses 'NNGRRT'",
        "B": "Only b uses 'NGG'; a uses None because no argument was provided",
        "C": "All three use 'NGG' — the default cannot be overridden",
        "D": "a uses 'NGG'; b and c both raise errors for passing a second argument"
      },
      "answer": "A",
      "explanation": "In call <python>a</python>, no PAM is provided, so the default\n<pre>NGG</pre> is used. Call <python>b</python> passes <pre>NGG</pre>\nexplicitly, so it has the same effect. Call <python>c</python> passes\n<pre>NNGRRT</pre>, which overrides the default. Default arguments provide a\nconvenient common case while still allowing callers to supply alternatives.\n"
    },
    {
      "slug": "pure-function-no-side-effects",
      "difficulty": "medium",
      "topic": "Distinguishing pure functions from those with side effects and understanding why purity aids testing",
      "question": "Two implementations of reverse_complement are proposed:\n\n<python>\n# Version A\ncomplement_table = {}\ndef reverse_complement_a(seq):\n    complement_table['last_input'] = seq\n    comp = seq.translate(str.maketrans('ATCG', 'TAGC'))\n    return comp[::-1]\n\n# Version B\ndef reverse_complement_b(seq):\n    comp = seq.translate(str.maketrans('ATCG', 'TAGC'))\n    return comp[::-1]\n</python>\n\nBoth return the correct reverse complement. Why is Version B preferred\nfor use in a design pipeline?\n",
      "choices": {
        "A": "Version B is a pure function — same input always gives the same output with no side effects",
        "B": "Version A is slower because dicts are slow",
        "C": "Version B handles lowercase input and Version A does not",
        "D": "Version A returns a different result each time it is called"
      },
      "answer": "A",
      "explanation": "Version A mutates the external dict <python>complement_table</python> on\nevery call, which is a side effect. Version B depends only on its input and\nproduces only a return value. That makes Version B easier to test, reason\nabout, and safely compose with other functions. Both versions return the\nsame reverse complement for the same input, but only Version B avoids hidden\nstate changes.\n"
    },
    {
      "slug": "function-as-reusable-unit",
      "difficulty": "medium",
      "topic": "Recognizing when repeated logic should be extracted into a function and how arguments generalize it",
      "question": "A student writes code to check for forbidden restriction sites in a\ndesigned gene:\n\n<python>\nhas_ecori = 'GAATTC' in cds\nhas_bsai = 'GGTCTC' in cds\nhas_bsai_rc = 'GAGACC' in cds\nhas_ecori_rc = 'GAATTC' in cds\n</python>\n\nThey realize the pattern repeats. Which refactoring best captures\nthe shared logic?\n",
      "choices": {
        "A": "<python>\ndef has_site(seq, site):\n    rc = reverse_complement(site)\n    return site in seq or rc in seq\n</python>\n",
        "B": "<python>\ndef has_site(seq):\n    return 'GAATTC' in seq or 'GGTCTC' in seq\n</python>\n",
        "C": "<python>\ndef has_site(site):\n    return site in cds\n</python>\n",
        "D": "<python>\ndef has_site():\n    return True\n</python>\n"
      },
      "answer": "A",
      "explanation": "Option A parameterizes both things that vary: the sequence being checked\nand the restriction site of interest. It also handles the reverse\ncomplement, which is part of the repeated logic. Option B hardcodes\nspecific sites, so it is not reusable. Option C relies on\n<python>cds</python> from outer scope instead of taking the sequence as an\nargument, making the function less reusable and harder to test. Option D\ndoes not implement the required logic.\n"
    },
    {
      "slug": "initiate-run-lifecycle",
      "difficulty": "medium",
      "topic": "Understanding the two-phase pattern of configuring an algorithm object then executing it",
      "question": "The RBSChooser class uses an initiate/run pattern:\n\n<python>\nchooser = RBSChooser()\nchooser.initiate()       # loads proteomics data and builds lookup tables\nresult = chooser.run(cds)  # designs an RBS for the given CDS\n</python>\n\nA student tries to skip initiation:\n\n<python>\nchooser2 = RBSChooser()\nresult2 = chooser2.run(cds)\n</python>\n\nWhat is the most likely outcome?\n",
      "choices": {
        "A": "It works — initiate is optional and run loads data on demand",
        "B": "AttributeError or KeyError — run depends on data structures that initiate creates",
        "C": "result2 is None — run detects missing initialization and returns nothing",
        "D": "TypeError — run cannot be called on an uninitialized object"
      },
      "answer": "B",
      "explanation": "In this pattern, <python>initiate()</python> performs one-time setup and\ncreates internal data structures that <python>run()</python> expects to use.\nIf setup is skipped, <python>run()</python> is likely to access missing\nattributes or missing keys and fail with an AttributeError or KeyError.\nThe key idea is that the caller must honor the object's lifecycle contract:\ninitialize first, then run queries.\n"
    },
    {
      "slug": "mutable-default-argument-trap",
      "difficulty": "medium",
      "topic": "Understanding why mutable default arguments can cause unexpected state sharing between calls",
      "question": "A function collects restriction sites to avoid during gene design:\n\n<python>\ndef add_forbidden_site(site, sites=[]):\n    sites.append(site)\n    return sites\n\nresult1 = add_forbidden_site('GAATTC')\nresult2 = add_forbidden_site('GGTCTC')\n</python>\n\nWhat is the value of result2?\n",
      "choices": {
        "A": "['GGTCTC'] — each call starts with a fresh empty list",
        "B": "['GAATTC', 'GGTCTC'] — the default list is shared across calls",
        "C": "TypeError — you cannot use a list as a default argument",
        "D": "['GGTCTC', 'GAATTC'] — the list prepends new entries"
      },
      "answer": "B",
      "explanation": "The default list is created once when the function is defined, not each\ntime the function is called. Both calls therefore use the same list object.\nAfter the first call it contains <pre>GAATTC</pre>, and after the second it\ncontains <pre>GAATTC</pre> and <pre>GGTCTC</pre>. The standard fix is to use\n<python>sites=None</python> and create a new list inside the function when\nneeded.\n"
    },
    {
      "slug": "class-attribute-vs-instance-attribute",
      "difficulty": "medium",
      "topic": "Distinguishing data shared across all instances from data specific to one instance",
      "question": "A TranscriptDesigner class stores both shared configuration and\nper-design results:\n\n<python>\nclass TranscriptDesigner:\n    checkers = [ForbiddenSequenceChecker, HairpinChecker]  # class attribute\n\n    def __init__(self, protein_seq):\n        self.protein_seq = protein_seq   # instance attribute\n        self.cds = None                  # instance attribute\n\ndesigner_a = TranscriptDesigner('MKALIV')\ndesigner_b = TranscriptDesigner('MPQRST')\n</python>\n\nWhich statement is true?\n",
      "choices": {
        "A": "designer_a.checkers and designer_b.checkers refer to the same list; their protein_seq values differ",
        "B": "Each designer has its own independent copy of checkers and protein_seq",
        "C": "checkers is only accessible via the class, not through instances",
        "D": "designer_a.protein_seq and designer_b.protein_seq refer to the same string"
      },
      "answer": "A",
      "explanation": "<python>checkers</python> is a class attribute, so it is shared across all\ninstances unless shadowed on a specific instance. By contrast,\n<python>self.protein_seq</python> is assigned in <python>__init__</python>,\nso each instance gets its own value. This is a common pattern: shared\nconfiguration at the class level and per-object state at the instance\nlevel.\n"
    },
    {
      "slug": "argument-order-and-keyword-args",
      "difficulty": "medium",
      "topic": "Using positional and keyword arguments to make function calls readable and correct",
      "question": "A PCR primer design function has this signature:\n\n<python>\ndef design_primers(template, target_tm=60.0, min_length=18, max_length=30):\n    ...\n</python>\n\nA student calls it four ways:\n\n<python>\na = design_primers('ATGCCC...', 55.0, 20, 25)\nb = design_primers('ATGCCC...', max_length=25, target_tm=55.0)\nc = design_primers('ATGCCC...', min_length=20, 55.0)\nd = design_primers(target_tm=55.0, template='ATGCCC...')\n</python>\n\nWhich calls raise a SyntaxError?\n",
      "choices": {
        "A": "Only c — positional arguments cannot follow keyword arguments",
        "B": "c and d — keyword arguments must match the exact order",
        "C": "Only d — template must be passed positionally",
        "D": "None — Python accepts arguments in any order"
      },
      "answer": "A",
      "explanation": "In a function call, positional arguments must come before keyword\narguments. Call <python>c</python> violates that rule by placing\n<python>55.0</python> after the keyword argument\n<python>min_length=20</python>. Calls <python>a</python> and\n<python>b</python> are valid, and call <python>d</python> is also valid\nbecause all arguments are passed by keyword (keyword order does not have to\nmatch the parameter order).\n"
    },
    {
      "slug": "function-composition-pipeline",
      "difficulty": "medium",
      "topic": "Composing functions so the output of one becomes the input of the next in a processing pipeline",
      "question": "A gene design pipeline composes three functions:\n\n<python>\ndef reverse_translate(protein, codon_table):\n    '''Returns a DNA CDS encoding the protein.'''\n    ...\n\ndef optimize_codons(cds, organism):\n    '''Returns an optimized version of the CDS.'''\n    ...\n\ndef remove_forbidden_sites(cds, forbidden):\n    '''Returns a CDS with forbidden sites silently eliminated.'''\n    ...\n</python>\n\nA student writes:\n\n<python>\ncds = reverse_translate('MKALI', codon_table)\noptimized = optimize_codons(cds, 'ecoli')\nfinal = remove_forbidden_sites(optimized, ['GAATTC', 'GGTCTC'])\n</python>\n\nAnother student writes:\n\n<python>\nfinal = remove_forbidden_sites(\n    optimize_codons(\n        reverse_translate('MKALI', codon_table),\n        'ecoli'),\n    ['GAATTC', 'GGTCTC'])\n</python>\n\nWhat is the relationship between these two approaches?\n",
      "choices": {
        "A": "They produce the same result — the second nests the calls but the execution order and data flow are identical",
        "B": "The nested version runs faster because it avoids creating intermediate variables",
        "C": "The nested version skips the optimize_codons step",
        "D": "They produce different results because nested calls change the evaluation order"
      },
      "answer": "A",
      "explanation": "Both versions call the same functions in the same logical order with the\nsame inputs. The nested form simply passes each return value directly into\nthe next function call instead of storing intermediate variables. Python\nevaluates the innermost call first, so the data flow is the same in both\nversions. Named intermediate variables are often easier to inspect while\ndebugging, but the final result is the same."
    }
  ],
  "indexing_slicing_and_string_processing": [
    {
      "slug": "zero-based-index-extraction",
      "difficulty": "medium",
      "topic": "Applying zero-based indexing to extract a specific element from sequential data",
      "question": "A promoter sequence is stored as a string. A student wants to check\nthe base at the transcription start site, which is the 5th nucleotide\nin the stored sequence:\n\n<pre>promoter = 'TTGACATATAAT'</pre>\n\nThe student writes:\n\n<python>\ntss = promoter[5]\n</python>\n\nWhat value does <python>tss</python> hold, and did the student get what\nthey wanted?\n",
      "choices": {
        "A": "'A' — this is the 6th nucleotide, not the 5th; the student has an off-by-one error",
        "B": "'C' — this is the 5th nucleotide, exactly what the student wanted",
        "C": "'T' — index 5 wraps around to the beginning of the string",
        "D": "IndexError — index 5 is out of range for this string"
      },
      "answer": "A",
      "explanation": "Python uses zero-based indexing, so the indices are:\n<python>promoter[0]='T'</python>, <python>promoter[1]='T'</python>,\n<python>promoter[2]='G'</python>, <python>promoter[3]='A'</python>,\n<python>promoter[4]='C'</python>, <python>promoter[5]='A'</python>.\nTherefore <python>promoter[5]</python> returns <pre>A</pre>, which is the\n6th nucleotide. The 5th nucleotide (1-based position 5) is at\n<python>promoter[4]</python>, which is <pre>C</pre>. This is a classic\noff-by-one error caused by mixing biological 1-based positions with\nPython's 0-based indexing.\n"
    },
    {
      "slug": "slice-endpoint-exclusion",
      "difficulty": "medium",
      "topic": "Understanding that slice endpoints are exclusive and reasoning about boundary positions",
      "question": "A gene annotation says the start codon begins at position 10 (0-based)\nin a genomic sequence. You want to extract the 3-nucleotide start codon:\n\n<pre>genome = 'CCCGTTAAACATGAAAGGGCCC'</pre>\n\nWhich slice correctly extracts <pre>ATG</pre> starting at index 10?\n",
      "choices": {
        "A": "genome[10:13]",
        "B": "genome[10:12]",
        "C": "genome[11:14]",
        "D": "genome[10:10+2]"
      },
      "answer": "A",
      "explanation": "Python slicing uses a half-open interval: <python>seq[start:end]</python>\nincludes <python>start</python> but excludes <python>end</python>. To get 3\ncharacters starting at index 10, you need indices 10, 11, and 12, so the\ncorrect slice is <python>genome[10:13]</python>. The general rule is:\nto extract <python>n</python> characters starting at index <python>i</python>,\nuse <python>seq[i:i+n]</python>.\n"
    },
    {
      "slug": "negative-index-from-end",
      "difficulty": "medium",
      "topic": "Using negative indices to access elements relative to the end of a sequence",
      "question": "A CDS must end with a stop codon. To extract the last three\nnucleotides for verification:\n\n<pre>cds = 'ATGAAAGGTCTCTAA'</pre>\n\nA student writes:\n\n<python>\nlast_codon = cds[-3:]\n</python>\n\nWhat is the value of <python>last_codon</python>?\n",
      "choices": {
        "A": "TAA",
        "B": "ATG",
        "C": "CTT",
        "D": "IndexError — negative indices are not allowed on strings"
      },
      "answer": "A",
      "explanation": "Negative indices count from the end of the string. The slice\n<python>cds[-3:]</python> means \"from the third-to-last character through\nthe end,\" which returns <pre>TAA</pre>. This is the standard idiom for\nchecking a terminal codon without explicitly computing the string length.\n"
    },
    {
      "slug": "off-by-one-protospacer-extraction",
      "difficulty": "medium",
      "topic": "Getting boundary arithmetic right when extracting a region defined relative to a landmark position",
      "question": "A CRISPR guide design function locates a PAM site (<pre>NGG</pre>) and must\nextract the 20-nt protospacer immediately upstream. The PAM starts at\nindex 25 in the target sequence:\n\n<python>\ntarget = '...' # a long genomic string\npam_index = 25\n</python>\n\nWhich slice correctly extracts the 20-nt protospacer?\n",
      "choices": {
        "A": "target[pam_index-20:pam_index]",
        "B": "target[pam_index-21:pam_index-1]",
        "C": "target[pam_index-20:pam_index-1]",
        "D": "target[pam_index-19:pam_index]"
      },
      "answer": "A",
      "explanation": "If the PAM starts at index 25, the 20-nt protospacer immediately upstream\noccupies indices 5 through 24 inclusive. In Python's half-open slicing,\nthat is <python>target[5:25]</python>, which is exactly\n<python>target[pam_index-20:pam_index]</python>. The endpoint should be the\nPAM index itself because slice endpoints are already exclusive.\n"
    },
    {
      "slug": "slice-with-step-reverse",
      "difficulty": "medium",
      "topic": "Using a step argument in slicing to reverse or subsample sequential data",
      "question": "A function needs to reverse a DNA sequence as part of computing the\nreverse complement. Given:\n\n<pre>seq = 'AACGTCG'</pre>\n\nWhat is the value of <python>seq[::-1]</python>?\n",
      "choices": {
        "A": "GCTGCAA",
        "B": "AACGTCG",
        "C": "GCAACGT",
        "D": "TypeError — strings do not support step slicing"
      },
      "answer": "A",
      "explanation": "The slice <python>[::-1]</python> reverses a sequence by stepping through it\nfrom end to beginning. Reversing <pre>AACGTCG</pre> gives <pre>GCTGCAA</pre>.\nThis creates a new string; it does not modify the original in place.\n"
    },
    {
      "slug": "find-returns-negative-one",
      "difficulty": "medium",
      "topic": "Distinguishing methods that return sentinel values from those that raise exceptions on failure",
      "question": "A restriction site scanner needs to locate <pre>GAATTC</pre> (EcoRI) in a\ndesigned gene. Two approaches:\n\n<python>\ncds = 'ATGAAACCCGGGTAA'\n\npos_a = cds.find('GAATTC')\npos_b = cds.index('GAATTC')\n</python>\n\nThe site is not present in this CDS. What happens?\n",
      "choices": {
        "A": "Both return -1",
        "B": "find returns -1; index raises ValueError",
        "C": "find returns None; index returns -1",
        "D": "Both raise ValueError"
      },
      "answer": "B",
      "explanation": "<python>str.find()</python> returns <python>-1</python> when the substring\nis absent, while <python>str.index()</python> raises a ValueError. This\ndifference matters in sequence-scanning code because failing to check for\n<python>-1</python> can lead to silent downstream slicing bugs.\n"
    },
    {
      "slug": "string-immutability-mutation",
      "difficulty": "medium",
      "topic": "Recognizing that immutable sequences cannot be modified in place and must be rebuilt",
      "question": "A codon optimization function wants to replace the codon at positions\n6-8 in a CDS with a synonymous alternative:\n\n<python>\ncds = 'ATGAAACCCGGGTAA'\ncds[6:9] = 'CCT'\n</python>\n\nWhat happens?\n",
      "choices": {
        "A": "The CDS is updated to 'ATGAAACCTGGGTAA'",
        "B": "TypeError — strings do not support item assignment",
        "C": "The slice is replaced and the string shrinks if the new codon is shorter",
        "D": "A new string is returned but cds is unchanged"
      },
      "answer": "B",
      "explanation": "Strings are immutable in Python, so you cannot assign to an index or a\nslice of a string. The statement raises a TypeError. To make this change,\nyou must build a new string, for example:\n<python>cds = cds[:6] + 'CCT' + cds[9:]</python>.\n"
    },
    {
      "slug": "codon-boundary-alignment",
      "difficulty": "medium",
      "topic": "Ensuring that positional arithmetic respects the internal structure of sequential data",
      "question": "A function extracts the codon that contains a specific nucleotide\nposition in a CDS. The CDS is in frame (starts with ATG at index 0).\nGiven nucleotide position 7:\n\n<pre>cds = 'ATGAAACCCTAA'</pre>\n\nWhat is the codon containing position 7 and what are its boundaries?\n",
      "choices": {
        "A": "'CCC' at indices 6:9 — position 7 falls in the third codon (i=6)",
        "B": "'AAC' at indices 3:6 — position 7 is in the second codon",
        "C": "'ACC' at indices 7:10 — start the codon at the given position",
        "D": "'CCC' at indices 7:9 — extract from position 7 to end of codon"
      },
      "answer": "A",
      "explanation": "In a CDS that starts in frame at index 0, codons begin at indices\n0, 3, 6, 9, and so on. To find the codon containing position\n<python>p</python>, compute the codon start as\n<python>(p // 3) * 3</python>. For <python>p = 7</python>, this gives\n<python>6</python>, so the codon is <python>cds[6:9]</python> = <pre>CCC</pre>.\nThis preserves reading-frame alignment rather than starting a 3-nt window\nat an arbitrary position.\n"
    },
    {
      "slug": "overlapping-substring-count",
      "difficulty": "medium",
      "topic": "Understanding how built-in search methods handle overlapping matches in sequential data",
      "question": "A function checks how many times the dinucleotide <pre>AA</pre> appears in a\npoly-A tract:\n\n<python>\nseq = 'AAAAAC'\ncount_a = seq.count('AA')\n</python>\n\nWhat is the value of <python>count_a</python>?\n",
      "choices": {
        "A": "4 — every overlapping occurrence is counted",
        "B": "2 — count returns non-overlapping matches from left to right",
        "C": "3 — count slides a window one base at a time",
        "D": "5 — every position where 'A' appears is counted"
      },
      "answer": "B",
      "explanation": "<python>str.count()</python> counts non-overlapping matches. In\n<pre>AAAAAC</pre>, it matches <pre>AA</pre> at indices 0-1 and again at 2-3,\nfor a total of 2. If you need overlapping matches, you must use an\nexplicit loop (or another method designed for overlapping pattern search).\n"
    },
    {
      "slug": "case-normalization-before-search",
      "difficulty": "medium",
      "topic": "Ensuring consistent data representation before performing comparisons or lookups",
      "question": "GenBank files sometimes represent features in lowercase to indicate\nthey were computationally predicted. A function must check whether a\nsequence contains a BamHI site (<pre>GGATCC</pre>), regardless of case:\n\n<pre>seq = 'atgGGATCCaaa'</pre>\n\nA student writes three attempts:\n\n<python>\nattempt1 = 'GGATCC' in seq\nattempt2 = 'GGATCC' in seq.upper()\nattempt3 = 'ggatcc' in seq\n</python>\n\nWhich attempt correctly detects the site regardless of input casing?\n",
      "choices": {
        "A": "Only attempt2",
        "B": "attempt1 and attempt2",
        "C": "attempt2 and attempt3",
        "D": "All three"
      },
      "answer": "A",
      "explanation": "Python string matching is case-sensitive. Only <python>attempt2</python>\nnormalizes the sequence before searching, so it works whether the site is\nuppercase, lowercase, or mixed case in the input. The other attempts may\nwork on some inputs but are not robust to arbitrary capitalization."
    }
  ],
  "tracebacks_and_exceptions": [
    {
      "slug": "reading-traceback-to-find-failing-line",
      "difficulty": "medium",
      "topic": "Reading a stack trace to identify which line caused an error and what triggered it",
      "question": "A student runs a gene design pipeline and gets this traceback:\n\n<pre>\nTraceback (most recent call last):\n  File \"pipeline.py\", line 12, in <module>\n    result = design_rbs(cds, proteomics)\n  File \"rbs.py\", line 45, in design_rbs\n    abundance = proteomics[gene_id]\nKeyError: 'b0025'\n</pre>\n\nWhich line actually raised the error, and what caused it?\n",
      "choices": {
        "A": "Line 12 of pipeline.py — the function design_rbs does not exist",
        "B": "Line 45 of rbs.py — the key 'b0025' was not found in the proteomics dict",
        "C": "Line 12 of pipeline.py — cds is None",
        "D": "Line 45 of rbs.py — gene_id is an integer but should be a string"
      },
      "answer": "B",
      "explanation": "Read the traceback from the bottom up: the last frame shown is where the\nexception was raised. Here, line 45 in <python>rbs.py</python> attempted\n<python>proteomics[gene_id]</python>, and the key <pre>b0025</pre> was not\npresent in the dict, so Python raised a KeyError. Line 12 in\n<python>pipeline.py</python> is the caller that led to the failure, not the\nline that raised it.\n"
    },
    {
      "slug": "exception-type-from-none-attribute-access",
      "difficulty": "medium",
      "topic": "Predicting the exception type when an operation is applied to the wrong kind of value",
      "question": "A CRISPR target finder returns None when no valid guide is found:\n\n<python>\ndef find_best_guide(seq, pam='NGG'):\n    candidates = find_all_targets(seq, pam)\n    if len(candidates) == 0:\n        return None\n    return select_best(candidates)\n</python>\n\nA caller writes:\n\n<python>\nguide = find_best_guide(short_seq)\nprint(guide.spacer)\n</python>\n\nIf no guide was found, what exception is raised on the second line?\n",
      "choices": {
        "A": "ValueError — the spacer is invalid",
        "B": "NameError — guide was never defined",
        "C": "AttributeError — None has no attribute 'spacer'",
        "D": "TypeError — print cannot accept None"
      },
      "answer": "C",
      "explanation": "If no guide is found, <python>find_best_guide()</python> returns\n<python>None</python>, so <python>guide</python> is defined but holds\n<python>None</python>. Accessing <python>guide.spacer</python> then raises\nAttributeError because <python>None</python> has no attribute\n<python>spacer</python>. The error occurs before <python>print()</python>\nreceives an argument.\n"
    },
    {
      "slug": "guard-clause-vs-silent-failure",
      "difficulty": "medium",
      "topic": "Recognizing why validating inputs early with guard clauses prevents harder-to-diagnose errors later",
      "question": "Two versions of reverse_complement handle non-ATCG characters differently:\n\n<python>\n# Version A: silently skips invalid bases\ndef reverse_complement_a(seq):\n    comp = {'A': 'T', 'T': 'A', 'C': 'G', 'G': 'C'}\n    result = ''\n    for base in seq:\n        if base in comp:\n            result = comp[base] + result\n    return result\n\n# Version B: guard clause that rejects invalid input\ndef reverse_complement_b(seq):\n    if not all(b in 'ATCG' for b in seq):\n        raise ValueError(f'Invalid base in sequence: {seq}')\n    comp = {'A': 'T', 'T': 'A', 'C': 'G', 'G': 'C'}\n    result = ''\n    for base in seq:\n        result = comp[base] + result\n    return result\n</python>\n\nA researcher accidentally passes <pre>ATGNCC</pre> (with an ambiguous N).\nWhat happens with each version?\n",
      "choices": {
        "A": "Both raise ValueError — any non-ATCG character triggers an error",
        "B": "A returns 'GGNAT' (skipping N); B raises ValueError explaining the problem",
        "C": "A returns 'GGNCAT'; B returns 'GGNCAT' — both handle N the same way",
        "D": "A returns 'GGCAT' (silently dropping N); B raises ValueError explaining the problem"
      },
      "answer": "D",
      "explanation": "In Version A, <pre>N</pre> is not in the complement dict, so it is silently\nskipped. The function therefore returns the reverse complement of\n<pre>ATGCC</pre>, which is <pre>GGCAT</pre>, and the output is the wrong length.\nIn Version B, the guard clause checks the full input first and raises a\nValueError with a clear message. This is preferable because it fails fast\ninstead of silently corrupting the result.\n"
    },
    {
      "slug": "raise-vs-return-none-for-invalid-input",
      "difficulty": "medium",
      "topic": "Choosing between raising an exception and returning None when a function receives illegal input",
      "question": "A function computes the molecular weight of a DNA sequence. A student\nconsiders two designs for handling a sequence that contains non-DNA\ncharacters:\n\n<python>\n# Design 1\ndef molecular_weight(seq):\n    if not all(b in 'ATCG' for b in seq):\n        return None\n    ...\n\n# Design 2\ndef molecular_weight(seq):\n    if not all(b in 'ATCG' for b in seq):\n        raise ValueError(f'Non-DNA character in: {seq}')\n    ...\n</python>\n\nA caller writes:\n\n<python>\ntotal = molecular_weight(seq1) + molecular_weight(seq2)\n</python>\n\nIf <python>seq2</python> contains an invalid character, what happens under\neach design?\n",
      "choices": {
        "A": "Design 1 returns None for the sum; Design 2 raises ValueError",
        "B": "Design 1 raises TypeError (cannot add number and None); Design 2 raises ValueError with a clear message",
        "C": "Both designs raise ValueError — returning None is automatically converted",
        "D": "Both produce None — the + operator propagates None like SQL null"
      },
      "answer": "B",
      "explanation": "Under Design 1, <python>molecular_weight(seq2)</python> returns\n<python>None</python>, so the addition becomes number + <python>None</python>,\nwhich raises TypeError. That error hides the real cause (invalid DNA\ninput). Under Design 2, the function raises ValueError immediately with a\nmessage that points directly to the bad input. Raising an exception at the\nvalidation boundary usually produces clearer, more actionable failures.\n"
    },
    {
      "slug": "propagating-vs-catching-exceptions",
      "difficulty": "medium",
      "topic": "Understanding when to let exceptions propagate versus catching them inside a function",
      "question": "A codon optimization pipeline has three layers:\n\n<python>\ndef optimize_codon_at(cds, pos, codon_table):\n    '''Replace one codon. Raises ValueError if pos is out of range.'''\n    if pos < 0 or pos >= len(cds) // 3:\n        raise ValueError(f'Codon position {pos} out of range')\n    ...\n\ndef optimize_all_codons(cds, codon_table):\n    '''Optimize every codon in the CDS.'''\n    for i in range(len(cds) // 3):\n        cds = optimize_codon_at(cds, i, codon_table)\n    return cds\n</python>\n\n<python>\n# Top-level script\ntry:\n    result = optimize_all_codons(my_cds, table)\nexcept ValueError as e:\n    print(f'Design failed: {e}')\n</python>\n\nWhere is the exception caught, and why is this structure correct?\n",
      "choices": {
        "A": "optimize_all_codons should catch the ValueError so the loop can continue with other codons",
        "B": "optimize_codon_at should catch its own ValueError so it never propagates",
        "C": "The exception propagates from optimize_codon_at through optimize_all_codons to the top-level try/except, which is the appropriate place to handle it",
        "D": "Each layer should have its own try/except block wrapping every call"
      },
      "answer": "C",
      "explanation": "<python>optimize_codon_at()</python> raises the exception, and\n<python>optimize_all_codons()</python> does not catch it, so it propagates\nupward to the top-level <python>try/except</python>. That is usually the\nright design when lower-level functions cannot recover meaningfully from\nthe error. The top-level script can then report the failure cleanly to the\nuser or log it.\n"
    },
    {
      "slug": "distinguishing-caller-error-from-function-bug",
      "difficulty": "medium",
      "topic": "Distinguishing between a bug inside a function and invalid input from its caller",
      "question": "A function translates a DNA sequence and a colleague reports it crashes:\n\n<pre>\nTraceback (most recent call last):\n  File \"design.py\", line 8, in <module>\n    protein = translate(user_seq)\n  File \"bio.py\", line 22, in translate\n    aa = genetic_code[codon]\nKeyError: 'ATN'\n</pre>\n\nThe genetic_code dict contains all 64 standard codons. Is this a bug\nin translate or a caller error?\n",
      "choices": {
        "A": "Bug in translate — it should handle every possible three-letter string",
        "B": "Caller error — 'ATN' is not a valid codon, so the input sequence contains non-ATCG characters that should have been validated before calling translate",
        "C": "Bug in genetic_code — it is missing entries for ambiguous bases",
        "D": "Caller error — the caller should have wrapped the call in try/except"
      },
      "answer": "B",
      "explanation": "<pre>ATN</pre> is not one of the 64 standard DNA codons because it contains\nan ambiguous base (<pre>N</pre>). If the function contract expects a valid DNA\nsequence with bases in <pre>ATCG</pre>, then this is invalid input from the\ncaller, not evidence that the translation function is broken. Catching the\nexception at the caller may prevent a crash, but it does not fix the bad\ninput.\n"
    },
    {
      "slug": "choosing-the-right-exception-type",
      "difficulty": "medium",
      "topic": "Selecting the appropriate exception type to communicate why a function rejected its input",
      "question": "A function checks whether a primer sequence is valid for ordering:\n\n<python>\ndef validate_primer(seq):\n    if not isinstance(seq, str):\n        raise ???('seq must be a string, got ' + type(seq).__name__)\n    if len(seq) < 15:\n        raise ???('Primer too short: ' + str(len(seq)) + ' bases (minimum 15)')\n    if not all(b in 'ATCG' for b in seq.upper()):\n        raise ???('Primer contains non-DNA characters: ' + seq)\n</python>\n\nWhat exception types best fill the three ??? slots?\n",
      "choices": {
        "A": "TypeError, ValueError, ValueError",
        "B": "ValueError, ValueError, ValueError",
        "C": "TypeError, IndexError, KeyError",
        "D": "Exception, Exception, Exception"
      },
      "answer": "A",
      "explanation": "Use TypeError when the argument has the wrong type (the first check), and\nValueError when the argument has the right type but an unacceptable value\n(the second and third checks). This preserves an important distinction for\ncallers and tests: wrong type vs wrong domain value.\n"
    },
    {
      "slug": "traceback-through-multiple-calls",
      "difficulty": "medium",
      "topic": "Reading a multi-level traceback to understand the chain of calls that led to a failure",
      "question": "A gene design pipeline crashes with this traceback:\n\n<pre>\nTraceback (most recent call last):\n  File \"main.py\", line 5, in <module>\n    construct = build_construct(gene, plasmid)\n  File \"assembly.py\", line 18, in build_construct\n    rbs_result = design_rbs(gene['cds'])\n  File \"rbs.py\", line 7, in design_rbs\n    utr = chooser.run(cds)\n  File \"chooser.py\", line 34, in run\n    score = self.proteomics[gene_id]\nKeyError: 'yaaX'\n</pre>\n\nA student says \"the bug is in chooser.py line 34.\" Another says \"the\nreal problem is missing or incomplete proteomics setup upstream.\" Who is\ncloser to the correct diagnosis?\n",
      "choices": {
        "A": "The first student — the fix should be adding 'yaaX' to the proteomics dict at line 34",
        "B": "The second student — the traceback shows where the error surfaced, but the root cause is likely missing or incomplete data setup upstream",
        "C": "Both are wrong — the error is in main.py where build_construct is called",
        "D": "Both are wrong — KeyError means the code has a syntax error"
      },
      "answer": "B",
      "explanation": "The traceback shows where the KeyError surfaced: <python>chooser.py</python>\nline 34, while looking up <pre>yaaX</pre> in <python>self.proteomics</python>.\nBut the better diagnosis is about root cause: the proteomics table may not\nhave been loaded, may be incomplete, or may not contain the expected gene\nidentifiers. Good debugging distinguishes the line where an exception is\nraised from the earlier setup step that created the bad state.\n"
    },
    {
      "slug": "what-happens-without-input-validation",
      "difficulty": "medium",
      "topic": "Predicting the downstream consequences of skipping input validation in a function",
      "question": "A function computes GC content but does not validate its input:\n\n<python>\ndef gc_content(seq):\n    gc = sum(1 for b in seq if b in 'GC')\n    return gc / len(seq)\n</python>\n\nA caller accidentally passes an integer gene ID instead of a sequence:\n\n<python>\ngc = gc_content(1234)\n</python>\n\nWhat happens?\n",
      "choices": {
        "A": "Returns 0.0 — no characters in an integer match 'G' or 'C'",
        "B": "TypeError — iterating over an integer with 'for b in seq' is not supported",
        "C": "Returns 0.25 — the digits are treated as characters",
        "D": "ValueError — the function detects that 1234 is not a DNA sequence"
      },
      "answer": "B",
      "explanation": "Integers are not iterable in Python, so the generator expression\n<python>for b in seq</python> raises TypeError. The message will be about an\n<python>int</python> not being iterable. A validation guard at the top of\nthe function (for example, checking that <python>seq</python> is a string)\nwould fail earlier with a clearer, more specific message.\n"
    },
    {
      "slug": "error-message-quality",
      "difficulty": "medium",
      "topic": "Evaluating whether an error message gives the caller enough information to diagnose the problem",
      "question": "Two versions of a restriction site checker raise exceptions differently:\n\n<python>\n# Version A\ndef check_forbidden_sites(seq, forbidden):\n    for site in forbidden:\n        if site in seq:\n            raise ValueError('bad')\n\n# Version B\ndef check_forbidden_sites(seq, forbidden):\n    for site in forbidden:\n        if site in seq:\n            pos = seq.index(site)\n            raise ValueError(\n                f'Forbidden site {site} found at position {pos} in sequence'\n            )\n</python>\n\nA designer gets a ValueError while building a construct with 5 forbidden\nsites to check. Why is Version B's error message better?\n",
      "choices": {
        "A": "Version B is not better — both stop execution equally well",
        "B": "Version B names the specific forbidden site and its position, so the designer knows exactly what to fix without re-running any code",
        "C": "Version B is better only because it includes the word \"Forbidden\"",
        "D": "Version B is slower because it calls seq.index, so Version A is preferred"
      },
      "answer": "B",
      "explanation": "Version A's message (<python>'bad'</python>) gives almost no diagnostic\ninformation. Version B identifies both what failed (which forbidden site)\nand where it failed (the position in the sequence). That makes the error\nimmediately actionable for the caller and reduces extra debugging work."
    }
  ],
  "automated_testing_and_validation": [
    {
      "slug": "validated-example-strength",
      "difficulty": "medium",
      "topic": "Understanding why experimentally confirmed data provides the strongest evidence for test correctness",
      "question": "A student writes three tests for a function that identifies protospacer\nsequences in a CRISPR array. Which test provides the strongest evidence\nthat the function works correctly?\n\n<python>\n# Test A: checks output is a string\ndef test_output_is_string():\n    result = find_protospacer(crispr_array)\n    assert isinstance(result, str)\n\n# Test B: checks output length is 20\ndef test_output_length():\n    result = find_protospacer(crispr_array)\n    assert len(result) == 20\n\n# Test C: uses experimentally confirmed protospacer from cadA\ndef test_cada_protospacer():\n    result = find_protospacer(cada_crispr_array)\n    assert result == 'ATAGTGAATGCTCAACGAAC'\n</python>\n",
      "choices": {
        "A": "Test A — type checking catches the broadest class of bugs",
        "B": "Test B — length constraints are more specific than type checks",
        "C": "Test C — matching a known experimental result validates actual correctness",
        "D": "All three are equally strong because they all use assert"
      },
      "answer": "C",
      "explanation": "Test C compares the output to an experimentally confirmed sequence. That\nis direct evidence that the algorithm returns the biologically correct\nprotospacer for a real case. Tests A and B are useful but weaker: a\nfunction can return the wrong 20-nt DNA string and still pass both. This\nillustrates the evidence hierarchy used in this course: validated example\n> specific property check > general type check.\n"
    },
    {
      "slug": "truism-property-check",
      "difficulty": "medium",
      "topic": "Recognizing property-based checks that verify necessary but not sufficient conditions for correctness",
      "question": "A function designs DNA oligos for Gibson Assembly. A test checks:\n\n<python>\ndef test_oligo_properties():\n    oligos = design_gibson_oligos(parts)\n    for oligo in oligos:\n        assert set(oligo).issubset({'A', 'T', 'C', 'G'})\n        assert 15 <= len(oligo) <= 80\n</python>\n\nBoth assertions pass. Can you conclude the oligos are correct?\n",
      "choices": {
        "A": "Yes — if the oligos contain only ATCG and are the right length, they must be correct",
        "B": "No — these are necessary properties of any valid oligo, but a completely wrong sequence could also pass",
        "C": "Yes — checking two independent properties is sufficient for validation",
        "D": "No — the test is wrong because it should use assertEqual instead of assert"
      },
      "answer": "B",
      "explanation": "These assertions test necessary properties, not full correctness. An oligo\ncan have the right alphabet and length while still being the wrong sequence\nfor the intended assembly. This kind of test is useful for catching gross\nfailures, but it does not validate the design logic itself.\n"
    },
    {
      "slug": "fixture-expensive-setup",
      "difficulty": "medium",
      "topic": "Using fixtures to share expensive initialization across tests without repeating computation",
      "question": "An RBSChooser requires loading a proteomics database and computing\nthermodynamic models, a process that takes 30 seconds. A student writes:\n\n<python>\ndef test_rbs_high_expression():\n    chooser = RBSChooser()\n    chooser.initiate()               # 30 seconds\n    result = chooser.run('ATGAAAGCGTAA', target='high')\n    assert result is not None\n\ndef test_rbs_low_expression():\n    chooser = RBSChooser()\n    chooser.initiate()               # 30 seconds again\n    result = chooser.run('ATGAAAGCGTAA', target='low')\n    assert result is not None\n</python>\n\nRunning both tests takes 60 seconds. What is the standard pytest\nmechanism to initialize the chooser once and share it across both tests?\n",
      "choices": {
        "A": "Move the initialization into a global variable at module level",
        "B": "Use a pytest fixture that creates and initiates the chooser once per session",
        "C": "Combine both tests into a single test function with two assertions",
        "D": "Cache the result by writing it to a file between test runs"
      },
      "answer": "B",
      "explanation": "A pytest fixture with an appropriate scope (such as module or session)\nperforms the expensive setup once and injects the initialized object into\ntests that request it. This avoids repeated 30-second setup costs while\npreserving test structure and readability.\n"
    },
    {
      "slug": "edge-case-identification",
      "difficulty": "medium",
      "topic": "Identifying inputs at domain boundaries that expose assumptions in biological sequence algorithms",
      "question": "A function finds CRISPR guide RNA targets by searching for the pattern\nNGG (PAM site) in a DNA sequence and returning the 20bp upstream:\n\n<python>\ndef find_guides(seq):\n    guides = []\n    for i in range(20, len(seq)):\n        if seq[i+1:i+3] == 'GG':\n            guides.append(seq[i-20:i])\n    return guides\n</python>\n\nWhich input is the best edge case to test for a hidden case-sensitivity\nassumption?\n",
      "choices": {
        "A": "A 1000bp sequence with multiple NGG sites",
        "B": "A lowercase sequence such as 'atgccaattgg...'",
        "C": "A 1000bp sequence with exactly one NGG site",
        "D": "A sequence consisting of only 'A' repeated 100 times"
      },
      "answer": "B",
      "explanation": "The code compares to uppercase <pre>GG</pre>. If the input sequence is\nlowercase, real PAM sites may be missed silently. Testing lowercase input\ndirectly probes a common hidden assumption in sequence-processing code.\nOption D is also a useful edge case (no matches), but it targets a\ndifferent behavior and is less specific to case sensitivity.\n"
    },
    {
      "slug": "inverse-function-testing",
      "difficulty": "medium",
      "topic": "Using inverse operations to validate that a design function produces correct outputs",
      "question": "DesignPCRPrimers takes a template and a target region and returns a pair\nof primers. PredictPCRProduct takes primers and a template and returns\nthe sequence that would be amplified. A test uses both:\n\n<python>\ndef test_pcr_roundtrip():\n    primers = DesignPCRPrimers(template, target_region)\n    product = PredictPCRProduct(primers, template)\n    assert product.sequence == target_region.sequence\n</python>\n\nWhy is this inverse function pattern a strong validation strategy?\n",
      "choices": {
        "A": "It eliminates the need for any other tests because it is mathematically complete",
        "B": "It verifies the design against an independent implementation of the domain logic, not just property checks",
        "C": "It is weaker than a truism because it depends on two functions both being correct",
        "D": "It only works for PCR and cannot be generalized to other design problems"
      },
      "answer": "B",
      "explanation": "This pattern checks the designer using a separate simulator that models the\ndomain behavior. If independently implemented design and simulation agree\non the intended product, that is much stronger evidence than simple output\nproperties like length or alphabet. It is still not a complete proof, so\nvalidated examples and edge-case tests remain valuable.\n"
    },
    {
      "slug": "checker-pattern-centralized",
      "difficulty": "medium",
      "topic": "Centralizing domain knowledge in reusable checkers shared between algorithm and test code",
      "question": "A ForbiddenSequenceChecker is used inside the codon optimization\nalgorithm to avoid restriction sites, and the same checker is called\nin the test to verify the output:\n\n<python>\n# Inside the algorithm\ndef optimize_codons(protein, ...):\n    candidate = generate_candidate(protein)\n    checker = ForbiddenSequenceChecker(['GGTCTC', 'CGTCTC'])\n    if not checker.run(candidate):\n        candidate = retry(...)\n    return candidate\n\n# In the test\ndef test_no_forbidden_sites():\n    result = optimize_codons('MKALM...')\n    checker = ForbiddenSequenceChecker(['GGTCTC', 'CGTCTC'])\n    assert checker.run(result)\n</python>\n\nWhat is the key advantage of using the same checker in both places?\n",
      "choices": {
        "A": "It makes the test run faster because the checker is already compiled",
        "B": "It ensures the algorithm and the test encode identical domain knowledge, preventing definition drift",
        "C": "It means the test is trivially guaranteed to pass and therefore provides no value",
        "D": "It eliminates the need for validated examples because the checker is authoritative"
      },
      "answer": "B",
      "explanation": "Reusing the same checker centralizes the definition of what counts as a\nforbidden sequence. That prevents definition drift between the production\ncode and the test suite. The test still has value because the algorithm can\nfail to apply the checker correctly on some execution paths.\n"
    },
    {
      "slug": "pytest-raises-invalid-input",
      "difficulty": "medium",
      "topic": "Verifying that functions reject invalid inputs by asserting specific exceptions are raised",
      "question": "A function that designs oligos should raise a ValueError when given a\nprotein sequence (containing amino acid letters not in ATCG) instead of\nDNA. A student writes this test:\n\n<python>\ndef test_rejects_protein_input():\n    result = design_oligos('MKALMPRGSL')\n    assert result is None\n</python>\n\nA colleague suggests a different approach:\n\n<python>\ndef test_rejects_protein_input():\n    with pytest.raises(ValueError):\n        design_oligos('MKALMPRGSL')\n</python>\n\nWhy is the colleague's version better?\n",
      "choices": {
        "A": "The first test is equivalent — returning None and raising ValueError are interchangeable signals",
        "B": "The colleague's version explicitly verifies the function fails loudly rather than silently returning a value that could propagate undetected",
        "C": "pytest.raises makes the test run faster than checking return values",
        "D": "The first test would fail because design_oligos would return an empty list, not None"
      },
      "answer": "B",
      "explanation": "<python>pytest.raises(ValueError)</python> verifies the function's error\ncontract: invalid input should trigger an explicit exception immediately.\nReturning <python>None</python> is a silent failure mode that can travel\ndownstream and cause a more confusing error later.\n"
    },
    {
      "slug": "test-passes-vs-design-correct",
      "difficulty": "medium",
      "topic": "Distinguishing between a test suite passing and the underlying design being biologically correct",
      "question": "A student's test suite for a codon optimizer has 15 passing tests. The\ntests check: output contains only ATCG, output length equals 3 times the\ninput protein length, output starts with ATG, and output ends with a stop\ncodon. A colleague then examines the output for a well-studied gene and\nfinds heavy use of rare codons, which would likely produce poor expression\nin E. coli.\n\nWhat does this reveal?\n",
      "choices": {
        "A": "The test suite has a bug — if 15 tests pass, the design must be correct",
        "B": "The tests verify structural properties, but none check whether the codon choices are actually optimized",
        "C": "Rare codons are acceptable because the sequence is still valid DNA",
        "D": "The colleague's observation is irrelevant because automated tests are the gold standard"
      },
      "answer": "B",
      "explanation": "The tests described are mostly structural checks (truisms). They confirm\nthat the output looks like a CDS, but they do not test the biological goal\nof codon optimization. A sequence can be valid DNA and still be a poor\ndesign for expression. This is why optimization tasks need domain-aware\ntests, such as validated examples or checkers that score codon usage.\n"
    },
    {
      "slug": "algorithm-test-shared-knowledge",
      "difficulty": "medium",
      "topic": "Recognizing that meaningful tests require the same domain expertise as the algorithm being tested",
      "question": "Two students test a hairpin checker. Student A writes:\n\n<python>\ndef test_hairpin():\n    result = check_hairpin('ATCGATCG')\n    assert isinstance(result, bool)\n</python>\n\nStudent B writes:\n\n<python>\ndef test_known_hairpin():\n    # AAAACCCCGGGGTTTTT forms a strong hairpin:\n    # 5'-AAAACCCC    (stem)\n    #          GGGG-3' (loop + complementary stem)\n    assert check_hairpin('AAAACCCCGGGGTTTTT') == True\n\ndef test_no_hairpin():\n    # Alternating AT has no self-complementary regions\n    assert check_hairpin('ATATATATATATAT') == False\n</python>\n\nWhy does Student B's approach require more domain knowledge?\n",
      "choices": {
        "A": "Student B uses more assertions, which requires understanding pytest better",
        "B": "Student B had to understand nucleic acid secondary structure to select inputs whose correct outputs are known",
        "C": "Student B's tests are longer, which makes them harder to write but no more informative",
        "D": "Student A's test is actually better because it does not assume specific outputs"
      },
      "answer": "B",
      "explanation": "Student B must know which sequences are expected to form hairpins and which\nare not. That requires domain knowledge about sequence self-complementarity\nand secondary structure, not just Python syntax. That same domain knowledge\nis what makes the test informative rather than superficial.\n"
    },
    {
      "slug": "benchmarking-all-inputs",
      "difficulty": "medium",
      "topic": "Using exhaustive input sets to expose failures that hand-picked test cases might miss",
      "question": "A codon optimization function is tested on three hand-picked genes and\npasses all assertions. A senior developer then runs the function on all\n4,391 protein-coding genes in the E. coli proteome:\n\n<python>\n@pytest.fixture(scope='session')\ndef proteome():\n    return load_ecoli_proteome()\n\ndef test_all_genes(proteome):\n    for gene in proteome:\n        result = optimize_codons(gene.protein)\n        assert len(result) == 3 * len(gene.protein)\n        checker = ForbiddenSequenceChecker(['GGTCTC'])\n        assert checker.run(result)\n</python>\n\nThe test fails on 12 genes. What is the most likely reason the hand-picked\ntests did not catch these failures?\n",
      "choices": {
        "A": "The hand-picked genes were too short to trigger bugs",
        "B": "The hand-picked genes may not have contained the specific amino acid combinations or rare subsequences that expose algorithmic edge cases",
        "C": "Three tests are always sufficient if they cover different gene lengths",
        "D": "The proteome test is overfitting to E. coli and does not generalize"
      },
      "answer": "B",
      "explanation": "Hand-picked tests reflect what the author thought to try. The 12 failing\ngenes likely contain sequence patterns the smaller test set did not cover.\nBroad benchmarking across the full proteome exposes edge cases and failure\nmodes that are easy to miss with a few examples, even when those examples\nlook diverse."
    }
  ],
  "schemas_identity_and_serialization": [
    {
      "slug": "required-vs-optional-fields",
      "difficulty": "medium",
      "topic": "Distinguishing required from optional fields and predicting behavior when optional fields are absent",
      "question": "A Polynucleotide dataclass is defined with some fields required and\nothers optional:\n\n<python>\n@dataclass\nclass Polynucleotide:\n    sequence: str\n    ext5: str = ''\n    ext3: str = ''\n    is_double_stranded: bool = True\n    is_circular: bool = False\n    mod_ext5: str = ''\n    mod_ext3: str = ''\n</python>\n\nA colleague creates an instance with only the sequence:\n\n<python>\ndna = Polynucleotide(sequence='ATGAAATAA')\n</python>\n\nWhat are the values of dna.ext5 and dna.is_circular?\n",
      "choices": {
        "A": "'' and False — optional fields take their default values",
        "B": "None and None — unspecified fields are always None",
        "C": "TypeError — all fields must be provided explicitly",
        "D": "'' and True — is_circular defaults to True for any sequence"
      },
      "answer": "A",
      "explanation": "In a dataclass, fields with default values are optional during\nconstruction. sequence has no default and is required; ext5 and\nis_circular use their declared defaults of '' and False. Option B\nconfuses omitted fields with None. Option C would apply only if those\nfields had no defaults. Option D invents biological logic that the class\ndoes not encode.\n"
    },
    {
      "slug": "frozen-dataclass-immutability",
      "difficulty": "medium",
      "topic": "Understanding how frozen dataclasses enforce immutability and why that matters for data integrity",
      "question": "A strain genotype is modeled as a frozen dataclass:\n\n<python>\n@dataclass(frozen=True)\nclass Strain:\n    name: str\n    genotype: tuple\n\necoli = Strain(name='DH10B', genotype=('lacZ-', 'recA1'))\n</python>\n\nLater, a function tries to record a new mutation:\n\n<python>\necoli.genotype = ('lacZ-', 'recA1', 'endA1')\n</python>\n\nWhat happens?\n",
      "choices": {
        "A": "The genotype is updated to include endA1",
        "B": "FrozenInstanceError — frozen dataclasses do not allow attribute reassignment",
        "C": "The original object is unchanged but a new Strain is silently created",
        "D": "TypeError because tuples cannot be extended"
      },
      "answer": "B",
      "explanation": "<python>frozen=True</python> makes dataclass attributes read-only after\nconstruction. Reassigning <python>ecoli.genotype</python> raises\n<python>FrozenInstanceError</python> (a subclass of AttributeError).\nThe failure is due to dataclass immutability, not tuple immutability.\n"
    },
    {
      "slug": "sequence-invariant-validation",
      "difficulty": "medium",
      "topic": "Enforcing invariants on object fields to prevent construction of invalid biological objects",
      "question": "A Polynucleotide constructor includes a validator:\n\n<python>\n@dataclass\nclass Polynucleotide:\n    sequence: str\n\n    def __post_init__(self):\n        import re\n        if not re.fullmatch(r'[ATCG]+', self.sequence):\n            raise ValueError('Sequence must be non-empty and contain only A, T, C, G')\n</python>\n\nWhich of the following calls raises a ValueError?\n",
      "choices": {
        "A": "Polynucleotide(sequence='ATGCCC')",
        "B": "Polynucleotide(sequence='AUGCCC')",
        "C": "Polynucleotide(sequence='ATCG')",
        "D": "Polynucleotide(sequence='GGGGGGGG')"
      },
      "answer": "B",
      "explanation": "The regex <python>r'[ATCG]+'</python> allows only DNA bases A, T, C, and\nG, and requires at least one character. <pre>AUGCCC</pre> contains U, so it\nfails validation and raises ValueError. The other sequences contain only\nvalid DNA bases and pass.\n"
    },
    {
      "slug": "reference-by-identifier",
      "difficulty": "medium",
      "topic": "Using stable identifiers to reference objects indirectly instead of embedding them directly",
      "question": "A ConstructionFile describes a cloning plan. One approach serializes the\nfull Polynucleotide object into each saved step. Another stores only the\ntemplate name and resolves it later from a registry:\n\n<python>\n# Approach 1: serialize embedded object into the saved file\nstep = {'action': 'PCR', 'template': pUC19_object}\n\n# Approach 2: reference by identifier in the saved file\nstep = {'action': 'PCR', 'template': 'pUC19'}\n# later: registry['pUC19'] returns the current object\n</python>\n\nA collaborator corrects pUC19's sequence in the registry after the file is\nsaved. What happens when the saved ConstructionFile is later reloaded?\n",
      "choices": {
        "A": "Both approaches automatically see the updated sequence",
        "B": "Only approach 2 sees the update — approach 1 preserves the older serialized object state",
        "C": "Only approach 1 sees the update — direct references track changes automatically after reload",
        "D": "Neither approach sees the update — registry lookup cannot affect reloaded files"
      },
      "answer": "B",
      "explanation": "In approach 2, the saved file contains only <pre>pUC19</pre>. On reload, that\nidentifier is resolved against the registry, so it retrieves the current\ncorrected object. In approach 1, the saved file contains the embedded object\ndata as it existed when saved, so it preserves the older sequence unless the\nfile itself is updated. This is the key advantage of reference-by-identifier:\nindirection allows the referenced object to evolve independently.\n"
    },
    {
      "slug": "sharable-identity-fields",
      "difficulty": "medium",
      "topic": "Identifying the minimal set of fields needed to uniquely identify and describe a shared resource",
      "question": "In the C9 system, all Sharables (models, data, functions, views) carry a\ncommon set of identity fields: id, type, name, description, and keywords.\n\nA student proposes dropping the id field and using name alone as the\nunique identifier, arguing that names are human-readable. Why is a\nseparate id field necessary?\n",
      "choices": {
        "A": "Names may be duplicated or changed over time; a stable id ensures references never break",
        "B": "The id field stores the object's sequence data, which names cannot hold",
        "C": "Python requires an id field for all objects to enable garbage collection",
        "D": "The name field is optional in Sharables, so it cannot serve as an identifier"
      },
      "answer": "A",
      "explanation": "Names are human-friendly, but they are not guaranteed to be unique or\nstable. A separate id provides a persistent reference that still works if a\nname changes or if multiple objects share similar names. This is the same\nidea as accession numbers in sequence databases.\n"
    },
    {
      "slug": "json-schema-type-enforcement",
      "difficulty": "medium",
      "topic": "Using schema definitions to validate data types and prevent silent errors in serialized data",
      "question": "A JSON schema for a Polynucleotide requires:\n\n<pre>\n{\n  \"sequence\": {\"type\": \"string\"},\n  \"is_circular\": {\"type\": \"boolean\"}\n}\n</pre>\n\nA researcher exports their construct as JSON, but their script writes\nis_circular as the string \"true\" instead of the boolean true:\n\n<pre>{\"sequence\": \"ATGAAATAA\", \"is_circular\": \"true\"}</pre>\n\nWhat should happen when this JSON is validated against the schema?\n",
      "choices": {
        "A": "Validation passes — \"true\" and true are equivalent in JSON",
        "B": "Validation fails — the schema requires a boolean, not a string",
        "C": "Validation passes — JSON schemas ignore type mismatches",
        "D": "Validation fails — \"true\" is not a valid JSON value"
      },
      "answer": "B",
      "explanation": "JSON distinguishes between strings and booleans. The schema explicitly\nrequires a boolean for <python>is_circular</python>, so the string\n<pre>\"true\"</pre> fails validation. This prevents subtle downstream bugs,\nsuch as treating the string <pre>\"false\"</pre> as truthy in Python.\n"
    },
    {
      "slug": "cf-shorthand-name-resolution",
      "difficulty": "medium",
      "topic": "Parsing a shorthand notation that uses names to reference objects and resolving them in order",
      "question": "A ConstructionFile uses CF shorthand where each line defines a new DNA\nby name, and subsequent lines can reference previously defined DNAs:\n\n<pre>\nPCR p1 p2 pUC19   -> frag1\nPCR p3 p4 genomic -> frag2\nGibson frag1 frag2 -> product\n</pre>\n\nThe Gibson step references frag1 and frag2 by name. What happens if the\nlines are reordered so the Gibson step appears before the PCR steps?\n",
      "choices": {
        "A": "It still works — CF shorthand resolves names after parsing all lines",
        "B": "It fails — frag1 and frag2 have not been defined yet when Gibson is parsed",
        "C": "It works only if frag1 and frag2 are pre-registered in a global registry",
        "D": "It produces the same product but with reversed fragment order"
      },
      "answer": "B",
      "explanation": "CF shorthand is parsed top-to-bottom. A name becomes available only after\nthe line that defines it has been parsed. If the Gibson line appears first,\n<pre>frag1</pre> and <pre>frag2</pre> cannot be resolved at that point.\n"
    },
    {
      "slug": "serialization-preserves-semantics",
      "difficulty": "medium",
      "topic": "Ensuring that serialization and deserialization preserve all semantically meaningful distinctions",
      "question": "Two Polynucleotide objects differ only in circularity:\n\n<python>\nlinear = Polynucleotide(sequence='ATGAAATAA', is_circular=False)\ncircular = Polynucleotide(sequence='ATGAAATAA', is_circular=True)\n</python>\n\nA student writes a serializer that saves only the sequence to a FASTA file\nand a deserializer that reconstructs the object with default values:\n\n<python>\ndef serialize(poly):\n    return f'>construct\\n{poly.sequence}'\n\ndef deserialize(fasta_text):\n    seq = fasta_text.split('\\n')[1]\n    return Polynucleotide(sequence=seq)\n</python>\n\nWhat happens when the circular plasmid is round-tripped through\nserialize then deserialize?\n",
      "choices": {
        "A": "The circular plasmid is correctly reconstructed as circular",
        "B": "The circular plasmid is reconstructed as linear — the circularity information is lost",
        "C": "A ValueError is raised because FASTA cannot store DNA sequences",
        "D": "The sequence itself is corrupted during serialization"
      },
      "answer": "B",
      "explanation": "The serializer writes only the sequence and discards the\n<python>is_circular</python> field. On deserialization, the object is rebuilt\nusing defaults, so <python>is_circular</python> becomes False. This is a loss\nof semantics during round-trip serialization.\n"
    },
    {
      "slug": "registry-lookup-failure",
      "difficulty": "medium",
      "topic": "Handling the case where a referenced identifier does not exist in the registry",
      "question": "A ConstructionFile references a plasmid by name:\n\n<pre>PCR oJC101 oJC102 pSB1C3 -> pcr_product</pre>\n\nThe parser looks up <pre>pSB1C3</pre> in a local registry dict:\n\n<python>\ntemplate = registry['pSB1C3']\n</python>\n\nBut the researcher forgot to add pSB1C3 to the registry before running the\nparser. What happens, and what is the best handling behavior?\n",
      "choices": {
        "A": "template is set to None, and the PCR step proceeds with no template",
        "B": "KeyError is raised; the parser should catch it and report which DNA name is missing",
        "C": "The parser automatically downloads pSB1C3 from a remote database",
        "D": "An empty Polynucleotide is created as a placeholder"
      },
      "answer": "B",
      "explanation": "Accessing a missing dict key raises KeyError. The parser should catch that\nand report a clear message identifying the missing name (and ideally the\nsource line), rather than continuing with invalid placeholder data.\n"
    },
    {
      "slug": "polynucleotide-extensions-meaning",
      "difficulty": "medium",
      "topic": "Understanding how optional fields modify the interpretation of a core required field",
      "question": "A Polynucleotide has a required sequence field and optional ext5 and ext3\nfields representing single-stranded overhangs:\n\n<python>\nfrag = Polynucleotide(\n    sequence='ATGAAAGGGCCC',\n    ext5='AATT',\n    ext3='',\n    is_double_stranded=True\n)\n</python>\n\nIn the physical DNA this represents, what is the structure at the 5' end\nversus the 3' end?\n",
      "choices": {
        "A": "The 5' end has a 4-nt single-stranded overhang; the 3' end is blunt",
        "B": "Both ends are blunt — ext5 and ext3 are metadata labels, not structural features",
        "C": "The 5' end is blunt; the 3' end has a 4-nt overhang",
        "D": "Both ends have 4-nt overhangs — ext3 defaults to matching ext5"
      },
      "answer": "A",
      "explanation": "<python>ext5='AATT'</python> indicates a 4-nt single-stranded extension on\nthe 5' end. <python>ext3=''</python> means no 3' extension, so the 3' end is\nblunt. The extension fields change the physical interpretation of the same\ncore double-stranded sequence."
    }
  ],
  "api_contracts_and_mcp": [
    {
      "slug": "function-signature-as-contract",
      "difficulty": "medium",
      "topic": "Understanding that a function signature and docstring define a contract between the implementer and every caller",
      "question": "A codon optimization function is documented as:\n\n<python>\ndef optimize_codons(cds: str, organism: str) -> str:\n    '''Accepts a DNA coding sequence and a host organism name.\n    Returns a codon-optimized DNA sequence of the same length.\n    Raises ValueError if cds length is not a multiple of 3.'''\n    ...\n</python>\n\nA colleague calls the function and writes these checks:\n\n<python>\nresult = optimize_codons('ATGAAAGGG', 'ecoli')\nassert len(result) == len('ATGAAAGGG')\nassert result.startswith('ATG')\n</python>\n\nWhy is the length assertion justified but the startswith assertion risky?\n",
      "choices": {
        "A": "The contract guarantees same-length output but makes no promise about preserving the start codon",
        "B": "Both assertions are guaranteed by the contract because ATG always maps to ATG",
        "C": "Neither assertion is safe because a return type of str allows any string",
        "D": "The startswith check is safe because biological convention requires a start codon"
      },
      "answer": "A",
      "explanation": "The docstring explicitly guarantees that the returned sequence has the same\nlength as the input, so the length assertion is contract-safe. The contract\nsays nothing about preserving any specific codon, including the start codon.\nA real implementation would usually preserve <pre>ATG</pre>, but callers should not\nrely on behavior the API does not explicitly promise. Option B assumes a\nbiological fact that is outside the stated contract. Option C ignores the\nexplicit same-length guarantee. Option D confuses biological convention with\nan API guarantee.\n"
    },
    {
      "slug": "separate-computation-from-io",
      "difficulty": "medium",
      "topic": "Recognizing why separating pure computation from I/O makes functions reusable and testable",
      "question": "Two approaches to computing the melting temperature of a primer:\n\n<python>\n# Version A\ndef get_tm_from_user():\n    seq = input('Enter primer sequence: ')\n    tm = 2 * sum(1 for b in seq if b in 'AT') + 4 * sum(1 for b in seq if b in 'GC')\n    print(f'Tm = {tm}')\n\n# Version B\ndef compute_tm(seq: str) -> float:\n    return 2 * sum(1 for b in seq if b in 'AT') + 4 * sum(1 for b in seq if b in 'GC')\n</python>\n\nA design pipeline needs to compute Tm for 500 primers stored in a list.\nWhich version can it use directly?\n",
      "choices": {
        "A": "Version A — it can be called in a loop with each primer",
        "B": "Version B — it accepts a sequence argument and returns a value, so it works with any data source",
        "C": "Both work equally well — print and return are interchangeable",
        "D": "Neither — both are unusable because the formula is a simplified approximation"
      },
      "answer": "B",
      "explanation": "Version A mixes computation with I/O: it reads from the keyboard and prints\nto the console. That makes it hard to use inside a pipeline that already has\nthe sequences in memory and needs the numeric result back. Version B cleanly\nseparates computation from I/O by taking an input value and returning an\noutput value. This makes it reusable in loops, tests, web apps, notebooks,\nand other functions. Option A fails because <python>input()</python> blocks for\ninteractive entry. Option C confuses a side effect (<python>print</python>) with\na returned value. Option D critiques the model, but the question is about API\ndesign and reusability.\n"
    },
    {
      "slug": "pure-function-guarantees",
      "difficulty": "medium",
      "topic": "Identifying the guarantees a pure function provides and why they matter for reproducible pipelines",
      "question": "A gene design pipeline calls three functions in sequence:\n\n<python>\ndef codon_optimize(cds, codon_table):\n    '''Pure function: returns optimized CDS.'''\n    ...\n\ndef log_to_database(cds, timestamp):\n    '''Writes the CDS and timestamp to a remote database.'''\n    ...\n\ndef add_flanking_sequences(cds, vector):\n    '''Pure function: returns CDS with appropriate flanks.'''\n    ...\n</python>\n\nThe pipeline runs once and produces a correct result. The server hosting\nthe database later goes offline. What happens when the pipeline is rerun\nwith identical inputs?\n",
      "choices": {
        "A": "All three functions fail — the database outage propagates to the pure functions",
        "B": "codon_optimize and add_flanking_sequences produce the same results; log_to_database fails",
        "C": "The pipeline produces a different result because the database cached state from the first run",
        "D": "All three succeed — Python automatically retries failed network calls"
      },
      "answer": "B",
      "explanation": "Pure functions depend only on their inputs and have no side effects, so they\nare unaffected by external failures like a database outage. With identical\ninputs, <python>codon_optimize</python> and <python>add_flanking_sequences</python>\nshould return the same outputs as before. <python>log_to_database</python>\nperforms network I/O and fails when the database is unavailable. This is why\npipelines are typically designed with a pure computational core and I/O at the\nedges. Option A incorrectly treats pure functions as externally dependent.\nOption C invents a hidden dependency not stated in the code. Option D invents\nautomatic retry behavior.\n"
    },
    {
      "slug": "mcp-host-client-server-roles",
      "difficulty": "medium",
      "topic": "Distinguishing the roles of host, client, and server in a layered protocol architecture",
      "question": "In the Model Context Protocol (MCP), three roles cooperate:\n\n- Server: exposes capabilities (Resources, Tools, Prompts)\n- Client: maintains a 1:1 connection with a server\n- Host: the user-facing application that coordinates clients\n\nA bioinformatics lab runs an MCP server that exposes a codon optimization\nTool. A researcher uses an LLM-powered assistant (the host) connected to\nthat server. The LLM proposes calling the codon optimization tool for the\nsequence <pre>ATGAAACCC</pre>.\n\nWho decides whether the tool is actually invoked?\n",
      "choices": {
        "A": "The server — it controls access to all tools it exposes",
        "B": "The LLM — including the tool call in its response already executes it",
        "C": "The host — it mediates between the LLM and the client, applying approval policies",
        "D": "The client — it autonomously executes any request the LLM generates"
      },
      "answer": "C",
      "explanation": "In MCP, the LLM proposes actions, but the host is responsible for applying\napproval policies before any tool call is executed. The host mediates between\nthe user, the model, and the client connection. Option A confuses exposing a\ntool with deciding whether to execute a particular invocation. Option B treats\na proposal as execution. Option D skips the host approval layer that is\ncentral to controlled tool use.\n"
    },
    {
      "slug": "mcp-resources-vs-tools",
      "difficulty": "medium",
      "topic": "Distinguishing read-only data access from actions that produce side effects",
      "question": "An MCP server for a genetic design platform exposes the following:\n\nResource: \"parts-catalog\" — returns the current list of BioBrick parts\nResource: \"codon-tables\" — returns codon usage tables for supported organisms\nTool: \"run-optimization\" — accepts a CDS and returns an optimized sequence\nTool: \"order-dna\" — submits a DNA sequence to a synthesis vendor\n\nA student claims that Resources and Tools are interchangeable and that\n\"parts-catalog\" could just as easily be a Tool. What is wrong with this claim?\n",
      "choices": {
        "A": "Resources are for read-only data retrieval; Tools are for actions that may have side effects — conflating them weakens the safety model",
        "B": "Resources return JSON and Tools return plain text, so the formats are incompatible",
        "C": "Tools are faster than Resources, which is why computation should be a Tool",
        "D": "Resources can only be accessed by the server itself, not by external clients"
      },
      "answer": "A",
      "explanation": "MCP separates Resources (read-only retrieval) from Tools (invoked actions that\nmay have side effects). Read access to a parts catalog should not require the\nsame approval flow as actions like placing an order. Treating read-only data\nas a Tool creates unnecessary approval friction and blurs an important safety\nboundary. Option B invents a format rule. Option C invents a performance rule.\nOption D is false because Resources are intended for client access.\n"
    },
    {
      "slug": "tool-invocation-approval",
      "difficulty": "medium",
      "topic": "Understanding why proposed actions require explicit approval before execution",
      "question": "An MCP-connected assistant is helping a researcher design a plasmid.\nThe assistant has access to these tools:\n\nTool: \"blast-sequence\" — runs BLAST against NCBI (network call)\nTool: \"order-dna\" — submits a sequence to IDT for synthesis ($$$)\nTool: \"write-genbank\" — writes a GenBank file to disk\n\nThe LLM generates a plan: \"I'll BLAST your insert, write the GenBank file,\nand order the DNA.\" Under MCP's controlled invocation model, what should\nhappen next?\n",
      "choices": {
        "A": "All three tools execute immediately — the user already asked for help",
        "B": "The host presents the proposed tool calls for approval before any execute",
        "C": "Only order-dna requires approval; blast-sequence and write-genbank run automatically",
        "D": "The server decides which tools are safe and executes those without asking"
      },
      "answer": "B",
      "explanation": "In MCP, tool calls are proposed first and executed only after host approval\n(by the user or by an explicit policy). That approval step matters because\nthe tools here have real side effects: network access, filesystem writes, and\na purchase/order action. Option A skips the control boundary. Option C may be\npossible under a custom policy, but it is not the default controlled-invocation\nmodel. Option D incorrectly places the approval decision at the server rather\nthan the host.\n"
    },
    {
      "slug": "error-modes-raise-vs-return-none",
      "difficulty": "medium",
      "topic": "Choosing between raising an exception and returning a sentinel value to communicate failure",
      "question": "A function validates a DNA sequence before processing:\n\n<python>\n# Approach 1: raise on error\ndef validate_cds(seq):\n    if len(seq) % 3 != 0:\n        raise ValueError(f'CDS length {len(seq)} is not a multiple of 3')\n    return seq\n\n# Approach 2: return None on error\ndef validate_cds(seq):\n    if len(seq) % 3 != 0:\n        return None\n    return seq\n</python>\n\nA caller passes an invalid sequence and then immediately calls\n<python>translate()</python> on the result without checking:\n\n<python>\ncds = validate_cds('ATGAA')\nprotein = translate(cds)\n</python>\n\nWhich approach leads to a more diagnosable failure?\n",
      "choices": {
        "A": "Approach 2 — returning None lets the caller decide how to handle the error",
        "B": "Approach 1 — the ValueError halts immediately with a message explaining the problem",
        "C": "Both are equivalent — translate will fail either way",
        "D": "Approach 2 — None is automatically skipped by translate"
      },
      "answer": "B",
      "explanation": "Approach 1 fails immediately at the point where the invalid input is detected\nand raises a ValueError that explains the actual problem. Approach 2 silently\nreturns <python>None</python>; if the caller forgets to check, the eventual\nerror appears later inside <python>translate()</python>, often as a less useful\nTypeError or AttributeError. Option A is about flexibility for careful callers,\nbut the question asks about diagnosability when the caller does not check.\nOption C ignores the difference in error quality. Option D invents behavior.\n"
    },
    {
      "slug": "function-scope-documentation",
      "difficulty": "medium",
      "topic": "Documenting what a function does and does not handle to set correct expectations",
      "question": "A function's docstring states:\n\n<python>\ndef remove_restriction_sites(cds: str, sites: list[str]) -> str:\n    '''Silently replaces codons to eliminate the specified restriction\n    sites from cds while preserving the encoded protein.\n\n    Scope: operates only on the coding region. Does not modify UTRs,\n    promoters, or flanking sequences. Does not check whether the\n    replacement introduces new forbidden sites not in the input list.\n\n    Raises ValueError if cds is not a valid reading frame.\n    Returns the modified CDS as a string.'''\n    ...\n</python>\n\nA researcher passes a full plasmid sequence (promoter + CDS + terminator)\nand finds that a BsaI site in the promoter is still present after the call.\nWhat went wrong?\n",
      "choices": {
        "A": "The function has a bug — it should scan the entire input for restriction sites",
        "B": "The researcher used the function outside its documented scope — it only operates on a coding region",
        "C": "BsaI sites cannot be removed computationally, only by manual design",
        "D": "The function silently failed because the promoter confused its reading-frame parser"
      },
      "answer": "B",
      "explanation": "The docstring explicitly limits the function's scope to the coding region and\nstates that promoters and flanking sequences are not modified. The researcher\npassed a full plasmid, so the function was used outside its documented\ncontract. This is a usage error, not evidence of a bug in the stated behavior.\nOption A ignores the documented scope. Option C is factually wrong. Option D\ninvents a failure mode not supported by the contract.\n"
    },
    {
      "slug": "reference-by-identifier-serialization",
      "difficulty": "medium",
      "topic": "Understanding why storing identifiers rather than full objects enables reliable serialization",
      "question": "A cloning plan is stored as a Python dict and serialized to JSON:\n\n<python>\n# Approach 1: embed full objects\nplan = {\n    'step': 'Gibson',\n    'fragments': [polynucleotide_obj_1, polynucleotide_obj_2]\n}\n\n# Approach 2: reference by identifier\nplan = {\n    'step': 'Gibson',\n    'fragment_ids': ['frag_001', 'frag_002']\n}\n</python>\n\nWhen <python>json.dumps(plan)</python> is called on each approach, what happens?\n",
      "choices": {
        "A": "Both serialize successfully — json.dumps handles any Python object",
        "B": "Approach 1 raises TypeError because custom objects are not JSON-serializable; approach 2 succeeds because it stores only strings",
        "C": "Approach 2 fails because identifiers cannot be resolved during serialization",
        "D": "Both fail — dicts cannot be serialized to JSON"
      },
      "answer": "B",
      "explanation": "<python>json.dumps()</python> can serialize standard JSON-compatible Python\ntypes such as dicts, lists, strings, numbers, booleans, and None. Custom\nobjects (like a Polynucleotide instance) are not JSON-serializable by default\nand raise TypeError unless a custom encoder is provided. Storing identifiers\nas strings avoids that problem and cleanly separates serialization from later\nobject resolution. Option C confuses serialization with lookup. Option D is\nfalse because dicts of JSON-compatible values serialize normally.\n"
    },
    {
      "slug": "json-schema-contract-enforcement",
      "difficulty": "medium",
      "topic": "Using a schema as a machine-readable contract that enforces structure before data enters a system",
      "question": "A design tool accepts JSON input validated against this schema:\n\n<pre>\n{\n  \"type\": \"object\",\n  \"required\": [\"sequence\", \"organism\"],\n  \"properties\": {\n    \"sequence\": {\"type\": \"string\", \"pattern\": \"^[ATCG]+$\"},\n    \"organism\": {\"type\": \"string\", \"enum\": [\"ecoli\", \"yeast\", \"human\"]},\n    \"circular\": {\"type\": \"boolean\"}\n  },\n  \"additionalProperties\": false\n}\n</pre>\n\nWhich JSON input passes validation?\n",
      "choices": {
        "A": "<pre>{\"sequence\": \"ATGCCC\", \"organism\": \"ecoli\"}</pre>",
        "B": "<pre>{\"sequence\": \"ATGCCC\", \"organism\": \"zebrafish\"}</pre>",
        "C": "<pre>{\"sequence\": \"ATGCCC\"}</pre>",
        "D": "<pre>{\"sequence\": \"ATGCCC\", \"organism\": \"ecoli\", \"temperature\": 37}</pre>"
      },
      "answer": "A",
      "explanation": "Option A includes both required fields, uses a sequence that matches the DNA\npattern, and provides an allowed organism value. <python>circular</python> is\noptional, so omitting it is valid. Option B fails the enum constraint.\nOption C fails the required-field constraint. Option D fails because\n<python>additionalProperties: false</python> disallows undeclared keys such as\n<python>temperature</python>. The schema acts as a machine-readable boundary\ncontract by enforcing structure and allowed values before computation begins."
    }
  ],
  "dna_rna_protein_and_core_processes": [
    {
      "slug": "transcription-directionality",
      "difficulty": "medium",
      "topic": "Understanding how enzyme movement on the template determines product directionality",
      "question": "RNA polymerase binds a promoter and begins transcribing a gene. The\ntemplate strand is read 3'->5', and the new RNA is synthesized 5'->3'.\n\nA student claims the mRNA sequence is identical to the template strand\nbecause polymerase \"copies\" the template. What is wrong with this claim?\n",
      "choices": {
        "A": "The mRNA is complementary to the template strand, not identical to it",
        "B": "The mRNA is identical to the template strand but in the reverse direction",
        "C": "RNA polymerase does not use a template at all and synthesizes RNA randomly",
        "D": "The mRNA is identical to the template strand except that T is replaced by U"
      },
      "answer": "A",
      "explanation": "RNA polymerase synthesizes an RNA strand that is complementary to the DNA\ntemplate. Base pairing is A-U, T-A, C-G, and G-C. Therefore, the mRNA is not\nidentical to the template strand. Instead, it matches the coding\n(non-template) strand sequence, except RNA uses U where DNA uses T. Option D\ndescribes the relationship between mRNA and the coding strand, not the\ntemplate strand.\n"
    },
    {
      "slug": "coding-vs-template-strand",
      "difficulty": "medium",
      "topic": "Distinguishing which strand carries the sequence that matches the product versus which strand is read",
      "question": "A gene has the following DNA sequence around the start codon:\n\n<pre>\n5'-...ATGAAACCC...-3'  (coding strand)\n3'-...TACTTTGGG...-5'  (template strand)\n</pre>\n\nWhich strand does RNA polymerase physically read, and what is the mRNA\nsequence for this region?\n",
      "choices": {
        "A": "It reads the coding strand (5'->3'); mRNA is 5'-AUGAAACCC...-3'",
        "B": "It reads the template strand (3'->5'); mRNA is 5'-AUGAAACCC...-3'",
        "C": "It reads the template strand (3'->5'); mRNA is 5'-UACUUUGGG...-3'",
        "D": "It reads the coding strand (3'->5'); mRNA is 5'-CCCAAAGUA...-3'"
      },
      "answer": "B",
      "explanation": "RNA polymerase reads the template strand in the 3'->5' direction and\nsynthesizes RNA 5'->3'. The RNA is complementary to the template and thus has\nthe same sequence as the coding strand except U replaces T, giving\n5'-AUGAAACCC...-3'. Option A gives the correct mRNA sequence but names the\nwrong strand as the one polymerase reads.\n"
    },
    {
      "slug": "uracil-in-rna",
      "difficulty": "medium",
      "topic": "Reasoning about why molecular differences between DNA and RNA have functional consequences",
      "question": "DNA uses thymine (T) while RNA uses uracil (U). Both bases pair with\nadenine. A student asks: \"If T and U both pair with A, does it matter which\none is used?\"\n\nWhich answer best explains why the distinction matters biologically?\n",
      "choices": {
        "A": "U pairs with A more strongly than T does, making RNA more stable than DNA",
        "B": "The cell can use U versus T to distinguish RNA from DNA, which helps support RNA turnover and DNA repair",
        "C": "U cannot form base pairs in double-stranded structures, so RNA must always be single-stranded",
        "D": "T and U are interchangeable, so the difference has no functional significance"
      },
      "answer": "B",
      "explanation": "T and U differ by a methyl group. That chemical difference matters because it\nhelps cells treat RNA and DNA differently. RNA is meant to be transient in\nmany contexts (for example mRNA turnover), while DNA is long-term storage.\nCells also treat uracil in DNA as damage (often arising from cytosine\ndeamination) and repair it. Option A is incorrect, and option C is false\nbecause RNA commonly forms double-stranded regions such as hairpins.\n"
    },
    {
      "slug": "genetic-code-direction",
      "difficulty": "medium",
      "topic": "Understanding why a lookup table is structured in one direction and what that implies for the reverse problem",
      "question": "The genetic code maps codons to amino acids. A student wants to go in the\nreverse direction: given an amino acid, determine which DNA codon to use. They\ntry:\n\n<python>\ncodon = genetic_code[amino_acid]\n</python>\n\nwhere genetic_code maps codons to amino acids. This fails. Beyond the coding\nerror, why is the reverse problem fundamentally harder?\n",
      "choices": {
        "A": "Some amino acids have no codon at all",
        "B": "The reverse mapping is one-to-many, so most amino acids have multiple valid codons",
        "C": "The genetic code is only valid in the 5'->3' direction and cannot be reversed conceptually",
        "D": "Amino acids map to codons in a different reading frame than codons map to amino acids"
      },
      "answer": "B",
      "explanation": "The genetic code is degenerate: many amino acids are encoded by multiple\nsynonymous codons. Translation (codon -> amino acid) is many-to-one, so a\ncodon lookup gives a single amino acid. Reverse translation (amino acid ->\ncodon) is one-to-many, so there is not one uniquely correct answer. Choosing\namong synonymous codons is exactly the codon optimization problem.\n"
    },
    {
      "slug": "start-stop-codon-roles",
      "difficulty": "medium",
      "topic": "Distinguishing the roles of signals that initiate versus terminate a molecular process",
      "question": "A gene's CDS begins with ATG and ends with a stop codon (TAA, TAG, or TGA).\nA student designs a CDS but accidentally introduces an in-frame TAA codon in\nthe middle. The gene is transcribed normally. What happens during\ntranslation?\n",
      "choices": {
        "A": "The ribosome skips the internal TAA because stop codons only work at the end of a gene",
        "B": "The ribosome terminates translation at the internal TAA, producing a truncated protein",
        "C": "The internal TAA is read as an amino acid because codon meaning depends on position",
        "D": "Transcription terminates at the internal TAA, so mRNA is not made past that point"
      },
      "answer": "B",
      "explanation": "During translation, the ribosome reads codons sequentially from the start\ncodon. Any in-frame stop codon is interpreted as a stop signal. An internal\nstop codon therefore causes premature termination and yields a truncated\nprotein. Option D confuses translation termination with transcription\ntermination, which is controlled by transcription terminator sequences, not\nstop codons.\n"
    },
    {
      "slug": "gene-structure-element-order",
      "difficulty": "medium",
      "topic": "Understanding how the spatial arrangement of gene elements determines functional sequence of events",
      "question": "In E. coli, a gene is organized as:\n\n<pre>promoter (-35, -10) -> +1 -> 5'UTR (with RBS) -> ATG -> CDS -> stop -> terminator</pre>\n\nA student moves the RBS to a position after the start codon. The promoter,\nCDS, and terminator are otherwise correct. What is the most likely outcome?\n",
      "choices": {
        "A": "Transcription fails because the RBS is required for RNA polymerase binding",
        "B": "The mRNA is transcribed, but translation initiation at the intended ATG is disrupted because the RBS must be upstream",
        "C": "Translation still works because bacterial ribosomes ignore RBS position and start at any ATG",
        "D": "The protein is produced normally but in a different reading frame"
      },
      "answer": "B",
      "explanation": "In bacteria, the ribosome-binding site (Shine-Dalgarno sequence) must be\nupstream of the start codon so the ribosome can position the start codon\ncorrectly for initiation. Moving the RBS downstream disrupts initiation at\nthe intended ATG. Transcription can still occur because RNA polymerase binds\nthe promoter, not the RBS.\n"
    },
    {
      "slug": "replication-vs-transcription-products",
      "difficulty": "medium",
      "topic": "Comparing two processes that use template-directed synthesis but produce fundamentally different outputs",
      "question": "Replication and transcription both use DNA as a template for polymer\nsynthesis. A student says: \"They are basically the same process, just with a\ndifferent polymerase.\"\n\nWhich statement best captures the key difference in what each process\nproduces?\n",
      "choices": {
        "A": "Replication duplicates the genome as double-stranded DNA, whereas transcription produces single-stranded RNA copies of selected regions",
        "B": "Replication produces RNA that is later converted to DNA, whereas transcription produces DNA that is later converted to RNA",
        "C": "Replication copies only the coding strand, whereas transcription copies only the template strand",
        "D": "Replication is error-free, whereas transcription always introduces mutations"
      },
      "answer": "A",
      "explanation": "Replication copies the entire genome to produce new double-stranded DNA\nmolecules. Transcription copies specific regions (genes or operons) into\nsingle-stranded RNA. The products differ in chemistry (DNA vs RNA), scope\n(whole genome vs selected regions), and typical lifespan (genomic storage vs\noften transient RNA molecules).\n"
    },
    {
      "slug": "information-carriers-comparison",
      "difficulty": "medium",
      "topic": "Reasoning about what each type of biological polymer encodes and why the system uses three rather than one",
      "question": "DNA, RNA, and protein all carry biological information, but they serve\ndifferent roles. A student asks: \"Why not just use DNA for everything? It is\nstable and stores sequence information.\"\n\nWhat is the strongest answer?\n",
      "choices": {
        "A": "DNA is well suited for stable information storage, but proteins provide diverse catalytic/structural functions and RNA provides a regulatable intermediate between gene copy number and protein production",
        "B": "RNA and protein exist only because DNA is too expensive for the cell to make in large amounts",
        "C": "Proteins are folded RNA molecules, so the cell effectively uses only two polymers",
        "D": "The three-polymer system persists only because evolution has not optimized it yet"
      },
      "answer": "A",
      "explanation": "DNA is specialized for stable information storage. Proteins, built from 20\namino acids with diverse chemistries, perform most catalysis and structural\nwork. RNA serves as an intermediate whose abundance can be regulated without\nchanging DNA copy number, enabling dynamic control of gene expression. The\nsystem is not redundant: each polymer contributes a distinct functional role.\n"
    },
    {
      "slug": "plasmid-origin-and-marker",
      "difficulty": "medium",
      "topic": "Understanding why autonomous genetic elements require both replication and selection functions",
      "question": "A minimal plasmid requires at least an origin of replication and a selectable\nmarker (for example, an antibiotic resistance gene). A student removes the\norigin to make room for a larger insert, reasoning that the host chromosome's\norigin will replicate the plasmid too.\n\nWhat is the most likely outcome after transformation?\n",
      "choices": {
        "A": "The plasmid is maintained normally because the host origin replicates all DNA in the cell",
        "B": "The plasmid cannot replicate as an independent molecule and is lost as cells divide, so transformants are not stably maintained",
        "C": "The plasmid automatically integrates into the chromosome at the host origin",
        "D": "The host dies immediately because plasmids without origins are intrinsically toxic"
      },
      "answer": "B",
      "explanation": "A plasmid needs its own origin to be replicated as an independent DNA\nmolecule. The chromosomal origin controls chromosome replication, not random\nextra DNA molecules. Without a plasmid origin, the incoming plasmid may exist\ntransiently after transformation but is not copied during cell division, so it\nis progressively lost. Selection cannot maintain a plasmid that is not being\nreplicated.\n"
    },
    {
      "slug": "polycistronic-mrna-and-operons",
      "difficulty": "medium",
      "topic": "Connecting gene organization to mRNA structure and understanding what one transcript can encode",
      "question": "In E. coli, the lac operon contains three genes (lacZ, lacY, lacA) under one\npromoter. When the operon is induced, RNA polymerase transcribes all three\ngenes into a single mRNA molecule.\n\nHow many separate proteins can ribosomes produce from this one mRNA?\n",
      "choices": {
        "A": "One, because each mRNA can encode only one protein",
        "B": "Three, because each coding region can have its own RBS and start codon for independent initiation",
        "C": "Three, but only after the mRNA is cut into three separate RNAs",
        "D": "It depends on whether all three genes are in the same reading frame"
      },
      "answer": "B",
      "explanation": "A bacterial polycistronic mRNA can encode multiple proteins. Each coding\nregion can have its own ribosome-binding site and start codon, allowing\nribosomes to initiate translation independently on the same transcript.\nBacterial translation does not require the mRNA to be cut into separate RNAs\nfirst. This arrangement supports coordinated expression of functionally\nrelated genes."
    }
  ],
  "regulation_control_points": [
    {
      "slug": "promoter-elements-transcription-rate",
      "difficulty": "medium",
      "topic": "Identifying which molecular features of a promoter determine transcription initiation rate",
      "question": "You are comparing two promoters that drive expression of the same gene in E. coli.\nPromoter A has a -10 box of <pre>TATAAT</pre> and a -35 box of <pre>TTGACA</pre>.\nPromoter B has a -10 box of <pre>CATAAT</pre> and a -35 box of <pre>TTGACA</pre>.\nBoth use sigma-70. Promoter A produces 10x more transcript than Promoter B.\n\nWhich explanation best accounts for the difference?\n",
      "choices": {
        "A": "The single base change in the -10 box reduces sigma factor affinity, lowering RNAP recruitment",
        "B": "The -10 box change alters the mRNA sequence, destabilizing the ribosome binding site",
        "C": "Sigma factor only recognizes the -35 box, so the -10 change has no effect",
        "D": "The -10 mutation changes the protein sequence of the downstream gene"
      },
      "answer": "A",
      "explanation": "Sigma factor recognizes both the -10 and -35 promoter elements. <pre>TATAAT</pre>\nis the sigma-70 consensus -10 sequence, so changing it to <pre>CATAAT</pre>\nweakens promoter recognition and reduces formation of a productive open complex.\nThat lowers transcription initiation rate. This is a transcriptional control point.\n\nOption B confuses promoter DNA with the transcribed mRNA region that contains the\nRBS. Option C is incorrect because sigma factor contacts both boxes. Option D is\nincorrect because promoter sequence is upstream of the coding region and is not\ntranslated.\n"
    },
    {
      "slug": "rbs-sequence-translation-initiation",
      "difficulty": "medium",
      "topic": "Reasoning about how Shine-Dalgarno sequence complementarity affects translation rate",
      "question": "Two constructs encode the same protein but differ only in their ribosome binding\nsite (RBS) region. Construct 1 has the Shine-Dalgarno sequence <pre>AGGAGG</pre>\nat position -8 relative to the start codon. Construct 2 has <pre>ACCACC</pre>\nat the same position. Both produce identical mRNA levels.\n\nWhat is the most likely effect on protein expression?\n",
      "choices": {
        "A": "Construct 2 produces more protein because ACCACC avoids stalling",
        "B": "Both produce equal protein because the mRNA levels are the same",
        "C": "Construct 1 produces more protein because AGGAGG base-pairs more strongly with 16S rRNA",
        "D": "Construct 2 produces more protein because its SD sequence recruits additional ribosomes"
      },
      "answer": "C",
      "explanation": "The Shine-Dalgarno sequence promotes translation initiation by base-pairing with the\nanti-Shine-Dalgarno sequence at the 3' end of 16S rRNA. <pre>AGGAGG</pre> is a\nstrong consensus-like SD sequence and provides stronger complementarity than\n<pre>ACCACC</pre>, which reduces ribosome recruitment and initiation.\n\nEqual mRNA levels do not imply equal protein output, because translation initiation\nis an independent control point. Option A and D do not provide a valid mechanism.\nOption B incorrectly treats transcription and translation as the same process.\n"
    },
    {
      "slug": "secondary-structure-blocks-translation",
      "difficulty": "medium",
      "topic": "Understanding how mRNA secondary structure near the start codon can occlude the RBS",
      "question": "You design a construct with a strong Shine-Dalgarno sequence and optimal spacing\nto the start codon. However, an RNA folding prediction shows that the SD sequence\nis sequestered in a stable hairpin formed between the SD region and nucleotides\ndownstream of the start codon. Protein expression is very low despite high mRNA\nlevels.\n\nWhat is the most likely cause?\n",
      "choices": {
        "A": "The hairpin is acting as a Rho-independent terminator, ending transcription early",
        "B": "The hairpin occludes the SD sequence, preventing 30S ribosomal subunit binding",
        "C": "The hairpin changes the codon usage of the downstream CDS",
        "D": "The hairpin causes RNase E to degrade the mRNA before translation can begin"
      },
      "answer": "B",
      "explanation": "Translation initiation requires the 30S ribosomal subunit to access the\nShine-Dalgarno sequence and base-pair with 16S rRNA. If the SD sequence is trapped\nin a stable hairpin, the ribosome cannot bind efficiently, so translation initiation\nis strongly reduced even if the SD sequence itself is strong.\n\nThis is why secondary structure near the start region (often approximated as the\nwindow around the start codon) is a major determinant of expression. Option A\ndescribes a terminator mechanism, which requires the right sequence context and\nlocation. Option C confuses sequence with structure. Option D is possible in some\ncases, but it does not best explain low protein together with high mRNA.\n"
    },
    {
      "slug": "steady-state-mrna-levels",
      "difficulty": "medium",
      "topic": "Reasoning about how synthesis and degradation rates jointly determine steady-state mRNA concentration",
      "question": "Two genes are transcribed at the same rate from identical promoters. Gene A's mRNA\nhas a half-life of 2 minutes, while Gene B's mRNA has a half-life of 20 minutes.\nBoth are measured at steady state.\n\nWhat is the expected relationship between their mRNA levels?\n",
      "choices": {
        "A": "Gene A has ~10x more mRNA because faster turnover means faster production",
        "B": "Gene B has ~10x more mRNA because it persists longer before being degraded",
        "C": "Both have equal mRNA levels because they have the same transcription rate",
        "D": "Gene A has more mRNA because short-lived mRNAs are preferentially stabilized by ribosomes"
      },
      "answer": "B",
      "explanation": "At steady state, mRNA abundance depends on both synthesis and degradation. If\ntranscription rates are equal, the mRNA with the longer half-life accumulates to a\nhigher steady-state level because it is removed more slowly.\n\nSince Gene B's mRNA half-life is 10x longer (20 min vs 2 min), Gene B is expected\nto have roughly 10x more mRNA at steady state. Option A reverses the relationship.\nOption C ignores degradation. Option D is not a general rule and does not explain\nthe stated comparison.\n"
    },
    {
      "slug": "codon-usage-expression-variation",
      "difficulty": "medium",
      "topic": "Understanding how synonymous codon choice affects protein expression independently of regulation",
      "question": "Two constructs encode the exact same GFP protein with identical promoters, RBS\nsequences, and terminators. The only difference is that Construct 1 uses codons\nabundant in E. coli, while Construct 2 uses rare codons throughout the CDS.\nConstruct 1 produces 100x more fluorescence.\n\nWhich statement best explains this result?\n",
      "choices": {
        "A": "Rare codons change the amino acid sequence, producing a nonfunctional protein",
        "B": "Rare codons slow ribosome elongation, reducing the rate of completed protein and potentially destabilizing the mRNA",
        "C": "Rare codons prevent transcription by blocking RNA polymerase",
        "D": "Rare codons change the Shine-Dalgarno sequence, blocking translation initiation"
      },
      "answer": "B",
      "explanation": "Synonymous codons encode the same amino acid sequence, so the protein identity is\nunchanged. However, codon choice can strongly affect expression by changing\ntranslation elongation kinetics. Rare codons are decoded by lower-abundance tRNAs,\nwhich can slow ribosomes and reduce the rate of completed protein production. In\nsome contexts, this can also contribute to reduced mRNA stability.\n\nOption A is incorrect because synonymous codons do not change the amino acid\nsequence. Option C is incorrect because RNA polymerase does not read codons during\ntranscription. Option D is incorrect because the Shine-Dalgarno sequence is in the\n5' UTR, not in the coding sequence.\n"
    },
    {
      "slug": "rbs-swap-what-changes",
      "difficulty": "medium",
      "topic": "Distinguishing which molecular properties change vs. remain constant when an RBS part is swapped",
      "question": "You are tuning expression of an enzyme in a metabolic pathway. You swap the RBS in\nyour construct from a strong RBS (high translation initiation rate) to a weak RBS\n(low translation initiation rate). The CDS, promoter, and terminator remain\nunchanged.\n\nWhich of the following changes as a result of this swap?\n",
      "choices": {
        "A": "The amino acid sequence of the enzyme",
        "B": "The metabolite concentrations in the pathway",
        "C": "The post-translational modifications of the enzyme",
        "D": "The enzymatic activity per molecule of protein"
      },
      "answer": "B",
      "explanation": "Swapping the RBS changes translation initiation rate, which changes how much enzyme\nis produced. Changing enzyme abundance can change pathway flux and therefore alter\nmetabolite concentrations.\n\nThe RBS is in the 5' UTR, so it does not change the coding sequence and therefore\ndoes not change the amino acid sequence (A). It also does not change the intrinsic\ncatalytic activity per molecule (D). Option C is not the expected consequence of an\nRBS swap in this context.\n"
    },
    {
      "slug": "transcriptional-vs-translational-control",
      "difficulty": "medium",
      "topic": "Classifying genetic parts by whether they act at the transcriptional or translational level",
      "question": "A student is debugging a construct that produces no detectable protein. They\nmeasure mRNA and find abundant transcript. They then inspect the 5' UTR and find\nthat the Shine-Dalgarno sequence has been deleted.\n\nAt which level of gene expression is the problem?\n",
      "choices": {
        "A": "Transcriptional — the promoter is not recruiting RNA polymerase",
        "B": "Translational — without an SD sequence, ribosomes cannot initiate translation on the mRNA",
        "C": "Post-translational — the protein is being degraded immediately after synthesis",
        "D": "Transcriptional — without the SD, RNA polymerase cannot terminate properly"
      },
      "answer": "B",
      "explanation": "Abundant mRNA indicates that transcription is occurring, so the promoter is working.\nThe Shine-Dalgarno sequence is needed for efficient ribosome recruitment to the mRNA.\nIf the SD sequence is deleted, translation initiation fails and little or no protein\nis produced despite abundant transcript.\n\nOption A is contradicted by the mRNA measurement. Option C would require protein to\nbe synthesized first. Option D confuses translation initiation signals with\ntranscription termination.\n"
    },
    {
      "slug": "same-protein-different-cds-expression",
      "difficulty": "medium",
      "topic": "Explaining why identical proteins can have different expression levels from different DNA encodings",
      "question": "A lab orders two synthetic genes encoding the identical lysozyme protein. Gene\nversion 1 is codon-optimized for E. coli. Gene version 2 uses the original\nbacteriophage codon usage. Both are cloned into the same vector with the same\npromoter, RBS, and terminator. Version 1 produces 50x more lysozyme.\n\nWhat is the BEST explanation for why two DNA sequences encoding the same protein\nyield such different expression levels?\n",
      "choices": {
        "A": "The different DNA sequences produce different amino acid sequences",
        "B": "The different codons result in different mRNA sequences, affecting secondary structure near the start codon and ribosome elongation rate",
        "C": "Codon-optimized genes have stronger promoters",
        "D": "The bacteriophage version has a weaker Shine-Dalgarno sequence"
      },
      "answer": "B",
      "explanation": "Synonymous codon changes alter the mRNA sequence without changing the amino acid\nsequence. That can change local mRNA secondary structure near the start codon (which\naffects translation initiation) and can also change elongation rate because codons\ndiffer in tRNA availability.\n\nThese effects can produce large expression differences even when promoter, RBS, and\nterminator are unchanged. Option A is incorrect because the proteins are stated to\nbe identical. Option C is incorrect because both constructs use the same promoter.\nOption D is incorrect because the RBS is in the 5' UTR and is the same in both\nconstructs.\n"
    },
    {
      "slug": "terminator-transcript-boundary",
      "difficulty": "medium",
      "topic": "Understanding how terminators define the 3' boundary of a transcript and prevent read-through",
      "question": "An operon contains Gene A followed by Gene B, each with its own RBS and start\ncodon. A strong Rho-independent terminator is placed between Gene A and Gene B.\nWhen the terminator is present, Gene B protein levels are very low. When the\nterminator is removed, Gene B is expressed at high levels from the same promoter\ndriving Gene A.\n\nWhat role is the terminator playing?\n",
      "choices": {
        "A": "The terminator is degrading Gene B's protein after it is translated",
        "B": "The terminator hairpin is blocking the ribosome from reaching Gene B's start codon",
        "C": "The terminator causes RNA polymerase to dissociate before it can transcribe Gene B, so Gene B has no mRNA",
        "D": "The terminator changes the reading frame of Gene B"
      },
      "answer": "C",
      "explanation": "A Rho-independent terminator forms a stable RNA hairpin followed by a U-rich tract,\nwhich promotes dissociation of RNA polymerase from the DNA template. When the\nterminator is placed between Gene A and Gene B, it stops transcription before Gene B\nis transcribed, so Gene B lacks mRNA and is not expressed.\n\nRemoving the terminator allows transcriptional read-through into Gene B, producing a\npolycistronic transcript from which Gene B can be translated using its own RBS.\nOption A confuses transcription with protein degradation. Option B confuses\ntermination with RBS occlusion. Option D has no mechanistic basis.\n"
    },
    {
      "slug": "rna-stability-expression-level",
      "difficulty": "medium",
      "topic": "Reasoning about how RNA degradation rate contributes to steady-state protein expression",
      "question": "You are engineering a biosensor whose output protein should drop quickly after an\ninducer signal disappears. You want the protein level to decay rapidly once\ntranscription stops.\n\nWhich design strategy would MOST help achieve fast signal decay?\n",
      "choices": {
        "A": "Use a very stable mRNA with no RNase E cleavage sites so that translation continues efficiently",
        "B": "Engineer the mRNA to contain RNase E cleavage sites and use a protein degradation tag, so both mRNA and protein turn over rapidly",
        "C": "Use the strongest possible RBS to maximize translation before the mRNA is degraded",
        "D": "Remove the terminator so that read-through transcription produces more mRNA"
      },
      "answer": "B",
      "explanation": "Fast signal decay requires rapid clearance of both the mRNA and the protein after\ntranscription stops. If the mRNA remains stable, translation can continue after the\ninducer is gone, which slows the response. Adding RNase E-sensitive features can\nshorten mRNA lifetime, and adding a protein degradation tag increases protein\nturnover.\n\nOption C can increase expression output but does not improve decay kinetics. Option D\nincreases transcript production, which opposes the design goal. Temporal control of\nexpression depends on both synthesis and degradation processes."
    }
  ],
  "genome_strain_and_chassis_constraints": [
    {
      "slug": "strain-vs-genotype-distinction",
      "difficulty": "medium",
      "topic": "Distinguishing between a strain name, the living cell population it refers to, and the genotype that describes it",
      "question": "A lab maintains a freezer stock labeled \"Mach1.\" A new student asks whether\n\"Mach1\" refers to the specific mutations (recA1398, endA1, etc.) or to the\npopulation of cells in the tube.\n\nWhich answer is most precise?\n",
      "choices": {
        "A": "Mach1 is the genotype because it lists every mutation present in the cells",
        "B": "Mach1 is a strain, a genetically homogeneous population derived from a single cell; the genotype is the list of mutations that distinguish it from its parent",
        "C": "Mach1 is a phenotype because it describes what the cells can do, not what DNA they carry",
        "D": "Mach1 is a composition because it specifies what proteins should be present"
      },
      "answer": "B",
      "explanation": "A strain is a population-level concept: a genetically uniform group of cells\ntraced to a single colony (or clone). The genotype is the set of genetic\ndifferences, usually described relative to a parent strain, that characterizes\nthat strain.\n\nOption A conflates the strain name with the genotype description. Option C\nconfuses genotype with phenotype. Option D confuses a living biological strain\nwith an abstract design specification.\n"
    },
    {
      "slug": "composition-specifies-vs-leaves-open",
      "difficulty": "medium",
      "topic": "Identifying what an abstract biological specification commits to and what it leaves unresolved",
      "question": "A Composition for a biosynthetic pathway specifies:\n- Host: E. coli\n- Proteins: LuxA, LuxB, LuxC, LuxD, LuxE\n\nA student assumes this Composition also determines the promoter driving each\ngene and whether the genes are on a plasmid or integrated into the chromosome.\nIs the student correct?\n",
      "choices": {
        "A": "Yes, because a Composition must specify all implementation details to be useful",
        "B": "No, because a Composition specifies the chassis and target proteins but deliberately leaves expression level, regulatory elements, codon usage, and genomic vs plasmid implementation unspecified",
        "C": "No, because a Composition specifies only the DNA sequence, not the proteins",
        "D": "Yes, because the host choice automatically determines promoters and gene location"
      },
      "answer": "B",
      "explanation": "A Composition is an abstract specification. It commits to what should be\npresent (for example, host and protein identities) but intentionally leaves\nopen many implementation decisions such as promoters, RBSs, copy number,\ncodon usage, and whether the build is plasmid-borne or chromosomally\nintegrated.\n\nThis separation is useful because the same Composition can be implemented in\nmultiple ways. Option A confuses an abstract specification with a complete\nbuild plan. Option C reverses the abstraction level. Option D incorrectly\nassumes host choice determines all downstream design choices.\n"
    },
    {
      "slug": "genotype-as-delta-from-parent",
      "difficulty": "medium",
      "topic": "Understanding why genotype descriptions emphasize changes relative to a parent strain",
      "question": "The genotype of Mach1 is written as:\n\n<pre>str. W deltarecA1398 endA1 fhuA phi80delta(lac)M15 delta(lac)X74 hsdR(rK- mK+)</pre>\n\nA student argues it would be simpler to store the complete genome sequence\ninstead of these cryptic delta annotations. What is the main reason genotypes\nare often expressed as changes from a parent strain?\n",
      "choices": {
        "A": "Delta notation is mainly used to reduce file size so the genotype fits in a database field",
        "B": "Relative notation highlights the mutations that matter for strain behavior, while a full genome sequence hides those differences among millions of unchanged bases",
        "C": "The complete genome of E. coli is unknown, so delta notation is the only option",
        "D": "Delta notation is legally required for genetically modified organisms"
      },
      "answer": "B",
      "explanation": "Relative genotype notation is useful because it emphasizes the changes that\ndistinguish the strain from its parent and often explain its engineering\nproperties. A complete genome sequence contains far more information than is\nusually needed for routine strain identity and engineering context, and the\nfew relevant differences are hard to spot without a comparison.\n\nOption A treats the notation as a storage trick rather than an information and\ninterpretation tool. Option C is false. Option D is fabricated.\n"
    },
    {
      "slug": "antibiotic-selection-compatibility",
      "difficulty": "medium",
      "topic": "Reasoning about why antibiotic selection depends on compatibility between host background and vector marker",
      "question": "A researcher wants to transform a plasmid carrying a kanamycin resistance gene\n(KanR) into a strain that already has a chromosomal KanR insertion from a\nprevious engineering step. They plan to select transformants on kanamycin\nplates.\n\nWhat is wrong with this plan?\n",
      "choices": {
        "A": "Nothing, because extra copies of KanR will make transformants grow much faster than non-transformants",
        "B": "The host already survives on kanamycin, so both transformants and non-transformants form colonies and the selection cannot distinguish them",
        "C": "Two copies of KanR are generally lethal because resistance genes are highly toxic when overexpressed",
        "D": "Kanamycin resistance works only from plasmids, not from chromosomal insertions"
      },
      "answer": "B",
      "explanation": "Antibiotic selection works only if cells lacking the plasmid are sensitive to\nthe antibiotic. If the host strain already carries a functional chromosomal\nKanR gene, untransformed cells also survive on kanamycin, so the plate no\nlonger selects for plasmid uptake.\n\nThe practical fix is to use a different selectable marker that the host does\nnot already carry. Option A misunderstands the purpose of selection. Option C\nis not generally true. Option D is factually incorrect.\n"
    },
    {
      "slug": "same-composition-different-genotypes",
      "difficulty": "medium",
      "topic": "Understanding how one abstract specification can be implemented by multiple distinct genotypes",
      "question": "Two labs independently implement the same Composition:\n- Host: E. coli\n- Proteins: GFP, LacI\n\nLab A puts both genes on a high-copy plasmid with strong promoters.\nLab B integrates both genes into the chromosome under weak promoters with\ncodon optimization for E. coli.\n\nBoth labs produce cells that express GFP and LacI. How do their results relate\nto the Composition?\n",
      "choices": {
        "A": "Only Lab A implements the Composition correctly because plasmids are the standard method",
        "B": "Neither lab implements the Composition because they used different engineering strategies",
        "C": "Both satisfy the Composition, but they created different genotypes and likely different phenotypes",
        "D": "Both have the same genotype because they started from the same Composition"
      },
      "answer": "C",
      "explanation": "A Composition specifies what is required at a high level (here, host and\nprotein identities), not the detailed implementation strategy. Both labs can\nsatisfy the same Composition while making different choices about promoter\nstrength, copy number, codon usage, and genomic location.\n\nThose choices produce different DNA architectures and therefore different\ngenotypes, and they often produce different phenotypes such as expression\nlevel, growth rate, and burden. Option A inserts a preference not stated by\nthe Composition. Option B misunderstands what it means to satisfy a spec.\nOption D confuses abstract specification with concrete genotype.\n"
    },
    {
      "slug": "chassis-constrains-design",
      "difficulty": "medium",
      "topic": "Reasoning about how chassis choice constrains which regulatory elements and expression mechanisms are valid",
      "question": "A researcher designs a gene expression cassette using an E. coli sigma-70\npromoter and a strong E. coli ribosome binding site. They then move the same\ncassette into Saccharomyces cerevisiae (yeast) without any modifications.\n\nWhat is most likely to happen?\n",
      "choices": {
        "A": "The gene will express normally because promoters and RBS sequences are universal across organisms",
        "B": "The gene will express at a lower level due to codon usage differences, but the bacterial promoter and RBS will still function",
        "C": "The gene will likely fail to express because yeast does not use bacterial sigma-70 promoters or Shine-Dalgarno-based translation initiation",
        "D": "The gene will express but produce a nonfunctional protein because yeast ribosomes translate too fast"
      },
      "answer": "C",
      "explanation": "Chassis choice constrains what regulatory parts are valid. Yeast and bacteria\nuse different transcription and translation initiation machinery. Yeast RNA\npolymerase does not recognize bacterial sigma-70 promoters, and yeast\ntranslation initiation does not rely on bacterial Shine-Dalgarno pairing.\n\nA yeast-compatible implementation would require yeast regulatory elements,\nincluding an appropriate promoter and translation initiation context. Option A\nassumes universality that does not exist. Option B underestimates the problem.\nOption D proposes an incorrect mechanism.\n"
    },
    {
      "slug": "what-makes-a-strain-engineerable",
      "difficulty": "medium",
      "topic": "Identifying host strain features that improve routine plasmid cloning and DNA handling",
      "question": "Mach1 carries several mutations including recA1398 (defective\nrecombination), endA1 (defective endonuclease), and hsdR(rK- mK+)\n(does not restrict incoming DNA but still methylates DNA).\n\nWhy are these mutations helpful for plasmid-based genetic engineering,\nrather than being random changes?\n",
      "choices": {
        "A": "They primarily increase growth rate, which is the main goal of cloning strains",
        "B": "They reduce host activities that would otherwise rearrange, degrade, or restrict foreign DNA",
        "C": "They are auxotrophic markers used for selection on minimal media",
        "D": "They allow cells to survive higher temperatures during heat shock"
      },
      "answer": "B",
      "explanation": "Cloning strains are engineered to make foreign DNA easier to introduce,\nmaintain, and recover. In this example, recA defects reduce homologous\nrecombination that can rearrange repeated sequences, endA1 improves plasmid DNA\nquality by reducing nuclease activity, and hsdR defects reduce restriction of\nincoming DNA.\n\nThese are deliberate engineering traits for molecular cloning workflows.\nOption A is not the main purpose. Option C confuses cloning-strain features\nwith nutritional markers. Option D confuses genotype with protocol details.\n"
    },
    {
      "slug": "genotype-tokens-and-dna-changes",
      "difficulty": "medium",
      "topic": "Interpreting genotype notation tokens and connecting notation to physical DNA changes",
      "question": "A genotype includes the token \"delta(lac)X74.\" A student interprets this as\nmeaning the lac region is overexpressed because \"delta\" sounds like it could\nmean \"enhanced.\"\n\nWhat does the delta symbol indicate in genotype notation, and what is the\nphysical consequence?\n",
      "choices": {
        "A": "Delta means duplication, so there are two copies of the lac region",
        "B": "Delta means deletion, so the designated lac region has been physically removed from the chromosome",
        "C": "Delta means translocation, so the lac region moved to a different chromosomal location",
        "D": "Delta means promoter replacement, so lac is now controlled by a different promoter"
      },
      "answer": "B",
      "explanation": "In genotype notation, delta denotes a deletion. The named region has been\nremoved from the chromosome, so the strain lacks that DNA segment and cannot\nproduce whatever gene products depend on the deleted sequence.\n\nOption A invents a meaning for delta. Option C describes a translocation, not\na deletion. Option D describes a regulatory edit that would be represented\nwith different notation.\n"
    },
    {
      "slug": "context-changes-design-outcomes",
      "difficulty": "medium",
      "topic": "Reasoning about how the same cassette can produce different outcomes in different genomic contexts",
      "question": "A researcher characterizes a promoter-RBS-GFP cassette on a high-copy plasmid\n(about 100 copies per cell) in E. coli strain DH10B and measures strong\nfluorescence. They then integrate the identical cassette as a single\nchromosomal copy in the same strain. Fluorescence drops by about 100-fold.\n\nWhat is the best explanation?\n",
      "choices": {
        "A": "Integration usually mutates the GFP coding sequence, so fluorescence drops because the protein is damaged",
        "B": "Gene copy number changed from about 100 templates to one, so total mRNA and protein output per cell drops substantially",
        "C": "Chromosomal DNA cannot be transcribed efficiently by RNA polymerase",
        "D": "The promoter works only on circular plasmids and not in the chromosome"
      },
      "answer": "B",
      "explanation": "The cassette sequence is the same, but the genomic context changed. Copy number\nis a major contextual variable. A high-copy plasmid provides many templates for\ntranscription, while a single chromosomal insertion provides only one. With far\nfewer transcription templates, total mRNA and protein output usually drops.\n\nThis is a core example of why identical parts can produce different phenotypes\nin different contexts. Option A is not the expected explanation. Option C is\nfalse. Option D is false.\n"
    },
    {
      "slug": "dna-string-vs-composition-information",
      "difficulty": "medium",
      "topic": "Identifying what semantic design information is missing from a raw DNA sequence string",
      "question": "A collaborator sends you a 3,000 bp DNA string with no annotation. You know it\nencodes a gene, but you do not know what organism it was designed for or how it\nshould be used. Compared to receiving a Composition object that specifies\n\"Host: E. coli, Protein: LuxA\", what information are you missing from the raw\nDNA string alone?\n",
      "choices": {
        "A": "Nothing, because the DNA string contains all necessary information if you translate it",
        "B": "You are missing high-level intent and context such as the intended host and protein identity, and you also do not know the intended implementation context from sequence alone",
        "C": "You are missing only the host organism, because the correct protein can always be recovered by translating all six reading frames",
        "D": "A raw DNA string contains strictly more useful information than a Composition, so nothing important is missing"
      },
      "answer": "B",
      "explanation": "A raw DNA string contains sequence-level information, but it does not encode the\nintended design semantics in a directly interpretable way. Without annotation or\nadditional context, you may not know the intended host, the intended protein\nidentity, the correct coding frame and start site, or how the sequence fits into\na larger design plan.\n\nA Composition explicitly provides high-level design intent such as host and\ntarget protein identity. Option A and C overstate what can be inferred from a\nbare sequence alone. Option D misses the distinction between low-level sequence\ndetail and high-level design meaning."
    }
  ],
  "targeting_rules_and_design_logic": [
    {
      "slug": "reverse-complement-basic",
      "difficulty": "medium",
      "topic": "Applying a sequence transformation to make hidden information visible",
      "question": "What is the reverse complement of the DNA sequence:\n\n<pre>ATCGAGA</pre>\n",
      "choices": {
        "A": "<pre>3'-ATCGAGA-5'</pre>",
        "B": "<pre>5'-TCTCGAT-3'</pre>",
        "C": "<pre>ATCGAGA</pre>",
        "D": "<pre>TAGCTCT</pre>"
      },
      "answer": "B",
      "explanation": "The reverse complement is found in two steps. First, take the complement of\neach base (A↔T, C↔G), so <pre>ATCGAGA</pre> becomes <pre>TAGCTCT</pre>.\nThen reverse that string so the opposite strand is written in the standard\n5'→3' orientation, giving <pre>TCTCGAT</pre>.\n\nOption D is the complement only (not reversed). Option A is the original\nsequence with flipped end labels, not the reverse complement. Option C is the\nunchanged input.\n"
    },
    {
      "slug": "pam-constrains-editing-sites",
      "difficulty": "medium",
      "topic": "Understanding how a recognition rule limits where a tool can act on a sequence",
      "question": "A Cas9 CRISPR system requires an NGG PAM adjacent to the target site.\nA researcher wants to knock out a gene but finds no NGG motif within the\nfirst 200 bp of the coding sequence on either strand.\n\nWhat is the most accurate conclusion?\n",
      "choices": {
        "A": "Cas9 cannot target this region; a different CRISPR system or a target further downstream must be used",
        "B": "The researcher should add an NGG sequence to the gene before targeting it",
        "C": "Cas9 can still target the region if the guide RNA is made longer than 20 nt",
        "D": "The PAM requirement only applies to the forward strand, so checking one strand is sufficient"
      },
      "answer": "A",
      "explanation": "The PAM is a fixed requirement of the Cas9 protein and must be present in the\ngenomic DNA adjacent to the target. Without an NGG on either strand, Cas9 has\nno valid binding site in that region.\n\nOption B is not a practical solution to the targeting problem as stated.\nOption C is wrong because guide length does not override the PAM requirement.\nOption D is wrong because DNA is double-stranded and a valid PAM can be on\neither strand.\n"
    },
    {
      "slug": "protospacer-extraction-indexing",
      "difficulty": "medium",
      "topic": "Translating a biological positional rule into correct sequence indices",
      "question": "A function searches a target DNA string for the Cas9 PAM and extracts\nthe 20 bp protospacer. Given:\n\n<python>\ntarget = 'ATGCCCTAGATGCCTGGCTCAGAAACCTGCC'\npam_index = target.find('GG', 21)   # returns 24\n</python>\n\nWhich slice correctly extracts the protospacer?\n",
      "choices": {
        "A": "target[pam_index - 21 : pam_index - 1]",
        "B": "target[pam_index - 20 : pam_index]",
        "C": "target[pam_index - 20 : pam_index - 1]",
        "D": "target[pam_index - 21 : pam_index]"
      },
      "answer": "A",
      "explanation": "For Cas9, the PAM is NGG and the N is not part of the protospacer. If\n<python>pam_index</python> points to the first G of GG, then the N is at\n<python>pam_index - 1</python>. The 20 bp protospacer ends immediately before\nthat N.\n\nTherefore the protospacer spans indices <python>pam_index - 21</python>\nthrough <python>pam_index - 2</python> inclusive, which in Python slicing is\n<python>target[pam_index - 21 : pam_index - 1]</python>.\n\nOption B includes the PAM-adjacent N. Option C is only 19 bp. Option D is 21\nbp and also includes the N.\n"
    },
    {
      "slug": "off-by-one-consequence",
      "difficulty": "medium",
      "topic": "Reasoning about how an indexing error propagates into a biological design failure",
      "question": "A student's gRNA design function extracts the protospacer as:\n\n<python>\nprotospacer = target[pam_index - 20 : pam_index]\n</python>\n\ninstead of the correct <python>target[pam_index - 21 : pam_index - 1]</python>.\nThe resulting guide RNA is synthesized and tested. What is the most likely\noutcome?\n",
      "choices": {
        "A": "The guide targets a shifted position that overlaps the PAM by one base, likely reducing or eliminating editing",
        "B": "The guide will work identically because one base difference is tolerated",
        "C": "The function will raise an IndexError at runtime",
        "D": "The guide RNA will be 19 bp instead of 20 bp"
      },
      "answer": "A",
      "explanation": "The incorrect slice still returns 20 bases, but it includes the N of the NGG\nPAM and omits the first base of the true protospacer. That shifts the guide by\none base toward the PAM.\n\nCas9 targeting depends on the correct protospacer sequence adjacent to (not\noverlapping) the PAM, so this shift will often severely reduce or eliminate\nediting. Option C is wrong because the slice is syntactically valid. Option D\nis wrong because the slice length is still 20.\n"
    },
    {
      "slug": "both-strands-must-be-checked",
      "difficulty": "medium",
      "topic": "Recognizing when a search must consider complementary representations of the same data",
      "question": "A function searches for Cas9 PAM sites on a target gene:\n\n<python>\ndef find_pam(target):\n    return target.find('GG', 21)\n</python>\n\nIt returns -1 for a known targetable gene. A colleague points out the\nerror. What did the function fail to do?\n",
      "choices": {
        "A": "Search the reverse complement of the target for GG on the opposite strand",
        "B": "Search for 'CC' instead, since that is the complement of GG",
        "C": "Use a regular expression instead of .find()",
        "D": "Search from position 0 instead of position 21"
      },
      "answer": "A",
      "explanation": "DNA is double-stranded, so a valid PAM can occur on either strand. If the\nforward strand search finds no valid GG in the required position range, a PAM\nmay still exist on the opposite strand and will be found by searching the\nreverse complement.\n\nOption B is not equivalent, because simply searching for <python>'CC'</python>\non the forward strand does not preserve the correct spatial relationship\nbetween PAM and protospacer. Option C does not fix the strand-coverage error.\nOption D changes the search window but not the missing-strand logic.\n"
    },
    {
      "slug": "guide-rna-from-protospacer",
      "difficulty": "medium",
      "topic": "Tracing a data transformation through multiple encoding steps",
      "question": "Given a DNA target with protospacer <pre>CATCGCCGCAGCGGTTTCAG</pre> adjacent to\nan NGG PAM, a function must produce the guide RNA. The gRNA scaffold is a\nconstant string appended after the targeting sequence. Which step correctly\nconverts the protospacer to the targeting portion of the gRNA?\n",
      "choices": {
        "A": "Replace every T in the protospacer with U to produce the RNA version of the same sequence",
        "B": "Take the reverse complement of the protospacer and then replace T with U",
        "C": "Translate the protospacer into amino acids using the genetic code",
        "D": "Reverse the protospacer string without complementing, then replace T with U"
      },
      "answer": "A",
      "explanation": "In this convention, the protospacer is the DNA sequence corresponding to the\nguide-targeting region. To generate the gRNA targeting sequence, convert that\nDNA sequence to RNA by replacing T with U.\n\nOption B incorrectly reverse-complements the protospacer. Option C confuses\nguide design with protein translation. Option D reverses the sequence without\nbiological justification.\n"
    },
    {
      "slug": "cas12a-vs-cas9-rules",
      "difficulty": "medium",
      "topic": "Recognizing how changing a system's rules changes the algorithm that implements it",
      "question": "Cas9 uses an NGG PAM on the 3' side of the protospacer, while Cas12a\nuses a TTTV PAM on the 5' side. A student has a working Cas9 gRNA\ndesign function. Which change is necessary to adapt it for Cas12a?\n",
      "choices": {
        "A": "Search for TTTV instead of NGG, and extract the protospacer downstream (3') of the PAM instead of upstream",
        "B": "Simply replace the string 'GG' with 'TTTV' in the search; the protospacer extraction stays the same",
        "C": "Keep the same PAM search but reverse complement the entire target before running the function",
        "D": "Use the same function but extend the protospacer from 20 bp to 24 bp"
      },
      "answer": "A",
      "explanation": "The key change is not just the PAM motif but the PAM position relative to the\nprotospacer. Cas12a uses a PAM on the 5' side of the target sequence, so the\nextraction direction changes compared with Cas9.\n\nOption B changes only the motif and leaves the geometry wrong. Option C does\nnot solve the changed PAM-side rule. Option D changes length without fixing\nextraction logic.\n"
    },
    {
      "slug": "no-valid-pam-error-handling",
      "difficulty": "medium",
      "topic": "Deciding what a function should do when a required precondition is not met",
      "question": "A gRNA design function searches for a PAM in the target sequence but\nfinds none. Which is the best way to handle this case?\n",
      "choices": {
        "A": "Raise a ValueError with a message explaining that no valid PAM was found",
        "B": "Return None silently so the caller can check for it",
        "C": "Return a gRNA using positions 0–19 as a default protospacer",
        "D": "Print a warning message and return an empty string"
      },
      "answer": "A",
      "explanation": "If no PAM is present, the biological precondition for design is not met and\nthe function cannot produce a valid guide. Raising a <python>ValueError</python>\nwith a clear message makes the failure explicit and prevents downstream code\nfrom using an invalid design.\n\nOption B can be made to work in some coding styles, but silent return values\nare easy to misuse. Option C returns an invalid design. Option D mixes error\nreporting with ambiguous return values.\n"
    },
    {
      "slug": "parameterizing-pam-rule",
      "difficulty": "medium",
      "topic": "Designing a function interface that accommodates varying biological rules",
      "question": "A lab uses both Cas9 (PAM = NGG) and Cas12a (PAM = TTTV) in different\nexperiments. A developer wants a single gRNA design function that works\nfor both systems. What is the best approach?\n",
      "choices": {
        "A": "Accept the PAM pattern, protospacer length, and PAM-side (5' or 3') as parameters",
        "B": "Hard-code both PAM rules with an if/else and a system_name string parameter",
        "C": "Write two completely separate functions with no shared code",
        "D": "Always search for both PAMs and return whichever match is found first"
      },
      "answer": "A",
      "explanation": "Parameterizing the PAM pattern, protospacer length, and PAM-side makes the\nfunction extensible to multiple CRISPR systems without rewriting the core\nlogic.\n\nOption B can work for a small number of systems but scales poorly. Option C\nduplicates logic. Option D ignores the fact that different systems use\ndifferent guide designs and must be selected intentionally.\n"
    },
    {
      "slug": "strand-orientation-and-protospacer",
      "difficulty": "medium",
      "topic": "Reasoning about how strand orientation determines which 20 bp sequence is the protospacer",
      "question": "A target gene's forward strand (5'→3') contains:\n\n<pre>\n...ACGTTGACCGATCCTGAAGG TCA...\n                     ^^^\n                     NGG (PAM)\n</pre>\n\nThe PAM on the forward strand is <pre>AGG</pre>. A colleague says the\nprotospacer must always be taken from the reverse strand.\n\nWhich statement is correct?\n",
      "choices": {
        "A": "The protospacer is the 20 bp immediately upstream (5') of the PAM on the same strand where the PAM is found, so in this case it is read from the forward strand",
        "B": "The protospacer always comes from the reverse strand regardless of which strand contains the PAM",
        "C": "Either strand gives the same protospacer because DNA is double-stranded",
        "D": "The protospacer should be chosen from whichever strand has higher GC content"
      },
      "answer": "A",
      "explanation": "For Cas9, the protospacer is defined relative to the PAM location: it is the\n20 bp sequence immediately upstream (5') of the NGG PAM on the same strand in\nwhich the PAM is identified. If the PAM is on the forward strand, the\nprotospacer is read from the forward strand. If the PAM is on the reverse\nstrand, the protospacer is read from the reverse strand.\n\nOption B is wrong because strand choice depends on PAM location. Option C is\nwrong because the two strands are complementary, not identical. Option D is\nunrelated to the targeting rule."
    }
  ],
  "transcription_and_translation_control_elements": [
    {
      "slug": "promoter-elements-and-transcription-rate",
      "difficulty": "medium",
      "topic": "Understanding how promoter sequence features control transcription initiation rate",
      "question": "In E. coli, sigma-70 recognizes conserved promoter elements. A researcher\nmutates the -10 box from <pre>TATAAT</pre> to <pre>TGTAAT</pre> and observes a\nlarge drop in mRNA production.\n\nWhich explanation best accounts for this result?\n",
      "choices": {
        "A": "The -10 box is a sigma-factor recognition element for transcription initiation, so mutating it reduces RNA polymerase recruitment/initiation",
        "B": "The -10 box is the ribosome binding site, so mutating it prevents translation",
        "C": "The mutation introduced a premature stop codon in the mRNA",
        "D": "The -10 box controls mRNA degradation rate rather than transcription initiation"
      },
      "answer": "A",
      "explanation": "The -10 and -35 promoter elements are recognized by sigma factor during\ntranscription initiation. Changing the -10 sequence away from the sigma-70\nconsensus weakens promoter recognition and reduces transcription initiation,\nwhich lowers mRNA production.\n\nOption B confuses promoter DNA with the ribosome binding site in the mRNA.\nOption C is incorrect because the -10 box is upstream of the coding region and\nis not translated. Option D is incorrect because the -10 box is a promoter\nelement, not an RNA degradation signal.\n"
    },
    {
      "slug": "shine-dalgarno-and-translation-initiation",
      "difficulty": "medium",
      "topic": "Reasoning about how base-pair complementarity determines translation initiation strength",
      "question": "The Shine-Dalgarno (SD) sequence in an mRNA base-pairs with the 3' end of\n16S rRNA in the ribosome. If one synthetic 5' UTR has SD sequence\n<pre>AGGAGG</pre> and another has <pre>AAGAAG</pre>, which construct is expected to\nhave the higher translation initiation rate, and why?\n",
      "choices": {
        "A": "AGGAGG, because it has stronger complementarity to the 16S rRNA anti-SD sequence",
        "B": "AAGAAG, because more A residues form stronger hydrogen bonds",
        "C": "Both will have equal translation rates because only the start codon matters",
        "D": "AGGAGG, because higher GC content always increases expression by stabilizing the full mRNA"
      },
      "answer": "A",
      "explanation": "Translation initiation in bacteria is strongly influenced by base-pairing\nbetween the mRNA Shine-Dalgarno sequence and the anti-Shine-Dalgarno region of\n16S rRNA. <pre>AGGAGG</pre> provides stronger complementarity than\n<pre>AAGAAG</pre>, so it is expected to recruit ribosomes more effectively.\n\nOption B is incorrect because A-U base pairs are weaker than G-C base pairs.\nOption C ignores the role of the SD sequence in bacterial translation\ninitiation. Option D overgeneralizes GC content and does not identify the key\nmechanism being tested here.\n"
    },
    {
      "slug": "hairpin-occlusion-of-rbs",
      "difficulty": "medium",
      "topic": "Understanding how local RNA secondary structure can mask a functional binding site",
      "question": "An mRNA has a strong Shine-Dalgarno sequence (<pre>AGGAGG</pre>) upstream of a new\ncoding sequence. Despite the strong SD, almost no protein is produced. A\nsecondary-structure prediction shows a stable hairpin that includes the SD\nregion.\n\nWhat is the most likely explanation?\n",
      "choices": {
        "A": "The hairpin sequesters the SD in a double-stranded stem, preventing ribosome binding",
        "B": "The hairpin blocks RNA polymerase from transcribing past the RBS",
        "C": "The hairpin causes the ribosome to translate in the wrong reading frame",
        "D": "The hairpin directly degrades the mRNA before translation can begin"
      },
      "answer": "A",
      "explanation": "If the Shine-Dalgarno sequence is base-paired within a hairpin stem, it is not\naccessible for pairing with 16S rRNA. Ribosome binding is therefore impaired,\nand translation initiation drops sharply. This is RBS occlusion.\n\nOption B is incorrect because the mechanism described is translation-initiation\nfailure, not transcription blockage. Option C is incorrect because hairpins do\nnot by themselves shift the reading frame. Option D is not the best explanation\nfor the evidence given, which directly points to occlusion of the SD site.\n"
    },
    {
      "slug": "context-dependent-rbs-performance",
      "difficulty": "medium",
      "topic": "Recognizing that RBS performance depends on local sequence context",
      "question": "A standard BioBrick RBS part is reported to produce high GFP expression. When\nthe same RBS is placed upstream of a different gene, expression drops to near\nzero. What is the most plausible explanation?\n",
      "choices": {
        "A": "The new CDS forms local secondary structure with the RBS region, occluding the Shine-Dalgarno site",
        "B": "The RBS must have mutated during cloning",
        "C": "BioBrick RBS parts only function with GFP",
        "D": "The new gene product is toxic, so the RBS no longer functions"
      },
      "answer": "A",
      "explanation": "RBS behavior is context-dependent. The sequence at the beginning of the CDS can\npair with bases in the 5' UTR and create local RNA secondary structure that\noccludes the Shine-Dalgarno sequence or start region, reducing translation\ninitiation.\n\nOption B is possible in principle but is not the most plausible explanation for\na common, reproducible context effect. Option C is false. Option D describes a\ndifferent biological problem and does not explain why the same RBS performs\ndifferently across constructs.\n"
    },
    {
      "slug": "sd-spacing-affects-expression",
      "difficulty": "medium",
      "topic": "Understanding how spacing between translation control elements affects initiation efficiency",
      "question": "An RBS design tool reports that the optimal spacing between the\nShine-Dalgarno sequence and the start codon (<pre>ATG</pre>) is 7 nucleotides for\na given system. If a designer accidentally inserts 2 extra bases between the\nSD and the ATG, what is the expected effect?\n",
      "choices": {
        "A": "Translation initiation rate will decrease because the ribosome is mispositioned relative to the start codon",
        "B": "Translation will be unaffected because the SD sequence itself is unchanged",
        "C": "Transcription will fail because promoter spacing is disrupted",
        "D": "The protein will include two extra amino acids at the N-terminus"
      },
      "answer": "A",
      "explanation": "The spacing between the Shine-Dalgarno sequence and the start codon affects how\nthe ribosome is positioned for start-codon recognition. Adding 2 extra bases\ncan misalign the start codon relative to the ribosome and reduce translation\ninitiation efficiency.\n\nOption B ignores the importance of SD-to-start spacing. Option C confuses\ntranslation-initiation spacing with promoter architecture. Option D is wrong\nbecause these extra bases are in the 5' UTR, not necessarily in the coding\nsequence.\n"
    },
    {
      "slug": "secondary-structure-near-start-codon",
      "difficulty": "medium",
      "topic": "Identifying which local sequence region most strongly predicts expression differences",
      "question": "In a study of 154 GFP variants with different codon usage but identical\nprotein sequences, researchers observed a large range in fluorescence. Which\nsequence region's secondary structure best predicted expression level?\n",
      "choices": {
        "A": "The region from -4 to +37 relative to the start codon",
        "B": "The full-length mRNA secondary structure",
        "C": "The last 50 bp of the coding sequence near the stop codon",
        "D": "The promoter region from -35 to +1"
      },
      "answer": "A",
      "explanation": "Expression differences among synonymous variants are often best predicted by\nlocal RNA structure near the translation start region, especially around the\nRBS and start codon. In this case, the region from approximately -4 to +37 was\nthe strongest predictor.\n\nOption B is less predictive than the local start-region structure in this type\nof dataset. Option C focuses on a region that is not the dominant determinant\nof initiation efficiency. Option D cannot explain the variation because the\npromoter is the same across the constructs.\n"
    },
    {
      "slug": "operon-structure-and-transcription",
      "difficulty": "medium",
      "topic": "Reasoning about how shared transcriptional control affects multiple genes in an operon",
      "question": "In an operon design, three genes (A, B, C) are placed under a single promoter\nand a single terminator, and each gene has its own RBS. If the promoter is\nrepressed, what happens to expression of genes A, B, and C?\n",
      "choices": {
        "A": "All three genes lose transcription because they share one promoter",
        "B": "Only gene A is affected because it is closest to the promoter",
        "C": "Gene C is affected first because the terminator blocks it",
        "D": "Each gene is affected independently because each has its own RBS"
      },
      "answer": "A",
      "explanation": "A single promoter drives transcription of the operon mRNA. If that promoter is\nrepressed, the polycistronic transcript is not produced, so none of the genes\nhas mRNA available for translation.\n\nThe separate RBS elements allow independent translation initiation from a\nshared transcript, but they do not bypass promoter-level transcriptional\ncontrol. Option B misunderstands operon transcription. Option C misstates\nterminator function. Option D confuses transcriptional and translational\ncontrol.\n"
    },
    {
      "slug": "promoter-vs-rbs-vs-codon-effects",
      "difficulty": "medium",
      "topic": "Distinguishing which sequence-level control element to modify to tune expression without changing protein identity",
      "question": "A designer wants to reduce expression of a protein by about 10-fold without\nchanging the protein sequence. Which modification targets the correct level of\ncontrol?\n",
      "choices": {
        "A": "Replace the RBS with a weaker Shine-Dalgarno sequence",
        "B": "Change the stop codon from <pre>TAA</pre> to <pre>TGA</pre>",
        "C": "Remove the plasmid origin of replication",
        "D": "Add a His-tag to the protein C-terminus"
      },
      "answer": "A",
      "explanation": "Replacing the RBS with a weaker Shine-Dalgarno sequence directly reduces\ntranslation initiation efficiency and can lower protein output without changing\nthe encoded protein sequence.\n\nOption B usually preserves termination and does not provide controlled tuning of\nexpression. Option C disrupts plasmid maintenance rather than tuning\nexpression. Option D changes the protein sequence and violates the design\nconstraint.\n"
    },
    {
      "slug": "rbs-does-not-change-protein",
      "difficulty": "medium",
      "topic": "Distinguishing sequence changes that alter expression level from those that alter protein sequence",
      "question": "A Composition specifies that protein X should be expressed in E. coli. An\nengineer creates two constructs with different RBS parts but identical CDS\nsequences. Which statement is true?\n",
      "choices": {
        "A": "They produce the same protein at different expression levels",
        "B": "They produce different proteins because the RBS is translated",
        "C": "They have different mRNA sequences and different protein sequences",
        "D": "They will have identical expression levels because the CDS is the same"
      },
      "answer": "A",
      "explanation": "The RBS is located in the 5' UTR and is not translated into protein. Changing\nthe RBS changes translation initiation efficiency (and therefore expression\nlevel), but the protein sequence remains determined by the CDS.\n\nOption B is incorrect because the RBS is not part of the coding region. Option\nC is only partly correct because the mRNA sequence changes but the protein\nsequence does not. Option D ignores the role of the RBS in controlling\nexpression.\n"
    },
    {
      "slug": "construct-parts-interaction",
      "difficulty": "medium",
      "topic": "Reasoning about how control elements and coding sequence interact in a construct",
      "question": "A genetic construct has the layout promoter → RBS → CDS → terminator. A\ndesigner tests 5 different RBS parts with one CDS and observes a 100-fold\nspread in expression. When the same 5 RBS parts are tested with a different\nCDS, the ranking of the RBS parts changes.\n\nWhat does this result demonstrate?\n",
      "choices": {
        "A": "RBS performance depends on downstream CDS context, likely through local RNA secondary structure at the RBS-CDS junction",
        "B": "The CDS modifies the RBS DNA sequence during replication",
        "C": "The ranking change is best explained by day-to-day experimental noise",
        "D": "RBS parts have fixed intrinsic expression levels that are independent of context"
      },
      "answer": "A",
      "explanation": "If the ranking of RBS parts changes when only the CDS changes, then RBS\nperformance is not context-free. A common mechanism is local RNA secondary\nstructure involving the RBS and the beginning of the CDS, which changes access\nto the Shine-Dalgarno sequence and start region.\n\nOption B proposes an implausible mechanism. Option C does not match the clear,\nsystematic context-dependent pattern. Option D is contradicted by the observed\nranking change."
    }
  ],
  "construction_methods_and_constraints": [
    {
      "slug": "pcr-primer-3prime-matching",
      "difficulty": "medium",
      "topic": "Understanding why only the primer 3' annealing region must match to initiate PCR synthesis",
      "question": "In PCR, a primer is designed with a 20 bp 3' annealing region that matches the\ntemplate and a 15 bp 5' tail that adds a new sequence.\n\nWhy does the 5' tail not need to match the template?\n",
      "choices": {
        "A": "DNA polymerase extends from the primer's base-paired 3' end, so only the 3' annealing region must match the template to initiate synthesis",
        "B": "The 5' tail is removed by an exonuclease during the first PCR cycle",
        "C": "The 5' tail anneals to the opposite strand of the template during the first cycle",
        "D": "Both ends must match the template, but 5' mismatches are simply tolerated by polymerase"
      },
      "answer": "A",
      "explanation": "DNA polymerase requires a base-paired primer 3' hydroxyl to begin extension.\nThe primer's 3' annealing region provides that base-paired starting point. The\n5' tail can remain unmatched in the first cycle and is still copied into the\nproduct as polymerase extends from the 3' end.\n\nIn later cycles, that tail sequence is present in the PCR product and can serve\nas part of the template. Option B is incorrect because the tail is not removed.\nOption C is incorrect because the tail is not required to anneal elsewhere.\nOption D is incorrect because the 5' tail is not just a tolerated mismatch; it\nis intentionally non-annealing sequence.\n"
    },
    {
      "slug": "gibson-assembly-homology",
      "difficulty": "medium",
      "topic": "Understanding how terminal homology enables fragment joining without restriction sites",
      "question": "In Gibson assembly, two DNA fragments are designed with about 20 bp of\nidentical sequence at the ends that should connect.\n\nWhat is the role of this shared homology?\n",
      "choices": {
        "A": "After exonuclease creates single-stranded overhangs, the homologous regions anneal and align the fragments for repair and ligation",
        "B": "The homologous regions are recognized by a restriction enzyme that cuts and ligates them",
        "C": "The shared sequence serves as a PCR primer that amplifies the joined product directly in the Gibson reaction",
        "D": "The homology encodes a protein that catalyzes the assembly reaction"
      },
      "answer": "A",
      "explanation": "In Gibson assembly, exonuclease first exposes complementary single-stranded\nends, the homologous regions anneal, polymerase fills remaining gaps, and\nligase seals nicks. The shared terminal homology is what allows adjacent\nfragments to find and pair with the correct partner.\n\nOption B confuses Gibson assembly with restriction-enzyme cloning. Option C\nconfuses Gibson assembly with PCR. Option D is nonsensical.\n"
    },
    {
      "slug": "forbidden-restriction-sites",
      "difficulty": "medium",
      "topic": "Recognizing how an assembly method constrains which sequences are allowed in a design",
      "question": "A gene synthesis order is rejected because the sequence contains a BsaI\nrecognition site (<pre>GGTCTC</pre>). The gene will later be assembled using Golden\nGate cloning, which uses BsaI.\n\nWhy must the internal site be removed?\n",
      "choices": {
        "A": "If BsaI cuts at the internal site during assembly, the fragment is split into unintended pieces and the assembly fails or produces incorrect products",
        "B": "BsaI sites slow gene synthesis enough that vendors refuse all such sequences",
        "C": "The sequence <pre>GGTCTC</pre> encodes a toxic peptide when present in a coding region",
        "D": "Restriction sites cannot appear in coding sequences because they inherently block translation"
      },
      "answer": "A",
      "explanation": "Golden Gate assembly depends on controlled BsaI cutting at intended junctions.\nIf the insert also contains an internal BsaI site, the enzyme cuts there too,\ncreating extra fragments that disrupt the planned assembly.\n\nThe usual fix is to remove the internal site by synonymous (silent) codon\nchanges if the site is in a coding region. Option B is incorrect as stated.\nOption C is false. Option D is false because restriction sites can occur in\ncoding sequences without inherently disrupting translation.\n"
    },
    {
      "slug": "construction-file-representation",
      "difficulty": "medium",
      "topic": "Understanding how a structured build plan represents a sequence of physical DNA construction steps",
      "question": "A Construction File (CF) contains these steps:\n\n<pre>\npcr   fwd1 rev1 pTemplate product1\ndigest product1 EcoRI 1 frag1\nligate frag1 lig1\ntransform lig1 Mach1 Amp pFinal\n</pre>\n\nWhat does this CF describe?\n",
      "choices": {
        "A": "A DNA construction workflow that amplifies DNA by PCR, digests it with EcoRI, ligates the product, and transforms it into Mach1 cells with ampicillin selection",
        "B": "A gene expression experiment that transcribes and translates a protein from pTemplate",
        "C": "A sequencing workflow that reads the DNA sequence of pTemplate",
        "D": "A codon optimization workflow that redesigns the coding sequence before synthesis"
      },
      "answer": "A",
      "explanation": "Each CF line encodes a build step in a cloning workflow. The file specifies a\nPCR step, an EcoRI digest of the PCR product, a ligation step, and a\ntransformation into Mach1 cells with ampicillin selection. That is a physical\nDNA construction plan, not an expression, sequencing, or codon-optimization\nworkflow.\n"
    },
    {
      "slug": "pcr-product-prediction",
      "difficulty": "medium",
      "topic": "Tracing the dominant PCR product from primer structure and template matching rules",
      "question": "A PCR reaction uses:\n<pre>\nForward oligo: 5'-AAAA-cccc-3'  (AAAA is a 5' tail; cccc anneals to template)\nReverse oligo: 5'-TTTT-gggg-3'  (TTTT is a 5' tail; gggg anneals to template)\nTemplate: 5'-...ccccXXXXXXXXgggg...-3'\n</pre>\n\nAfter many PCR cycles, what is the dominant product?\n",
      "choices": {
        "A": "A double-stranded DNA product bounded by the full primer sequences, including the AAAA and TTTT 5' tails",
        "B": "Only the original template sequence, because 5' primer tails are not copied",
        "C": "Single-stranded DNA matching the forward oligo only",
        "D": "A product containing only the XXXXXXXX internal region with no primer-derived sequence"
      },
      "answer": "A",
      "explanation": "The primer 3' annealing regions bind the template and are extended by DNA\npolymerase. During the first cycles, the 5' tails become incorporated into the\nnewly synthesized strands. In later cycles, those tail-containing products act\nas templates, so the full primer sequences become fixed at the ends of the PCR\namplicon.\n\nTherefore the dominant product includes primer-derived tail sequences at both\nends. Options B, C, and D all ignore how primer sequences become incorporated\nand then re-amplified.\n"
    },
    {
      "slug": "fragment-size-limits-strategy",
      "difficulty": "medium",
      "topic": "Understanding how fragment size limits drive divide-and-assemble build strategies",
      "question": "A synthesis provider can reliably deliver DNA fragments only up to a few\nkilobases each. A designer needs to build a 15 kb plasmid.\n\nWhat is the standard strategy?\n",
      "choices": {
        "A": "Split the design into multiple fragments with planned overlaps and assemble them using Gibson or a similar multi-fragment method",
        "B": "Request a single 15 kb synthesized fragment as a rush order to bypass the limit",
        "C": "Order thousands of short oligos and assemble the full plasmid directly by PCA in one step",
        "D": "Abandon synthesis and clone the full sequence from a natural organism using restriction enzymes"
      },
      "answer": "A",
      "explanation": "Large constructs are typically built by dividing the design into buildable\nfragments and then assembling them with methods such as Gibson assembly that\nuse defined overlaps. This is the standard engineering response to synthesis\nlength limits.\n\nOption B assumes the limit can simply be bypassed. Option C is not a standard\none-step strategy for a 15 kb plasmid. Option D assumes the sequence exists in\nnature and ignores the stated design-build workflow.\n"
    },
    {
      "slug": "restriction-digest-and-ligation",
      "difficulty": "medium",
      "topic": "Understanding how restriction digest and ligation change DNA ends and topology",
      "question": "A linear PCR product has an EcoRI site near each end. After digesting with\nEcoRI and then ligating, what is the expected major product under typical\ndilute ligation conditions?\n",
      "choices": {
        "A": "A circular DNA formed by intramolecular ligation of the compatible EcoRI sticky ends",
        "B": "Two separate fragments that cannot be rejoined because EcoRI destroys end compatibility",
        "C": "The same linear DNA, unchanged, because ligase cannot act after restriction digestion",
        "D": "A large concatemer made primarily from repeated intermolecular ligation events"
      },
      "answer": "A",
      "explanation": "EcoRI generates compatible sticky ends (5' overhangs) at both cut sites. After\ndigestion, those ends can anneal and be sealed by ligase. For a single fragment\nunder typical dilute ligation conditions, intramolecular ligation (circular\nproduct) is usually favored over intermolecular concatenation.\n\nOption B is incorrect because EcoRI creates compatible ends. Option C is\nincorrect because ligation after digestion is a standard workflow. Option D can\noccur, especially at higher DNA concentration, but is not typically the major\nproduct under dilute conditions.\n"
    },
    {
      "slug": "pca-vs-standard-pcr",
      "difficulty": "medium",
      "topic": "Distinguishing standard PCR amplification from polymerase chain assembly by the inputs provided",
      "question": "Standard PCR uses two primers and a separate template DNA to amplify a target\nregion. Polymerase Chain Assembly (PCA) instead uses a pool of overlapping\noligos with no separate full-length template.\n\nWhat does PCA produce?\n",
      "choices": {
        "A": "A gene-length DNA assembled from overlapping oligos that serve as templates and primers for one another during the reaction",
        "B": "Many copies of only the longest oligo in the pool",
        "C": "A random library of all possible oligo combinations with no dominant product",
        "D": "Only single-stranded DNA because no full-length template was provided initially"
      },
      "answer": "A",
      "explanation": "In PCA, overlapping oligos anneal to one another and are extended by\npolymerase, creating progressively longer fragments across cycles. The reaction\nbuilds a longer DNA product from the oligo pool, and outer primers are often\nused afterward to amplify the assembled full-length product.\n\nOption B misunderstands the assembly mechanism. Option C overstates the\nrandomness of the process. Option D is wrong because the oligos themselves act\nas templates during assembly.\n"
    },
    {
      "slug": "oligo-design-constraints",
      "difficulty": "medium",
      "topic": "Understanding how multiple primer design constraints must be satisfied simultaneously",
      "question": "When designing a PCR primer annealing region, several constraints are usually\nconsidered at the same time. Which set of constraints is most appropriate?\n",
      "choices": {
        "A": "About 18–25 bp length, moderate GC content, no long homopolymer runs, and a stable 3' end (often a G/C clamp)",
        "B": "Exactly 20 bp length, any GC content, must begin with ATG, and no sequence constraints otherwise",
        "C": "About 50–100 bp length, low GC content, and must end with a stop codon",
        "D": "About 10–15 bp length, very high GC content, and A/T at both ends to improve priming"
      },
      "answer": "A",
      "explanation": "Primer annealing regions are typically chosen to balance specificity,\nmelting/annealing behavior, and robust extension from the 3' end. Common\ndesign heuristics include roughly 18 to 25 bases, moderate GC content,\navoiding long homopolymers, and a reasonably stable 3' end (often a G/C-rich\nend).\n\nOption B confuses primer design with coding-sequence design. Option C is far\ntoo long and uses inappropriate coding constraints. Option D is generally too\nshort and too GC-rich for reliable, specific priming.\n"
    },
    {
      "slug": "design-vs-fabrication-feasibility",
      "difficulty": "medium",
      "topic": "Recognizing that a sequence can be computationally valid yet difficult to synthesize physically",
      "question": "A codon-optimization algorithm produces a 4,000 bp coding sequence. The\nsequence passes software checks (for example, no forbidden restriction sites\nand acceptable codon-usage metrics), but a fabrication engineer flags it as\ndifficult to synthesize.\n\nWhich issue could cause that problem?\n",
      "choices": {
        "A": "A short region with extreme GC content that promotes strong secondary structure in synthesis intermediates and increases synthesis failure risk",
        "B": "High codon diversity across the sequence",
        "C": "The encoded protein is too large for E. coli to express efficiently",
        "D": "The sequence does not end with a transcription terminator"
      },
      "answer": "A",
      "explanation": "DNA synthesis feasibility depends on fabrication constraints that are not the\nsame as expression-design constraints. Local regions with extreme GC content,\nrepeats, or strong secondary structure can make synthesis and assembly much\nharder even when the sequence is otherwise biologically valid.\n\nOption B is not a typical synthesis blocker by itself. Option C is an\nexpression issue, not a fabrication issue. Option D is a construct-design\ncontext issue and is not a reason a coding sequence itself would be hard to\nsynthesize."
    }
  ],
  "coding_sequence_design_and_optimization": [
    {
      "slug": "many-valid-encodings",
      "difficulty": "medium",
      "topic": "Understanding why reverse translation has many valid DNA solutions while translation is unambiguous",
      "question": "The genetic code maps 61 sense codons to 20 amino acids. A protein of 100\namino acids must be reverse-translated into a DNA coding sequence.\n\nWhy does this design problem have many valid solutions, while translation\n(DNA → protein) does not?\n",
      "choices": {
        "A": "Most amino acids have multiple synonymous codons, so reverse translation offers multiple choices at many positions; in translation, each codon maps to one amino acid",
        "B": "DNA polymerase introduces random mutations during replication, creating many possible outputs",
        "C": "The genetic code is ambiguous, so some codons encode multiple amino acids",
        "D": "Reverse translation produces a single unique sequence because organisms always use one preferred codon per amino acid"
      },
      "answer": "A",
      "explanation": "The genetic code is degenerate but unambiguous. Degenerate means multiple\ncodons can encode the same amino acid. Unambiguous means each codon maps to\nexactly one amino acid. Therefore, reverse translation (protein → DNA) usually\nhas many valid encodings, while translation (DNA → protein) does not.\n\nOption B is about replication errors, not reverse-translation design. Option C\nis false because codons do not encode multiple amino acids. Option D is false\nbecause codon preference does not eliminate synonymous alternatives.\n"
    },
    {
      "slug": "one-aa-one-codon-limitations",
      "difficulty": "medium",
      "topic": "Recognizing why a naive codon assignment strategy can fail fabrication constraints",
      "question": "A \"one amino acid, one codon\" strategy assigns the most frequent codon for each\namino acid and concatenates them. A designer applies this to the peptide\n<pre>MKKK</pre> and gets <pre>ATG AAA AAA AAA</pre>.\n\nWhat fabrication problem can this create?\n",
      "choices": {
        "A": "It creates a long poly-A run that can trigger homopolymer-related synthesis errors and polymerase slippage",
        "B": "It creates excessively high GC content, which blocks synthesis",
        "C": "Three consecutive lysines are inherently toxic to E. coli",
        "D": "AAA is a rare lysine codon in E. coli, so expression will fail"
      },
      "answer": "A",
      "explanation": "Repeating the same synonymous codon for repeated amino acids can create long\nhomopolymeric runs. In this case, repeated <pre>AAA</pre> codons generate a long\nrun of A bases, which can cause synthesis and replication problems.\n\nA common fix is to alternate synonymous codons (for lysine, <pre>AAA</pre> and\n<pre>AAG</pre>) while preserving the protein sequence. Option B is incorrect\nbecause a poly-A run is low GC. Option C is false. Option D is false because\n<pre>AAA</pre> is not a rare lysine codon in E. coli.\n"
    },
    {
      "slug": "guided-random-codon-selection",
      "difficulty": "medium",
      "topic": "Understanding how weighted random codon selection biases solutions while preserving diversity",
      "question": "A guided-random codon optimization method builds a 100-entry lookup table for\neach amino acid, with codons repeated in proportion to usage frequency. For\nleucine, the table is:\n\n<pre>CTG: 49 entries, TTA: 13, TTG: 13, CTT: 11, CTC: 10, CTA: 4</pre>\n\nA random integer from 0 to 99 selects one entry. What is true about this\napproach?\n",
      "choices": {
        "A": "Frequently used codons are selected more often, but less frequent codons still appear sometimes, so multiple valid sequences can be generated",
        "B": "CTG is always selected because it has the highest count in the table",
        "C": "All leucine codons are selected with equal probability because the selection is random",
        "D": "The frequency-weighted selection guarantees that no forbidden sequences appear in the final gene"
      },
      "answer": "A",
      "explanation": "The lookup table implements weighted random sampling. Codons with more entries\nare selected more often, but lower-frequency codons still have nonzero\nprobability and therefore still appear. This preserves host-biased codon usage\nwhile generating diverse sequence solutions.\n\nOption B is false because the method is probabilistic, not deterministic.\nOption C ignores the weighting. Option D is false because forbidden sequences\ncan still arise by chance and must be checked separately.\n"
    },
    {
      "slug": "cai-measures-codon-bias",
      "difficulty": "medium",
      "topic": "Understanding what CAI measures about codon usage relative to a reference set",
      "question": "The Codon Adaptation Index (CAI) is a per-gene metric derived from codon\nadaptiveness values based on a reference organism's highly expressed genes. A\ngene with CAI = 0.85 mostly uses preferred codons.\n\nWhat does a CAI of 0.15 indicate?\n",
      "choices": {
        "A": "The gene mainly uses codons that are relatively rare in the reference organism's highly expressed genes",
        "B": "The gene has 15% GC content",
        "C": "Only 15% of the codons in the gene are valid codons",
        "D": "The encoded protein is 15% identical to proteins in the host organism"
      },
      "answer": "A",
      "explanation": "CAI measures how well a gene's codon usage matches the codon preferences of a\nreference set (typically highly expressed host genes). A low CAI means the gene\nuses codons that are less preferred in that reference context.\n\nCAI does not measure GC content (B), codon validity (C), or protein-sequence\nsimilarity (D).\n"
    },
    {
      "slug": "restriction-site-removal-preserves-protein",
      "difficulty": "medium",
      "topic": "Making a synonymous DNA change that fixes a sequence constraint while preserving protein sequence",
      "question": "A coding sequence contains a BsaI site <pre>GGTCTC</pre> starting at position 120.\nThe overlapping codons are <pre>GGT</pre> (Gly) and <pre>CTC</pre> (Leu).\n\nTo remove the BsaI site without changing the encoded protein, the designer\nshould:\n",
      "choices": {
        "A": "Replace <pre>GGT</pre> with <pre>GGC</pre> (still Gly) or replace <pre>CTC</pre> with <pre>CTG</pre> (still Leu), disrupting the recognition sequence",
        "B": "Delete the six bases <pre>GGTCTC</pre>, even though this shifts the reading frame",
        "C": "Insert a stop codon before position 120 so the enzyme cannot reach the site",
        "D": "Replace <pre>GGT</pre> with <pre>AAA</pre> to ensure the restriction site is broken"
      },
      "answer": "A",
      "explanation": "The correct strategy is a synonymous substitution: change the DNA sequence\nwhile preserving the amino acid sequence. Glycine and leucine each have\nmultiple codons, so the BsaI recognition sequence can be disrupted without\nchanging the protein.\n\nOption B causes a frameshift. Option C truncates the protein. Option D changes\nglycine to lysine and therefore changes the protein sequence.\n"
    },
    {
      "slug": "multiple-competing-objectives",
      "difficulty": "medium",
      "topic": "Recognizing that coding-sequence optimization is a multi-objective tradeoff problem",
      "question": "A codon optimization tool must balance several goals at once: maximize CAI,\navoid forbidden sequences (for example, BsaI sites), reduce problematic local\nsecondary structure near the start codon, and avoid homopolymeric runs.\n\nWhy is there generally no single universally best coding sequence?\n",
      "choices": {
        "A": "Improving one objective can worsen another, so acceptable solutions represent tradeoffs among competing constraints",
        "B": "The genetic code is too simple to represent all design constraints",
        "C": "There is always exactly one true optimum sequence, but it is too expensive to compute",
        "D": "Codon choice does not affect expression, so all synonymous solutions are equivalent"
      },
      "answer": "A",
      "explanation": "Coding-sequence design is usually a multi-objective optimization problem. For\nexample, maximizing preferred codons can increase CAI but may also create\nhomopolymer runs or introduce forbidden motifs. Fixing one issue may worsen a\ndifferent score.\n\nThe result is typically a set of tradeoff solutions rather than one universally\nbest sequence. Option B is false. Option C incorrectly assumes a single global\nbest answer in practice. Option D is contradicted by known expression\ndifferences among synonymous variants.\n"
    },
    {
      "slug": "rscu-vs-cai-distinction",
      "difficulty": "medium",
      "topic": "Distinguishing a per-codon usage metric from a per-gene codon adaptation metric",
      "question": "RSCU (Relative Synonymous Codon Usage) and CAI (Codon Adaptation Index) both\nrelate to codon usage bias.\n\nWhat is the key difference between them?\n",
      "choices": {
        "A": "RSCU describes how often one codon is used relative to its synonymous alternatives, while CAI summarizes codon adaptation across an entire gene",
        "B": "RSCU applies only to RNA sequences, while CAI applies only to DNA sequences",
        "C": "RSCU is calculated from protein sequences, while CAI is calculated from DNA sequences",
        "D": "RSCU and CAI are the same metric reported in different units"
      },
      "answer": "A",
      "explanation": "RSCU is a codon-level statistic that compares observed use of one synonymous\ncodon to equal-use expectation. CAI is a gene-level summary score that combines\ncodon adaptiveness values across a coding sequence.\n\nSo RSCU helps define codon preference in a reference set, while CAI scores how\nwell one gene matches that preference pattern. Options B, C, and D are\nincorrect.\n"
    },
    {
      "slug": "secondary-structure-affects-expression",
      "difficulty": "medium",
      "topic": "Understanding how synonymous codon choices can change expression through local RNA structure near the start region",
      "question": "Two coding sequences encode the same protein but differ in synonymous codon\nusage. Sequence A is predicted to form strong secondary structure in the first\n~40 nucleotides of the coding region, while Sequence B has weaker structure in\nthat region.\n\nBased on expression studies of synonymous GFP variants, what is the most likely\noutcome?\n",
      "choices": {
        "A": "Sequence B will likely express more protein because weaker structure near the start region improves ribosome access and initiation",
        "B": "Sequence A will likely express more protein because stronger secondary structure always improves mRNA stability and translation",
        "C": "Both sequences will express identically because they encode the same protein sequence",
        "D": "Sequence A will likely express more protein because coding-region structure directly increases transcription initiation rate"
      },
      "answer": "A",
      "explanation": "Synonymous codon changes can alter local RNA structure near the translation\nstart region. Strong structure in this region can reduce access to the RBS and\nstart codon and lower translation initiation efficiency. Weaker local structure\noften supports higher expression.\n\nOption B overgeneralizes mRNA stability and ignores the specific importance of\nstart-region accessibility. Option C ignores well-established synonymous-codon\neffects on expression. Option D confuses translation-related effects with\ntranscription initiation.\n"
    },
    {
      "slug": "codon-context-matters",
      "difficulty": "medium",
      "topic": "Recognizing that codon context effects require algorithms to consider neighboring codons",
      "question": "Research shows that adjacent codons (codon context or codon pairs) can affect\ntranslation elongation beyond what single-codon frequency predicts. In one\ncomparison, codon-context-aware optimization outperformed optimization based\nonly on individual codon usage.\n\nWhat does this imply for algorithm design?\n",
      "choices": {
        "A": "The algorithm should score codons in windows that include neighboring codons, not just optimize one position independently at a time",
        "B": "Only the first codon after the start codon matters for expression",
        "C": "Codon optimization should be abandoned because context effects make single-codon usage irrelevant",
        "D": "The algorithm should prefer the rarest codons to maximize sequence diversity"
      },
      "answer": "A",
      "explanation": "If neighboring codons influence translation performance, then optimizing each\ncodon independently misses important interactions. A context-aware algorithm\nshould evaluate windows (for example, codon pairs or short local segments)\nrather than only single positions.\n\nOption B is too narrow. Option C is incorrect because both single-codon bias\nand context effects can matter. Option D is unrelated to the stated evidence.\n"
    },
    {
      "slug": "iterative-generation-and-checking",
      "difficulty": "medium",
      "topic": "Understanding the strengths and risks of generate-and-test optimization under multiple constraints",
      "question": "A guided-random codon optimization algorithm uses this loop:\n\n<pre>\n1. Randomly choose codons (weighted by usage) for each amino acid\n2. Check the full sequence against constraints (forbidden motifs, homopolymers, etc.)\n3. If any check fails, regenerate and try again\n</pre>\n\nWhat is a practical risk of this approach?\n",
      "choices": {
        "A": "For proteins with repeated amino acids (for example, many lysines in a row), the algorithm may need many retries before it finds a sequence that passes all constraints",
        "B": "The algorithm always returns the same sequence regardless of random seed",
        "C": "The algorithm cannot check constraints because the sequence changes every iteration",
        "D": "Weighted random codon selection always generates invalid sequences"
      },
      "answer": "A",
      "explanation": "Weighted random selection can repeatedly favor common codons that create the\nsame constraint violations, especially in repeated-amino-acid regions (for\nexample, repeated lysine codons creating homopolymer-prone runs). The algorithm\nmay therefore require many generate-and-test cycles before finding an\nacceptable sequence.\n\nOption B is false because different random seeds can produce different\nsequences. Option C is false because constraint checking is performed on each\ngenerated full sequence. Option D overstates the problem."
    }
  ],
  "verification_strategies_and_failure_modes": [
    {
      "slug": "checker-purpose",
      "difficulty": "medium",
      "topic": "Understanding why domain logic is encapsulated in a reusable function rather than duplicated",
      "question": "A ForbiddenSequenceChecker is a function that inputs a DNA sequence and\nreturns True if the sequence is free of forbidden restriction sites.\nThis checker is used both inside the TranscriptDesigner algorithm and\nin the pytest suite that tests TranscriptDesigner.\n\nWhy is the checker written as a separate, shared function?\n",
      "choices": {
        "A": "Both the algorithm and the test need the same domain logic; a shared checker avoids code duplication and ensures consistency",
        "B": "The checker runs faster as a standalone function than as inline code",
        "C": "Python does not allow the same logic to appear in two different files",
        "D": "The checker is needed only for testing and is never used inside the algorithm itself"
      },
      "answer": "A",
      "explanation": "If the algorithm checks for forbidden sequences internally and the test\nalso checks for them independently, both must implement the same logic.\nDuplicating that logic creates a maintenance risk — if one copy is\nupdated but the other is not, they can silently diverge. The checker\npattern centralizes this domain knowledge in one place that both the\nalgorithm and tests can call. This also makes the checker independently\ntestable.\n"
    },
    {
      "slug": "which-checker-for-which-region",
      "difficulty": "medium",
      "topic": "Recognizing that different validation rules apply to different parts of a composite design",
      "question": "A genetic construct has three regions: the RBS (5' UTR), the CDS\n(coding sequence), and the terminator. A developer considers applying\nInternalRBSChecker to the full construct.\n\nWhat is the problem with this approach?\n",
      "choices": {
        "A": "The construct intentionally contains an RBS, so the checker would always report a violation — it should only be applied to the CDS and terminator regions",
        "B": "InternalRBSChecker only works on protein sequences, not DNA",
        "C": "The checker is too slow to run on a full construct",
        "D": "There is no problem; InternalRBSChecker should be applied to all regions"
      },
      "answer": "A",
      "explanation": "The InternalRBSChecker looks for Shine-Dalgarno-like sequences followed\nby a start codon. Every transcript intentionally has an RBS at the\nbeginning, so applying the checker to the full construct (including the\nreal RBS) would always flag it as a violation. The checker should only\nbe applied to regions where an RBS would be unintended — the internal\nCDS and downstream regions. This illustrates that different checkers\nhave different valid scopes.\n"
    },
    {
      "slug": "checker-test-validates-checker",
      "difficulty": "medium",
      "topic": "Understanding that a validation tool itself must be tested to ensure it catches known cases",
      "question": "A test for ForbiddenSequenceChecker includes these assertions:\n\n<python>\nassert checker.run('AAAAGGTCTCAAAAA') == False  # contains BsaI site\nassert checker.run('ACACACACACACAC') == True     # no forbidden sites\nassert raises(ValueError, checker.run, 'BOB')    # invalid input\n</python>\n\nWhat is the purpose of testing the checker itself?\n",
      "choices": {
        "A": "To verify that the checker correctly identifies known forbidden sequences and correctly passes clean sequences before using it to validate designs",
        "B": "To benchmark the speed of the checker function",
        "C": "To test whether the TranscriptDesigner algorithm works correctly",
        "D": "To generate a list of all possible forbidden sequences"
      },
      "answer": "A",
      "explanation": "If the checker has a bug (e.g. it fails to detect GGTCTC, or it\nfalse-positives on clean sequences), then both the algorithm and the\ntest that rely on it would silently produce incorrect results. Testing\nthe checker on known positive cases (sequences that do contain forbidden\nsites), known negative cases (clean sequences), and invalid inputs\n(non-DNA strings) ensures the checker itself is trustworthy before it\nis used to validate designs.\n"
    },
    {
      "slug": "edge-case-reveals-algorithm-weakness",
      "difficulty": "medium",
      "topic": "Identifying inputs that stress a specific weakness in an algorithm's logic",
      "question": "The peptide <pre>MKKKKKKK</pre> is used as an edge case for testing\nTranscriptDesigner. Why is this particular input challenging?\n",
      "choices": {
        "A": "Lysine's most common codon is AAA, so consecutive lysines tend to produce poly-A runs that violate the forbidden homopolymeric sequence constraint",
        "B": "The peptide is too short for the algorithm to process",
        "C": "Lysine cannot be encoded by any codon in E. coli",
        "D": "The sequence has too many methionines, which confuses the start codon detection"
      },
      "answer": "A",
      "explanation": "Lysine is encoded by AAA (most common) and AAG. A naive algorithm that\nalways picks the most common codon produces <pre>ATGAAAAAAAAAAAAAAAAAAAAA</pre> —\na poly-A run that fails the forbidden sequence check for homopolymeric\nruns (typically 8+ consecutive identical bases). This edge case forces\nthe algorithm to use synonymous codon variation (alternating AAA and\nAAG). It reveals whether the algorithm can handle the constraint. The\npeptide has only one Met (the start), not \"too many.\"\n"
    },
    {
      "slug": "inverse-function-validation",
      "difficulty": "medium",
      "topic": "Using a reverse operation to verify that a forward operation produced a correct result",
      "question": "DesignPCRPrimers inputs a template and desired product, and outputs two\noligos. PredictPCRProduct inputs two oligos and a template, and outputs\nthe expected product sequence.\n\nHow can these two functions be used together for validation?\n",
      "choices": {
        "A": "Run DesignPCRPrimers to get oligos, then run PredictPCRProduct with those oligos and the template, and verify the predicted product matches the desired product",
        "B": "Run both functions simultaneously and check that they have the same runtime",
        "C": "Use DesignPCRPrimers to test PredictPCRProduct's error handling",
        "D": "Run PredictPCRProduct first, then use its output as input to DesignPCRPrimers to check for exceptions"
      },
      "answer": "A",
      "explanation": "DesignPCRPrimers and PredictPCRProduct are inverse functions. If the\ndesign function works correctly, feeding its output (the oligos) into\nthe simulation function (the predictor) should reproduce the original\ndesired product. If the predicted product does not match, either the\ndesign or the simulation has a bug. This pattern — design then simulate\n— is a powerful validation strategy that avoids manually computing\nexpected results.\n"
    },
    {
      "slug": "truism-as-property-check",
      "difficulty": "medium",
      "topic": "Using necessarily true properties to catch errors without computing exact expected values",
      "question": "A test for RBSChooser asserts that the output RBS sequence contains\nonly valid DNA characters (A, T, C, G) and is between 6 and 30\nnucleotides long. These assertions are examples of:\n",
      "choices": {
        "A": "Truisms — properties that must be true for any valid output, regardless of the specific input",
        "B": "Validated examples — experimentally confirmed input/output pairs",
        "C": "Edge cases — inputs designed to break the algorithm",
        "D": "Benchmarks — performance measurements of the algorithm"
      },
      "answer": "A",
      "explanation": "Truisms are broad property checks that should hold for any valid output\nof a function. \"Output is valid DNA\" and \"output length is within a\nbiologically plausible range\" are truisms. They do not verify that the\noutput is the *best* or *correct* RBS for the specific input, but they\ncatch gross errors (e.g. returning None, returning RNA characters, or\nreturning an impossibly long sequence). Validated examples check specific\nknown input/output pairs. Edge cases are specific tricky inputs.\n"
    },
    {
      "slug": "validated-example-strongest-evidence",
      "difficulty": "medium",
      "topic": "Understanding why empirical data provides stronger validation than purely computational checks",
      "question": "A researcher tests a gRNA design function using the cadA gene from\nE. coli. The protospacer found in the published pTargetF plasmid\n(experimentally confirmed to edit cadA) is used as the expected output.\n\nWhy is this test stronger than a truism like \"output contains only ATCG\"?\n",
      "choices": {
        "A": "It verifies the function's specific biological logic against a real, experimentally validated result — not just that the output looks plausible",
        "B": "It runs faster than truism-based tests",
        "C": "It tests more edge cases simultaneously",
        "D": "Validated examples are easier to write than truisms"
      },
      "answer": "A",
      "explanation": "A truism catches gross errors but cannot verify whether the function\nfound the *correct* protospacer. A validated example uses a real\nexperimental result — the actual protospacer sequence from a published,\nworking CRISPR system — to verify the function's biological logic. If\nthe function extracts the wrong 20-mer (e.g. off-by-one), the truism\nstill passes (it's valid DNA and the right length) but the validated\nexample fails. Validated examples are the \"best evidence short of\nexperimentally testing designs yourself.\"\n"
    },
    {
      "slug": "benchmarking-on-proteome",
      "difficulty": "medium",
      "topic": "Understanding how testing at scale reveals failure rates that individual tests cannot",
      "question": "A proteome benchmarker runs TranscriptDesigner on all 2,458 E. coli\nproteins and reports:\n- Forbidden sequence violations: 1,924\n- Hairpin violations: 2,326\n- Translation match failures: 130\n\nWhat does this benchmark reveal that individual test cases cannot?\n",
      "choices": {
        "A": "The overall failure rate and which types of violations are most common across the full input space",
        "B": "The exact DNA sequence that should be designed for each protein",
        "C": "Whether the algorithm runs without syntax errors",
        "D": "Which specific codon causes each violation"
      },
      "answer": "A",
      "explanation": "Individual test cases verify behavior on specific inputs, but a proteome\nbenchmark evaluates the algorithm across the entire space of valid\ninputs. It reveals the aggregate failure rate (e.g. 78% of proteins\nhave hairpin issues) and identifies which constraints are hardest to\nsatisfy. This guides algorithm improvement: hairpin violations are most\ncommon, so the algorithm should prioritize secondary structure\navoidance. Individual tests cannot reveal these population-level\nstatistics.\n"
    },
    {
      "slug": "pwm-promoter-checking",
      "difficulty": "medium",
      "topic": "Understanding how a statistical model of sequence features can detect unintended functional sites",
      "question": "InternalPromoterChecker uses a position weight matrix (PWM) to score\nwhether a region of DNA resembles a sigma-70 promoter. The PWM encodes\nthe probability of each base at each position in the -35 and -10 boxes.\n\nWhy is a PWM used instead of an exact sequence match?\n",
      "choices": {
        "A": "Promoters are not a single exact sequence — they are a family of related sequences with position-dependent variation, so a probabilistic model is more sensitive than exact matching",
        "B": "PWMs run faster than exact string matching",
        "C": "Exact matching would find too many false positives",
        "D": "The PWM also detects restriction enzyme sites"
      },
      "answer": "A",
      "explanation": "Sigma-70 promoters are not defined by one exact sequence but by a\nconsensus pattern with variation at each position (e.g. the -10 box is\n<pre>TATAAT</pre> but functional variants exist). A PWM captures this variation by\nscoring how likely a given sequence is to function as a promoter. An\nexact match for TATAAT alone would miss functional promoters with single\nsubstitutions, and a search for partial matches would produce too many\nfalse positives. The PWM balances sensitivity and specificity.\n"
    },
    {
      "slug": "passing-checks-vs-being-correct",
      "difficulty": "medium",
      "topic": "Understanding the difference between satisfying known constraints and achieving the true design goal",
      "question": "A TranscriptDesigner output passes all checkers: ForbiddenSequenceChecker,\nHairpinChecker, CodonChecker, and InternalPromoterChecker all return\nTrue. Does this guarantee the design will express well in E. coli?\n",
      "choices": {
        "A": "No — the checkers verify known constraints are satisfied, but real expression depends on factors beyond what the checkers model (e.g. mRNA stability, tRNA interactions, protein folding)",
        "B": "Yes — if all checkers pass, the design is guaranteed to work experimentally",
        "C": "No — because the checkers have false positive rates above 50%",
        "D": "Yes — the checkers collectively model all aspects of gene expression"
      },
      "answer": "A",
      "explanation": "Checkers enforce a defined set of domain-specific constraints (no\nforbidden sites, low hairpin count, acceptable CAI, no internal\npromoters). However, gene expression depends on many additional factors:\nmRNA stability and RNase E cleavage, interactions with other cellular\nRNAs, codon context effects, protein folding during translation, and\nresource competition. No finite set of checkers can model all biological\ncomplexity. Passing the checks means the design is free of known\nproblems, not that it is guaranteed to work. Experimental validation\nremains necessary."
    }
  ]
}
