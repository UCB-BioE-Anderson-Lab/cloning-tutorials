

---
slug: return-vs-print-in-design
difficulty: medium
topic: Understanding that functions communicate results through return values, not side effects
question: |
  A student writes a function to translate a CDS into a protein:

  <python>
  def translate(cds, genetic_code):
      protein = ''
      for i in range(0, len(cds), 3):
          codon = cds[i:i+3]
          protein += genetic_code[codon]
      print(protein)

  result = translate('ATGAAATAA', genetic_code)
  </python>

  They then try to check whether the protein starts with methionine:

  <python>
  result.startswith('M')
  </python>

  What happens?
choices:
  A: Returns True — the protein starts with 'M'
  B: AttributeError — result is None because the function prints but does not return
  C: Returns False — print converts the protein to a different format
  D: NameError — protein is not accessible outside the function
answer: B
explanation: |
  The function uses <python>print()</python> instead of <python>return</python>,
  so it displays the protein but returns <python>None</python> by default.
  Calling <python>.startswith()</python> on <python>None</python> raises an
  AttributeError. Option A would be correct if the function returned the
  protein string. Option D states a true scoping fact (<python>protein</python>
  is local), but that is not the immediate error in the code shown.

---
slug: local-scope-isolation
difficulty: medium
topic: Recognizing that local variables inside a function are invisible to the caller
question: |
  A function computes the GC content of a DNA sequence:

  <python>
  def gc_content(seq):
      gc_count = 0
      for base in seq:
          if base in 'GC':
              gc_count += 1
      fraction = gc_count / len(seq)
      return fraction

  result = gc_content('ATGCGC')
  print(gc_count)
  </python>

  What happens when <python>print(gc_count)</python> executes?
choices:
  A: Prints 4 — gc_count was computed inside the function
  B: Prints 0 — gc_count is reset after the function returns
  C: NameError — gc_count is local to gc_content and does not exist in the caller's scope
  D: Prints 0.667 — gc_count holds the fraction, not the count
answer: C
explanation: |
  Variables created inside a function are local to that function unless they
  are explicitly returned or otherwise exposed. <python>gc_count</python>
  exists only inside <python>gc_content()</python>, so the caller cannot read
  it directly. The function returns the fraction (stored in
  <python>result</python>), but <python>gc_count</python> itself is out of
  scope in the caller.

---
slug: default-argument-override
difficulty: medium
topic: Using default arguments to provide sensible fallbacks that callers can override
question: |
  A CRISPR guide RNA design function has a default PAM:

  <python>
  def find_targets(seq, pam='NGG'):
      targets = []
      for i in range(len(seq) - len(pam)):
          if matches_pam(seq[i:i+len(pam)], pam):
              targets.append(i)
      return targets

  a = find_targets(genome_seq)
  b = find_targets(genome_seq, 'NGG')
  c = find_targets(genome_seq, 'NNGRRT')
  </python>

  Which calls use <pre>NGG</pre> and which use <pre>NNGRRT</pre>?
choices:
  A: a and b use 'NGG'; c uses 'NNGRRT'
  B: Only b uses 'NGG'; a uses None because no argument was provided
  C: All three use 'NGG' — the default cannot be overridden
  D: a uses 'NGG'; b and c both raise errors for passing a second argument
answer: A
explanation: |
  In call <python>a</python>, no PAM is provided, so the default
  <pre>NGG</pre> is used. Call <python>b</python> passes <pre>NGG</pre>
  explicitly, so it has the same effect. Call <python>c</python> passes
  <pre>NNGRRT</pre>, which overrides the default. Default arguments provide a
  convenient common case while still allowing callers to supply alternatives.

---
slug: pure-function-no-side-effects
difficulty: medium
topic: Distinguishing pure functions from those with side effects and understanding why purity aids testing
question: |
  Two implementations of reverse_complement are proposed:

  <python>
  # Version A
  complement_table = {}
  def reverse_complement_a(seq):
      complement_table['last_input'] = seq
      comp = seq.translate(str.maketrans('ATCG', 'TAGC'))
      return comp[::-1]

  # Version B
  def reverse_complement_b(seq):
      comp = seq.translate(str.maketrans('ATCG', 'TAGC'))
      return comp[::-1]
  </python>

  Both return the correct reverse complement. Why is Version B preferred
  for use in a design pipeline?
choices:
  A: Version B is a pure function — same input always gives the same output with no side effects
  B: Version A is slower because dicts are slow
  C: Version B handles lowercase input and Version A does not
  D: Version A returns a different result each time it is called
answer: A
explanation: |
  Version A mutates the external dict <python>complement_table</python> on
  every call, which is a side effect. Version B depends only on its input and
  produces only a return value. That makes Version B easier to test, reason
  about, and safely compose with other functions. Both versions return the
  same reverse complement for the same input, but only Version B avoids hidden
  state changes.

---
slug: function-as-reusable-unit
difficulty: medium
topic: Recognizing when repeated logic should be extracted into a function and how arguments generalize it
question: |
  A student writes code to check for forbidden restriction sites in a
  designed gene:

  <python>
  has_ecori = 'GAATTC' in cds
  has_bsai = 'GGTCTC' in cds
  has_bsai_rc = 'GAGACC' in cds
  has_ecori_rc = 'GAATTC' in cds
  </python>

  They realize the pattern repeats. Which refactoring best captures
  the shared logic?
choices:
  A: |
    <python>
    def has_site(seq, site):
        rc = reverse_complement(site)
        return site in seq or rc in seq
    </python>
  B: |
    <python>
    def has_site(seq):
        return 'GAATTC' in seq or 'GGTCTC' in seq
    </python>
  C: |
    <python>
    def has_site(site):
        return site in cds
    </python>
  D: |
    <python>
    def has_site():
        return True
    </python>
answer: A
explanation: |
  Option A parameterizes both things that vary: the sequence being checked
  and the restriction site of interest. It also handles the reverse
  complement, which is part of the repeated logic. Option B hardcodes
  specific sites, so it is not reusable. Option C relies on
  <python>cds</python> from outer scope instead of taking the sequence as an
  argument, making the function less reusable and harder to test. Option D
  does not implement the required logic.

---
slug: initiate-run-lifecycle
difficulty: medium
topic: Understanding the two-phase pattern of configuring an algorithm object then executing it
question: |
  The RBSChooser class uses an initiate/run pattern:

  <python>
  chooser = RBSChooser()
  chooser.initiate()       # loads proteomics data and builds lookup tables
  result = chooser.run(cds)  # designs an RBS for the given CDS
  </python>

  A student tries to skip initiation:

  <python>
  chooser2 = RBSChooser()
  result2 = chooser2.run(cds)
  </python>

  What is the most likely outcome?
choices:
  A: It works — initiate is optional and run loads data on demand
  B: AttributeError or KeyError — run depends on data structures that initiate creates
  C: result2 is None — run detects missing initialization and returns nothing
  D: TypeError — run cannot be called on an uninitialized object
answer: B
explanation: |
  In this pattern, <python>initiate()</python> performs one-time setup and
  creates internal data structures that <python>run()</python> expects to use.
  If setup is skipped, <python>run()</python> is likely to access missing
  attributes or missing keys and fail with an AttributeError or KeyError.
  The key idea is that the caller must honor the object's lifecycle contract:
  initialize first, then run queries.

---
slug: mutable-default-argument-trap
difficulty: medium
topic: Understanding why mutable default arguments can cause unexpected state sharing between calls
question: |
  A function collects restriction sites to avoid during gene design:

  <python>
  def add_forbidden_site(site, sites=[]):
      sites.append(site)
      return sites

  result1 = add_forbidden_site('GAATTC')
  result2 = add_forbidden_site('GGTCTC')
  </python>

  What is the value of result2?
choices:
  A: "['GGTCTC'] — each call starts with a fresh empty list"
  B: "['GAATTC', 'GGTCTC'] — the default list is shared across calls"
  C: TypeError — you cannot use a list as a default argument
  D: "['GGTCTC', 'GAATTC'] — the list prepends new entries"
answer: B
explanation: |
  The default list is created once when the function is defined, not each
  time the function is called. Both calls therefore use the same list object.
  After the first call it contains <pre>GAATTC</pre>, and after the second it
  contains <pre>GAATTC</pre> and <pre>GGTCTC</pre>. The standard fix is to use
  <python>sites=None</python> and create a new list inside the function when
  needed.

---
slug: class-attribute-vs-instance-attribute
difficulty: medium
topic: Distinguishing data shared across all instances from data specific to one instance
question: |
  A TranscriptDesigner class stores both shared configuration and
  per-design results:

  <python>
  class TranscriptDesigner:
      checkers = [ForbiddenSequenceChecker, HairpinChecker]  # class attribute

      def __init__(self, protein_seq):
          self.protein_seq = protein_seq   # instance attribute
          self.cds = None                  # instance attribute

  designer_a = TranscriptDesigner('MKALIV')
  designer_b = TranscriptDesigner('MPQRST')
  </python>

  Which statement is true?
choices:
  A: designer_a.checkers and designer_b.checkers refer to the same list; their protein_seq values differ
  B: Each designer has its own independent copy of checkers and protein_seq
  C: checkers is only accessible via the class, not through instances
  D: designer_a.protein_seq and designer_b.protein_seq refer to the same string
answer: A
explanation: |
  <python>checkers</python> is a class attribute, so it is shared across all
  instances unless shadowed on a specific instance. By contrast,
  <python>self.protein_seq</python> is assigned in <python>__init__</python>,
  so each instance gets its own value. This is a common pattern: shared
  configuration at the class level and per-object state at the instance
  level.

---
slug: argument-order-and-keyword-args
difficulty: medium
topic: Using positional and keyword arguments to make function calls readable and correct
question: |
  A PCR primer design function has this signature:

  <python>
  def design_primers(template, target_tm=60.0, min_length=18, max_length=30):
      ...
  </python>

  A student calls it four ways:

  <python>
  a = design_primers('ATGCCC...', 55.0, 20, 25)
  b = design_primers('ATGCCC...', max_length=25, target_tm=55.0)
  c = design_primers('ATGCCC...', min_length=20, 55.0)
  d = design_primers(target_tm=55.0, template='ATGCCC...')
  </python>

  Which calls raise a SyntaxError?
choices:
  A: Only c — positional arguments cannot follow keyword arguments
  B: c and d — keyword arguments must match the exact order
  C: Only d — template must be passed positionally
  D: None — Python accepts arguments in any order
answer: A
explanation: |
  In a function call, positional arguments must come before keyword
  arguments. Call <python>c</python> violates that rule by placing
  <python>55.0</python> after the keyword argument
  <python>min_length=20</python>. Calls <python>a</python> and
  <python>b</python> are valid, and call <python>d</python> is also valid
  because all arguments are passed by keyword (keyword order does not have to
  match the parameter order).

---
slug: function-composition-pipeline
difficulty: medium
topic: Composing functions so the output of one becomes the input of the next in a processing pipeline
question: |
  A gene design pipeline composes three functions:

  <python>
  def reverse_translate(protein, codon_table):
      '''Returns a DNA CDS encoding the protein.'''
      ...

  def optimize_codons(cds, organism):
      '''Returns an optimized version of the CDS.'''
      ...

  def remove_forbidden_sites(cds, forbidden):
      '''Returns a CDS with forbidden sites silently eliminated.'''
      ...
  </python>

  A student writes:

  <python>
  cds = reverse_translate('MKALI', codon_table)
  optimized = optimize_codons(cds, 'ecoli')
  final = remove_forbidden_sites(optimized, ['GAATTC', 'GGTCTC'])
  </python>

  Another student writes:

  <python>
  final = remove_forbidden_sites(
      optimize_codons(
          reverse_translate('MKALI', codon_table),
          'ecoli'),
      ['GAATTC', 'GGTCTC'])
  </python>

  What is the relationship between these two approaches?
choices:
  A: They produce the same result — the second nests the calls but the execution order and data flow are identical
  B: The nested version runs faster because it avoids creating intermediate variables
  C: The nested version skips the optimize_codons step
  D: They produce different results because nested calls change the evaluation order
answer: A
explanation: |
  Both versions call the same functions in the same logical order with the
  same inputs. The nested form simply passes each return value directly into
  the next function call instead of storing intermediate variables. Python
  evaluates the innermost call first, so the data flow is the same in both
  versions. Named intermediate variables are often easier to inspect while
  debugging, but the final result is the same.