

---
slug: zero-based-index-extraction
difficulty: medium
topic: Applying zero-based indexing to extract a specific element from sequential data
question: |
  A promoter sequence is stored as a string. A student wants to check
  the base at the transcription start site, which is the 5th nucleotide
  in the stored sequence:

  <pre>promoter = 'TTGACATATAAT'</pre>

  The student writes:

  <python>
  tss = promoter[5]
  </python>

  What value does <python>tss</python> hold, and did the student get what
  they wanted?
choices:
  A: "'A' — this is the 6th nucleotide, not the 5th; the student has an off-by-one error"
  B: "'C' — this is the 5th nucleotide, exactly what the student wanted"
  C: "'T' — index 5 wraps around to the beginning of the string"
  D: IndexError — index 5 is out of range for this string
answer: A
explanation: |
  Python uses zero-based indexing, so the indices are:
  <python>promoter[0]='T'</python>, <python>promoter[1]='T'</python>,
  <python>promoter[2]='G'</python>, <python>promoter[3]='A'</python>,
  <python>promoter[4]='C'</python>, <python>promoter[5]='A'</python>.
  Therefore <python>promoter[5]</python> returns <pre>A</pre>, which is the
  6th nucleotide. The 5th nucleotide (1-based position 5) is at
  <python>promoter[4]</python>, which is <pre>C</pre>. This is a classic
  off-by-one error caused by mixing biological 1-based positions with
  Python's 0-based indexing.

---
slug: slice-endpoint-exclusion
difficulty: medium
topic: Understanding that slice endpoints are exclusive and reasoning about boundary positions
question: |
  A gene annotation says the start codon begins at position 10 (0-based)
  in a genomic sequence. You want to extract the 3-nucleotide start codon:

  <pre>genome = 'CCCGTTAAACATGAAAGGGCCC'</pre>

  Which slice correctly extracts <pre>ATG</pre> starting at index 10?
choices:
  A: genome[10:13]
  B: genome[10:12]
  C: genome[11:14]
  D: genome[10:10+2]
answer: A
explanation: |
  Python slicing uses a half-open interval: <python>seq[start:end]</python>
  includes <python>start</python> but excludes <python>end</python>. To get 3
  characters starting at index 10, you need indices 10, 11, and 12, so the
  correct slice is <python>genome[10:13]</python>. The general rule is:
  to extract <python>n</python> characters starting at index <python>i</python>,
  use <python>seq[i:i+n]</python>.

---
slug: negative-index-from-end
difficulty: medium
topic: Using negative indices to access elements relative to the end of a sequence
question: |
  A CDS must end with a stop codon. To extract the last three
  nucleotides for verification:

  <pre>cds = 'ATGAAAGGTCTCTAA'</pre>

  A student writes:

  <python>
  last_codon = cds[-3:]
  </python>

  What is the value of <python>last_codon</python>?
choices:
  A: 'TAA'
  B: 'ATG'
  C: 'CTT'
  D: IndexError — negative indices are not allowed on strings
answer: A
explanation: |
  Negative indices count from the end of the string. The slice
  <python>cds[-3:]</python> means "from the third-to-last character through
  the end," which returns <pre>TAA</pre>. This is the standard idiom for
  checking a terminal codon without explicitly computing the string length.

---
slug: off-by-one-protospacer-extraction
difficulty: medium
topic: Getting boundary arithmetic right when extracting a region defined relative to a landmark position
question: |
  A CRISPR guide design function locates a PAM site (<pre>NGG</pre>) and must
  extract the 20-nt protospacer immediately upstream. The PAM starts at
  index 25 in the target sequence:

  <python>
  target = '...' # a long genomic string
  pam_index = 25
  </python>

  Which slice correctly extracts the 20-nt protospacer?
choices:
  A: target[pam_index-20:pam_index]
  B: target[pam_index-21:pam_index-1]
  C: target[pam_index-20:pam_index-1]
  D: target[pam_index-19:pam_index]
answer: A
explanation: |
  If the PAM starts at index 25, the 20-nt protospacer immediately upstream
  occupies indices 5 through 24 inclusive. In Python's half-open slicing,
  that is <python>target[5:25]</python>, which is exactly
  <python>target[pam_index-20:pam_index]</python>. The endpoint should be the
  PAM index itself because slice endpoints are already exclusive.

---
slug: slice-with-step-reverse
difficulty: medium
topic: Using a step argument in slicing to reverse or subsample sequential data
question: |
  A function needs to reverse a DNA sequence as part of computing the
  reverse complement. Given:

  <pre>seq = 'AACGTCG'</pre>

  What is the value of <python>seq[::-1]</python>?
choices:
  A: 'GCTGCAA'
  B: 'AACGTCG'
  C: 'GCAACGT'
  D: TypeError — strings do not support step slicing
answer: A
explanation: |
  The slice <python>[::-1]</python> reverses a sequence by stepping through it
  from end to beginning. Reversing <pre>AACGTCG</pre> gives <pre>GCTGCAA</pre>.
  This creates a new string; it does not modify the original in place.

---
slug: find-returns-negative-one
difficulty: medium
topic: Distinguishing methods that return sentinel values from those that raise exceptions on failure
question: |
  A restriction site scanner needs to locate <pre>GAATTC</pre> (EcoRI) in a
  designed gene. Two approaches:

  <python>
  cds = 'ATGAAACCCGGGTAA'

  pos_a = cds.find('GAATTC')
  pos_b = cds.index('GAATTC')
  </python>

  The site is not present in this CDS. What happens?
choices:
  A: Both return -1
  B: find returns -1; index raises ValueError
  C: find returns None; index returns -1
  D: Both raise ValueError
answer: B
explanation: |
  <python>str.find()</python> returns <python>-1</python> when the substring
  is absent, while <python>str.index()</python> raises a ValueError. This
  difference matters in sequence-scanning code because failing to check for
  <python>-1</python> can lead to silent downstream slicing bugs.

---
slug: string-immutability-mutation
difficulty: medium
topic: Recognizing that immutable sequences cannot be modified in place and must be rebuilt
question: |
  A codon optimization function wants to replace the codon at positions
  6-8 in a CDS with a synonymous alternative:

  <python>
  cds = 'ATGAAACCCGGGTAA'
  cds[6:9] = 'CCT'
  </python>

  What happens?
choices:
  A: "The CDS is updated to 'ATGAAACCTGGGTAA'"
  B: TypeError — strings do not support item assignment
  C: The slice is replaced and the string shrinks if the new codon is shorter
  D: A new string is returned but cds is unchanged
answer: B
explanation: |
  Strings are immutable in Python, so you cannot assign to an index or a
  slice of a string. The statement raises a TypeError. To make this change,
  you must build a new string, for example:
  <python>cds = cds[:6] + 'CCT' + cds[9:]</python>.

---
slug: codon-boundary-alignment
difficulty: medium
topic: Ensuring that positional arithmetic respects the internal structure of sequential data
question: |
  A function extracts the codon that contains a specific nucleotide
  position in a CDS. The CDS is in frame (starts with ATG at index 0).
  Given nucleotide position 7:

  <pre>cds = 'ATGAAACCCTAA'</pre>

  What is the codon containing position 7 and what are its boundaries?
choices:
  A: "'CCC' at indices 6:9 — position 7 falls in the third codon (i=6)"
  B: "'AAC' at indices 3:6 — position 7 is in the second codon"
  C: "'ACC' at indices 7:10 — start the codon at the given position"
  D: "'CCC' at indices 7:9 — extract from position 7 to end of codon"
answer: A
explanation: |
  In a CDS that starts in frame at index 0, codons begin at indices
  0, 3, 6, 9, and so on. To find the codon containing position
  <python>p</python>, compute the codon start as
  <python>(p // 3) * 3</python>. For <python>p = 7</python>, this gives
  <python>6</python>, so the codon is <python>cds[6:9]</python> = <pre>CCC</pre>.
  This preserves reading-frame alignment rather than starting a 3-nt window
  at an arbitrary position.

---
slug: overlapping-substring-count
difficulty: medium
topic: Understanding how built-in search methods handle overlapping matches in sequential data
question: |
  A function checks how many times the dinucleotide <pre>AA</pre> appears in a
  poly-A tract:

  <python>
  seq = 'AAAAAC'
  count_a = seq.count('AA')
  </python>

  What is the value of <python>count_a</python>?
choices:
  A: 4 — every overlapping occurrence is counted
  B: 2 — count returns non-overlapping matches from left to right
  C: 3 — count slides a window one base at a time
  D: 5 — every position where 'A' appears is counted
answer: B
explanation: |
  <python>str.count()</python> counts non-overlapping matches. In
  <pre>AAAAAC</pre>, it matches <pre>AA</pre> at indices 0-1 and again at 2-3,
  for a total of 2. If you need overlapping matches, you must use an
  explicit loop (or another method designed for overlapping pattern search).

---
slug: case-normalization-before-search
difficulty: medium
topic: Ensuring consistent data representation before performing comparisons or lookups
question: |
  GenBank files sometimes represent features in lowercase to indicate
  they were computationally predicted. A function must check whether a
  sequence contains a BamHI site (<pre>GGATCC</pre>), regardless of case:

  <pre>seq = 'atgGGATCCaaa'</pre>

  A student writes three attempts:

  <python>
  attempt1 = 'GGATCC' in seq
  attempt2 = 'GGATCC' in seq.upper()
  attempt3 = 'ggatcc' in seq
  </python>

  Which attempt correctly detects the site regardless of input casing?
choices:
  A: Only attempt2
  B: attempt1 and attempt2
  C: attempt2 and attempt3
  D: All three
answer: A
explanation: |
  Python string matching is case-sensitive. Only <python>attempt2</python>
  normalizes the sequence before searching, so it works whether the site is
  uppercase, lowercase, or mixed case in the input. The other attempts may
  work on some inputs but are not robust to arbitrary capitalization.